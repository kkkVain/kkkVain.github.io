<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="en">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="Keep moving. Don&apos;t settle.">
<meta property="og:type" content="website">
<meta property="og:title" content="Coco">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="Coco">
<meta property="og:description" content="Keep moving. Don&apos;t settle.">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Coco">
<meta name="twitter:description" content="Keep moving. Don&apos;t settle.">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/2/"/>





  <title>Coco</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Coco</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Hello world</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/24/车辆检测2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ke Yu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coco">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/24/车辆检测2/" itemprop="url">车辆检测论文（2）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-10-24T20:03:13+08:00">
                2017-10-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/图像/" itemprop="url" rel="index">
                    <span itemprop="name">图像</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>2017年</p>
<h4 id="Adaptive-ViBe-background-model-for-vehicle-detection"><a href="#Adaptive-ViBe-background-model-for-vehicle-detection" class="headerlink" title="Adaptive ViBe background model for vehicle detection"></a>Adaptive ViBe background model for vehicle detection</h4><p>BY 东南大学的好几个人</p>
<p>这和刚才那篇架构，也太像了吧….</p>
<h4 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h4><p>在实际应用中，光照变化会引起背景的巨大变化，所以需要对这个背景建模算法（ViBe）进行改进。</p>
<ul>
<li>一是定义两种车辆检测的误差和误差方程；</li>
<li>二是根据这两种误差的范围，定义合理的评估环境来调整不合理的阙值（用来保证这个模型的改进之处）；</li>
<li>三是实际场景下的实验体现了改进的ViBe模型相比高斯模型、codeback模型和固定阙值的ViBe模型有更好的车辆检测准确度；</li>
</ul>
<h4 id="文章结构"><a href="#文章结构" class="headerlink" title="文章结构"></a>文章结构</h4><ul>
<li>一 介绍</li>
<li>二 ViBe 模型介绍<br>  ViBe 模型的初始化；<br>  车辆检测；<br>  模型改进；</li>
<li>三 自适应ViBe模型<br>  分析ViBe模型<br>  定义车辆检测误差方程<pre><code>帧差的二值化
两种误差方程
</code></pre>  自适应阙值调整</li>
<li>四 测试结果</li>
<li>五 结论</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/24/车辆检测1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ke Yu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coco">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/24/车辆检测1/" itemprop="url">车辆检测论文（1）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-10-24T18:15:54+08:00">
                2017-10-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/图像/" itemprop="url" rel="index">
                    <span itemprop="name">图像</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="A-vehicle-detection-method-in-tunnel-video-based-on-ViBe-algorithm"><a href="#A-vehicle-detection-method-in-tunnel-video-based-on-ViBe-algorithm" class="headerlink" title="A vehicle detection method in tunnel video based on ViBe algorithm"></a>A vehicle detection method in tunnel video based on ViBe algorithm</h4><p> BY 武大 Zhu Qiming Ma ChengQian</p>
<h4 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h4><p>在隧道视频中的车辆检测，基于ViBe（Visual Background Extraction 一种目标检测）算法，主要包括三步：</p>
<ul>
<li>一是对视频进行直方图均衡化，提高视频图像的质量；</li>
<li>二是调节ViBe算法根据背景建模并且检测移动的车辆；</li>
<li>三是用形态滤波器去除检测结果的噪点。</li>
</ul>
<h4 id="文章结构"><a href="#文章结构" class="headerlink" title="文章结构"></a>文章结构</h4><ul>
<li>一 介绍</li>
<li>二 ViBe建模算法介绍<br>  公式，流程等。</li>
<li>三 隧道车辆检测方法<br>  按照Abstract中的步骤进行叙述</li>
<li>四 实验结果</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/24/车辆检测10/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ke Yu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coco">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/24/车辆检测10/" itemprop="url">车辆检测论文（8）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-10-24T15:41:12+08:00">
                2017-10-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/图像/" itemprop="url" rel="index">
                    <span itemprop="name">图像</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Vehicle Detection by a Context-Aware<br>Multichannel Feature Pyramid</p>
<h4 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h4><p>现有的appearance-based车辆检测方法主要都是运用特征算子进行检测，比如Haar-like,方向梯度直方图，尺度变化特征转换等等。然而，当需要处理光照、缩放、形态变化和复杂的背景时，这些局部特征都有局限性。现在需要一种有辨别性和鲁棒性的特征。为了实习这个目的，本文提出了一个新奇的使用上下文感知多通道特征金字塔的算法。本文主要贡献是提出两种上下文感知的结构描述子，这两种描述子分别被叫做context-aware difference sign transform feature和context-aware difference magnitude transform feature。 图片被置于cell的稠密网格中，每个cell都由局部细节和上下文感知结构描述子描述。这个描述子可以捕捉到这些cells的上下文感知结构信息。该特征金字塔可以为车辆检测提供更高效的特征。使用两个公共交通数据集进行的实验体现这个方法相比state-of-the-art方法有更高的性能。更重要的是，即便是车辆出现了形态变化或者相机视点改变，该实验结果也很令人满意。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/24/车辆检测9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ke Yu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coco">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/24/车辆检测9/" itemprop="url">车辆检测论文（7）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-10-24T15:23:54+08:00">
                2017-10-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/图像/" itemprop="url" rel="index">
                    <span itemprop="name">图像</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Efficient L-Shape Fitting for Vehicle Detection Using Laser Scanners BY Xiao Zhang, Wenda Xu, Chiyu Dong and John M. Dolan<br>2017</p>
<h4 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h4><p>自动驾驶中，周围汽车的检测是一项重要的任务，最近引起了广泛的关注。当使用雷达扫描器时，L-Shape装置是基于模型的车辆检测和追踪的关键步骤，需要彻底的调查和综合的研究。在本篇论文中，我们将L-shape装置公式化为一个最优问题，寻找这个最优解的方法被提出。我们的方法不依赖于雷达扫描序列信息，并且支持多雷达扫描器的便捷数据融合。这非常的高效，并且几乎不涉及通信参数。同时此方法非常的灵活，可以适用于多种多样的条件不同的装置。使用产品分数的雷达扫描器的路上实验显示了这个方法的有效性和鲁棒性。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/24/车辆检测6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ke Yu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coco">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/24/车辆检测6/" itemprop="url">车辆检测论文（6）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-10-24T14:33:23+08:00">
                2017-10-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/图像/" itemprop="url" rel="index">
                    <span itemprop="name">图像</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Automated Vehicle Detection Using Optical Fiber<br>Communication<br>BY Samarth Gupta ， Professor Vikas Upadhyaya<br>Electronics and Communication Department NIIT University<br>Neemrana, India</p>
<h4 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h4><p>汽车自动探测是很有挑战性的领域，由于复杂的交通情况，交通监控系统检测更复杂更有挑战性。在本次研究中，我们探索到光纤技术可以用于负荷传感器来测量车辆以普通速度前进时的种类。用于传感器的光纤的光学特性在一个纤维弯曲实验中第一次获得并且与在示波器中检测到的各种各样的传播特性比如振幅、相移等相关联。实验在使用光纤来用来做负荷传感器的情况下进行。实验结果也体现了当传统传感器不能捕捉精确的的数据时使用光纤纤维网络来传递数据的好处。于是我们试图找到使用车辆的重量进行车辆检测并且克服在军事战争中用来检测车辆传感器的错误的可能性。</p>
<h4 id="文章结构"><a href="#文章结构" class="headerlink" title="文章结构"></a>文章结构</h4><ul>
<li>一 介绍</li>
<li>二 系统需要和工作</li>
<li>三 结果和结论</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/24/Android源码设计模式解析与实战----状态模式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ke Yu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coco">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/24/Android源码设计模式解析与实战----状态模式/" itemprop="url">Android源码设计模式解析与实战----状态模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-10-24T13:21:34+08:00">
                2017-10-24
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><pre><code>多个对象都可以处理同一个请求，但具体由哪个对象处理则在运行时动态处理。
</code></pre><h3 id="Android源码解析"><a href="#Android源码解析" class="headerlink" title="Android源码解析"></a>Android源码解析</h3><pre><code>常说的View的分发机制，就是使用了责任链模式。一层一层的往下找处理事件的目标，当onTouchEvent返回false的时候，就代表这个view不是目标，不处理这个事件。
</code></pre><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><pre><code>通过有序的BroadcastReceiver可以实现全局责任链模式。因为有序广播可以决定消息是否继续传下去。
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/24/handler解析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ke Yu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coco">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/24/handler解析/" itemprop="url">Handler解析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-09-24T15:23:42+08:00">
                2017-09-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>主要为了解决不能在UI线程更新控件的问题。</p>
<p>由于Handler运行在主线程中(UI线程中)，  它与子线程可以通过Message对象来传递数据， 这个时候，Handler就承担着接受子线程传过来的(子线程用sendMessage()方法传递Message对象，里面包含数据)  ， 把这些消息放入主线程队列中，配合主线程进行更新UI。</p>
<h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>handler可以分发Message对象和Runnable对象到主线程中， 每个Handler实例，都会绑定到创建他的线程中(一般是位于主线程)，它有两个作用：</p>
<p>(1)安排消息或Runnable在某个主线程中某个地方执行；</p>
<p>post类方法允许你排列一个Runnable对象到主线程队列中</p>
<p>sendMessage类方法， 允许你安排一个带数据的Message对象到队列中，等待更新。</p>
<p>(2）将一个任务放入队列，以便它可以在另外的线程中执行。</p>
<p><img src="handler" alt="http://ovwunej09.bkt.clouddn.com/handler.png"></p>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><h6 id="A-Handler"><a href="#A-Handler" class="headerlink" title="A.Handler"></a>A.Handler</h6><p>1）几个构造函数，最终主要是两个：</p>
<p>a.使用传入的looper</p>
<p>public Handler(Looper looper, Callback callback, boolean async) {</p>
<p>​    mLooper = looper;//指定该handler实例所绑定的looper实例</p>
<p>​    mQueue = looper.mQueue;</p>
<p>​    mCallback = callback; //给定回调接口进行消息处理。</p>
<p>​    mAsynchronous = async;</p>
<p>}</p>
<p><strong><strong>思考：looper遍历queue中的Msg ，用msg的target handler进行处理，这是looper 关联handler，那么handler关联looper是什么情况？</strong></strong></p>
<p>b.使用默认的looper. Handler最终的构造函数：（async默认是false）</p>
<p>public Handler(Callback callback, boolean async) {</p>
<p>​    if (FIND_POTENTIAL_LEAKS) {</p>
<p>​        final Class&lt;? extends Handler&gt; klass = getClass();</p>
<p>​        if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp;</p>
<p>​                (klass.getModifiers() &amp; Modifier.STATIC) == 0) {</p>
<p>​            Log.w(TAG, “The following Handler class should be static or leaks might occur: “ +</p>
<p>​                klass.getCanonicalName());</p>
<p>​        }</p>
<p>​    }</p>
<p>​    mLooper = Looper.myLooper(); //静态函数，从sThreadLocal中取出变量</p>
<p>​    if (mLooper == null) {</p>
<p>​        throw new RuntimeException(</p>
<p>​            “Can’t create handler inside thread that has not called Looper.prepare()”);</p>
<p>​    }</p>
<p>​    mQueue = mLooper.mQueue;</p>
<p>​    mCallback = callback;</p>
<p>​    mAsynchronous = async;</p>
<p>}</p>
<p>mLooper的默认值是什么？只有Looper调用了prepare()才会有！</p>
<p>// sThreadLocal.get() will return null unless you’ve called prepare().</p>
<p>static final ThreadLocal<looper> sThreadLocal = new ThreadLocal<looper>();</looper></looper></p>
<p>也就是说，handler在构造前，要先在这个线程中执行Looper.prepare()，使Looper.myLooper()能成功返回当前线程threadLocal的looper！</p>
<p>也就是说handler关联looper，是一开始在构造函数中就关联起来的了，handler构造时，要么传入一个存在了的looper（looper.prepare()创造），要么当前线程已经调用looper.prepare()</p>
<p>终究就是要先有Looper.prepare()</p>
<p>2）所有的常用的send和post方法，最终调用的都是sendMessageAtTime(Message, long) 这个方法（如果传入的参数是runnable的话，会先调用getPostMessage(Runnable) 或getPostMessage(Runnable, Object)方法获取消息）</p>
<p>假设看看postDelayed：</p>
<p>A.public final boolean postDelayed(Runnable r, long delayMillis)</p>
<p>{</p>
<p>​    return sendMessageDelayed(getPostMessage(r), delayMillis);—&gt;B</p>
<p>}</p>
<p>其中get函数用来设置runnable依附的message</p>
<p>private static Message getPostMessage(Runnable r) {</p>
<p>​    Message m = Message.obtain();</p>
<p>​    m.callback = r;</p>
<p>​    return m;</p>
<p>}</p>
<p>B.public final boolean sendMessageDelayed(Message msg, long delayMillis)</p>
<p>{</p>
<p>​    if (delayMillis &lt; 0) {</p>
<p>​        delayMillis = 0;</p>
<p>​    }</p>
<p>​    return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);—&gt;C</p>
<p>}</p>
<p>重点函数：</p>
<p>// 将message入队，并在指定时间到之前将该消息放在所有挂起的消息之后。</p>
<p>C.public boolean sendMessageAtTime(Message msg, long uptimeMillis) {</p>
<p>​        MessageQueue queue = mQueue;</p>
<p>​        if (queue == null) {</p>
<p>​            RuntimeException e = new RuntimeException(</p>
<p>​                    this + “ sendMessageAtTime() called with no mQueue”);</p>
<p>​            Log.w(“Looper”, e.getMessage(), e);</p>
<p>​            return false;</p>
<p>​        }</p>
<p>​        return enqueueMessage(queue, msg, uptimeMillis);</p>
<p>​    }</p>
<p>private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) {</p>
<p>​    msg.target = this; //为message指定target为该handler实例（精髓）</p>
<p>​    if (mAsynchronous) {</p>
<p>​        msg.setAsynchronous(true);</p>
<p>​    }</p>
<p>​    return queue.enqueueMessage(msg, uptimeMillis);</p>
<p>}</p>
<p>PS: 发现了两个强行插队，让runnable在message 的下一个Loop直接执行的函数：</p>
<p>其实就是把delaymills置为0= =</p>
<p>public final boolean postAtFrontOfQueue(Runnable r)</p>
<p>{</p>
<p>​    return sendMessageAtFrontOfQueue(getPostMessage(r));</p>
<p>}</p>
<p>public final boolean sendMessageAtFrontOfQueue(Message msg) {</p>
<p>​    MessageQueue queue = mQueue;</p>
<p>​    if (queue == null) {</p>
<p>​        RuntimeException e = new RuntimeException(</p>
<p>​            this + “ sendMessageAtTime() called with no mQueue”);</p>
<p>​        Log.w(“Looper”, e.getMessage(), e);</p>
<p>​        return false;</p>
<p>​    }</p>
<p>​    return enqueueMessage(queue, msg, 0);</p>
<p>}</p>
<p>D. loop()函数中，msg.target调用的函数：</p>
<p>执行优先级：1)msg中含有callback（用post方法时），用message的这个callback方法处理msg；2）构造这个handler时传入了callback，同样用callback处理Msg；3）直接用handler的重载函数handleMessage处理msg</p>
<p>/**</p>
<p> * Handle system messages here.</p>
<p> */</p>
<p>public void dispatchMessage(Message msg) {</p>
<p>​    if (msg.callback != null) {</p>
<p>​        handleCallback(msg);</p>
<p>​    } else {</p>
<p>​        if (mCallback != null) {</p>
<p>​            if (mCallback.handleMessage(msg)) {</p>
<p>​                return;</p>
<p>​            }</p>
<p>​        }</p>
<p>​        handleMessage(msg);</p>
<p>​    }</p>
<p>}</p>
<p>######B.Message</p>
<p>extends Object</p>
<p>implements Parcelable</p>
<p>一个message对象包含一个自身的描述信息和一个可以发给handler的任意数据对象。</p>
<p>虽然Message的构造方法是public的，但实例化Message的最好方法是调用Message.obtain() 或 Handler.obtainMessage() ，因为这两个方法是从一个可回收利用的message对象回收池中获取Message实例（实际上最终调用的仍然是Message.obtain()）。该回收池用于将每次交给handler处理的message对象进行回收。 </p>
<h5 id="C-MessageQueue"><a href="#C-MessageQueue" class="headerlink" title="C.MessageQueue"></a>C.MessageQueue</h5><p>MessageQueue是用来存放Message的集合，并由Looper实例来分发里面的Message对象。同时，message并不是直接加入到MessageQueue中的, 而是通过与Looper对象相关联的MessageQueue.IdleHandler 对象来完成的。我们可以通过Looper.myQueue() 方法来获得当前线程的MessageQueue。 </p>
<p>MQ实际上没有采用队列，而是采用单链表的数据结构来存储消息列表。</p>
<h5 id="D-Looper"><a href="#D-Looper" class="headerlink" title="D.Looper"></a>D.Looper</h5><p>Looper是线程用来运行消息循环(message loop)的类。默认情况下，线程并没有与之关联的Looper，可以通过在线程中调用Looper.prepare() 方法来获取，用来执行loop，并通过Looper.loop() 无限循环地获取并分发MessageQueue中的消息，直到所有消息全部处理。</p>
<p>* </p><p>This is a typical example of the implementation of a Looper thread,</p>
<p>* using the separation of {@link #prepare} and {@link #loop} to create an</p>
<p>* initial Handler to communicate with the Looper.</p>
<p>*</p>
<p>* <pre></pre></p>
<p>*  class LooperThread extends Thread {</p>
<p>*      public Handler mHandler;</p>
<p>*</p>
<p>*      public void run() {</p>
<p>*          Looper.prepare(); // 创建一个looper，来循坏获取处理MessageQueue里面的消息</p>
<p>*</p>
<p>*          mHandler = new Handler() { // 那么这个handler，就不是在主线程处理msg了，而是在looperThread上处理</p>
<p>*              public void handleMessage(Message msg) {</p>
<p>*                  // process incoming messages here</p>
<p>*              }</p>
<p>*          };</p>
<p>*</p>
<p>*          Looper.loop();  // 处理messagequeue的关键函数</p>
<p>*      }</p>
<p>*  }</p>
<p>1）public static void prepare() {</p>
<p>​    prepare(true);</p>
<p>}</p>
<p>private static void prepare(boolean quitAllowed) { // quitAllowed：是否允许调用quit()函数</p>
<p>​    if (sThreadLocal.get() != null) {</p>
<p>​        throw new RuntimeException(“Only one Looper may be created per thread”);</p>
<p>​    }</p>
<p>​    sThreadLocal.set(new Looper(quitAllowed));</p>
<p>}</p>
<p>可以看到，调用prepare()方法时，会执行prepare(boolean quitAllowed) 方法，其中得先判断sThreadLocal是否为空，不为空才将新建的Looper实例放进sThreadLocal对象中。那么这个sThreadLocal是什么呢？它是一个本地线程存储类，所有线程共享这个对象，但是这个对象对每一个线程而言却具有不同的值，且每个线程对这个对象的访问或修改都不会影响到其他线程，即它的值对于每个线程来说都是独立的。 不同线程的Looper相互独立，之所以能做到这一点，就是借助ThreadLocal来实现的。</p>
<p>sThreadLocal.set(new Looper(quitAllowed))则是把一个新建的Looper实例放进sThreadLocal对象中，而Looper的构造函数内部实现如下,创建一个新的MessageQueue对象并绑定当前线程:</p>
<p>private Looper(boolean quitAllowed) {</p>
<p>​    mQueue = new MessageQueue(quitAllowed);</p>
<p>​    mThread = Thread.currentThread();// 这个mThread在Looper类中毫无用处….</p>
<p>}</p>
<p>2）public static void loop() {}代码很长</p>
<p>public static void loop() {</p>
<p>​    final Looper me = myLooper(); —-&gt;  A. 从threadLocal.get()取looper</p>
<p>​    if (me == null) {</p>
<p>​        throw new RuntimeException(“No Looper; Looper.prepare() wasn’t called on this thread.”);</p>
<p>​    }</p>
<p>​    final MessageQueue queue = me.mQueue;</p>
<p>​    // Make sure the identity of this thread is that of the local process,</p>
<p>​    // and keep track of what that identity token actually is.</p>
<p>​    Binder.clearCallingIdentity();</p>
<p>​    final long ident = Binder.clearCallingIdentity();</p>
<p>​    for (;;) {</p>
<p>​        Message msg = queue.next(); // might block</p>
<p>​        if (msg == null) {</p>
<p>​            // No message indicates that the message queue is quitting.</p>
<p>​            return;</p>
<p>​        }</p>
<p>​        // This must be in a local variable, in case a UI event sets the logger</p>
<p>​        final Printer logging = me.mLogging;</p>
<p>​        if (logging != null) {</p>
<p>​            logging.println(“&gt;&gt;&gt;&gt;&gt; Dispatching to “ + msg.target + “ “ +</p>
<p>​                    msg.callback + “: “ + msg.what);</p>
<p>​        }</p>
<p>​        final long traceTag = me.mTraceTag;</p>
<p>​        if (traceTag != 0 &amp;&amp; Trace.isTagEnabled(traceTag)) {</p>
<p>​            Trace.traceBegin(traceTag, msg.target.getTraceName(msg));</p>
<p>​        }</p>
<p>​        try {</p>
<p>​            msg.target.dispatchMessage(msg); // handler不断把msg入队，这里从队列取出msg，然后用msg的handler进行消息处理</p>
<p>​        } finally {</p>
<p>​            if (traceTag != 0) {</p>
<p>​                Trace.traceEnd(traceTag);</p>
<p>​            }</p>
<p>​        }</p>
<p>​        if (logging != null) {</p>
<p>​            logging.println(“&lt;&lt;&lt;&lt;&lt; Finished to “ + msg.target + “ “ + msg.callback);</p>
<p>​        }</p>
<p>​        // Make sure that during the course of dispatching the</p>
<p>​        // identity of the thread wasn’t corrupted.</p>
<p>​        final long newIdent = Binder.clearCallingIdentity();</p>
<p>​        if (ident != newIdent) {</p>
<p>​            Log.wtf(TAG, “Thread identity changed from 0x”</p>
<p>​                    + Long.toHexString(ident) + “ to 0x”</p>
<p>​                    + Long.toHexString(newIdent) + “ while dispatching to “</p>
<p>​                    + msg.target.getClass().getName() + “ “</p>
<p>​                    + msg.callback + “ what=” + msg.what);</p>
<p>​        }</p>
<p>​        msg.recycleUnchecked();</p>
<p>​    }</p>
<p>}</p>
<p>这个方法，主要是通过myLooper()获取当前线程的Looper实例，如果这个实例存在，就取出这个looper的MQ，然后通过一个死循环，不断的调用queue.next();取出message，如果msg没有target（想想enqueueMessage里面为msg指定了target），就退出循环。</p>
<p>如果有target:msg.target.dispatchMessage(msg);</p>
<p>把真正的处理工作交给msg的target，即对应的handler，直到队列为空。</p>
<p>该函数在每次msg的循环的最后都会调用msg.recycle();回收msg资源。</p>
<p>A.public static @Nullable Looper myLooper() {</p>
<p>​    return sThreadLocal.get();</p>
<p>}</p>
<p>3）Message next() {} 代码也很长，不贴了。</p>
<p>主要功能就是：取出单链表的头节点，对相应指针进行操作，最后返回这个头节点。</p>
<h3 id="灵魂拷问"><a href="#灵魂拷问" class="headerlink" title="灵魂拷问"></a>灵魂拷问</h3><p><strong>思考一：loop() 这里采用的是无限循环，该循环会不会特别消耗CPU资源？？</strong></p>
<p>其实并不会，如果MQ里面有消息，next（）自然能不停的取到msg去交给handler进行处理，如果取不到，那么在nex()的nativePollOnce(ptr, nextPollTimeoutMillis);  就会阻塞该线程，主线程会释放CPU资源进入休眠状态，当有下一个工作到来时，才通过往pipe管道写端写入数据来唤醒主线程工作。这里涉及到的是Linux的pipe/epoll机制，epoll机制是一种IO多路复用机制，可以同时监控多个描述符，当某个描述符就绪(读或写就绪)，则立刻通知相应程序进行读或写操作，本质同步I/O，即读写是阻塞的。所以说，主线程大多数时候都是处于休眠状态，并不会消耗大量CPU资源。</p>
<p>4）public void dispatchMessage(Message msg) {</p>
<p>​    if (msg.callback != null) {</p>
<p>​        handleCallback(msg); ①</p>
<p>​    } else {</p>
<p>​        if (mCallback != null) {</p>
<p>​            if (mCallback.handleMessage(msg)) {②</p>
<p>​                return;</p>
<p>​            }</p>
<p>​        }</p>
<p>​        handleMessage(msg);③</p>
<p>​    }</p>
<p>}</p>
<p>…</p>
<p>① private static void handleCallback(Message message) {</p>
<p>​    message.callback.run();</p>
<p>}</p>
<p>这里我们可以看到，在分发消息时三个方法的优先级分别如下：</p>
<p>①Message的回调方法优先级最高，即message.callback.run()；</p>
<p>②Handler的回调方法优先级次之，即Handler.mCallback.handleMessage(msg)；</p>
<p>③Handler的默认方法优先级最低，即Handler.handleMessage(msg)</p>
<p><strong>思考二、为什么looper.loop()要使用死循环？</strong></p>
<p>对于线程既然是一段可执行的代码，当可执行代码执行完成后，线程生命周期便该终止了，线程退出。而对于主线程，我们是绝不希望会被运行一段时间，自己就退出，那么如何保证能一直存活呢？简单做法就是可执行代码是能一直执行下去的，死循环便能保证不会被退出，例如，binder线程也是采用死循环的方法，通过循环方式不同与Binder驱动进行读写操作，当然并非简单地死循环，无消息时会休眠。但这里可能又引发了另一个问题，既然是死循环又如何去处理其他事务呢？通过创建新线程的方式。</p>
<p><strong>思考三、哪里为Looper.loop（)创建了新线程？</strong></p>
<p>在代码ActivityThread.main()中：</p>
<p>public static void main(String[] args) {</p>
<p>​    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, “ActivityThreadMain”);</p>
<p>​    SamplingProfilerIntegration.start();</p>
<p>​    // CloseGuard defaults to true and can be quite spammy.  We</p>
<p>​    // disable it here, but selectively enable it later (via</p>
<p>​    // StrictMode) on debug builds, but using DropBox, not logs.</p>
<p>​    CloseGuard.setEnabled(false);</p>
<p>​    Environment.initForCurrentUser();</p>
<p>​    // Set the reporter for event logging in libcore</p>
<p>​    EventLogger.setReporter(new EventLoggingReporter());</p>
<p>​    // Make sure TrustedCertificateStore looks in the right place for CA certificates</p>
<p>​    final File configDir = Environment.getUserConfigDirectory(UserHandle.myUserId());</p>
<p>​    TrustedCertificateStore.setDefaultUserDirectory(configDir);</p>
<p>​    Process.setArgV0(“<pre-initialized>“);</pre-initialized></p>
<p>​    //创建Looper和MessageQueue对象，用于处理主线程的消息</p>
<p>​    Looper.prepareMainLooper();—–&gt;A</p>
<p>​    // 创建ActivityThread对象</p>
<p>​    ActivityThread thread = new ActivityThread();</p>
<p>​    //建立Binder通道 (创建新线程)</p>
<p>​    thread.attach(false);</p>
<p>​    if (sMainThreadHandler == null) {</p>
<p>​        sMainThreadHandler = thread.getHandler();</p>
<p>​    }</p>
<p>​    if (false) {</p>
<p>​        Looper.myLooper().setMessageLogging(new</p>
<p>​                LogPrinter(Log.DEBUG, “ActivityThread”));</p>
<p>​    }</p>
<p>​    // End of event ActivityThreadMain.</p>
<p>​    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</p>
<p>​    Looper.loop();</p>
<p>​    throw new RuntimeException(“Main thread loop unexpectedly exited”);</p>
<p>}</p>
<p>A.我们自己不能调用这个function，如果调用了的话- -会 怎么样呢 ？？</p>
<p>/**</p>
<p> * Initialize the current thread as a looper, marking it as an</p>
<p> * application’s main looper. The main looper for your application</p>
<p> * is created by the Android environment, so you should never need</p>
<p> * to call this function yourself.  See also: {@link #prepare()}</p>
<p> */</p>
<p>public static void prepareMainLooper() {</p>
<p>​    prepare(false);</p>
<p>​    synchronized (Looper.class) {</p>
<p>​        if (sMainLooper != null) {</p>
<p>​            throw new IllegalStateException(“The main Looper has already been prepared.”);</p>
<p>​        }</p>
<p>​        sMainLooper = myLooper();</p>
<p>​    }</p>
<p>}</p>
<p>thread.attach(false)；便会创建一个Binder线程（具体是指ApplicationThread，Binder的服务端，用于接收系统服务AMS发送来的事件），该Binder线程通过Handler将Message发送给主线程。</p>
<p>ActivityThread实际上并非线程，不像HandlerThread类，ActivityThread并没有真正继承Thread类，只是往往运行在主线程，该人以线程的感觉，其实承载ActivityThread的主线程就是由Zygote fork而创建的进程。</p>
<p><strong>思考四、最后，扩展到Activity的生命周期。Activity的生命周期是怎么实现在死循环体外能够执行起来的？</strong></p>
<p>ActivityThread的内部类H继承于Handler，通过handler消息机制，简单说Handler机制用于同一个进程的线程间通信。Activity的生命周期都是依靠主线程的Looper.loop，当收到不同Message时则采用相应措施：</p>
<p>在H.handleMessage(msg)方法中，根据接收到不同的msg，执行相应的生命周期。</p>
<p>比如收到msg=H.LAUNCH_ACTIVITY，则调用ActivityThread.handleLaunchActivity()方法，最终会通过反射机制，创建Activity实例，然后再执行Activity.onCreate()等方法；  </p>
<p>再比如收到msg=H.PAUSE_ACTIVITY，则调用ActivityThread.handlePauseActivity()方法，最终会执行Activity.onPause()等方法。</p>
<p>主线程的消息又是哪来的呢？当然是App进程中的其他线程通过Handler发送给主线程，</p>
<p><strong>思考五、handler怎么进行线程切换的？</strong></p>
<p>Handler类的介绍写了：在自己的子线程中，调用post或者sendMessage函数，最后都是调用sendMessageAtTime函数，反正就是把message（post的runnalble 会经过包装，成为message）放到queue中让looper循环获取。</p>
<p>You can create your own threads, and communicate back with</p>
<p>* the main application thread through a Handler.  This is done by calling</p>
<p>* the same <em>post</em> or <em>sendMessage</em> methods as before, but from</p>
<p>* your new thread. </p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/11/RxJava/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ke Yu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coco">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/11/RxJava/" itemprop="url">RxJAVA初步理解(1)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-09-11T23:29:17+08:00">
                2017-09-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>RxJAVA</strong></p>
<p>① subscribe函数：</p>
<p>调用了observable.onSubscribe.call(subscriber)<br>observable:最后一个变换后的observable<br>onSubscribe创建最后一个observable时传入的参数<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SchedulerSupport</span>(SchedulerSupport.NONE)</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(Observer&lt;? <span class="keyword">super</span> T&gt; observer)</span> </span>&#123;</span><br><span class="line">	ObjectHelper.requireNonNull(observer, <span class="string">"observer is null"</span>);</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">	<span class="comment">// onXXXX相关的，和刚才的onAssembly是一个套路，同样的使用了Hook</span></span><br><span class="line">		observer = RxJavaPlugins.onSubscribe(<span class="keyword">this</span>, observer);</span><br><span class="line">		ObjectHelper.requireNonNull(observer, <span class="string">"Plugin returned null Observer"</span>);</span><br><span class="line">		<span class="comment">//开始订阅，这个subscribeActual函数，作为onAssembly()的参数时的类，都有重写，</span></span><br><span class="line">		subscribeActual(observer);-----&gt; <span class="number">2</span>A</span><br><span class="line">	&#125; <span class="keyword">catch</span> (NullPointerException e) &#123; <span class="comment">// NOPMD</span></span><br><span class="line">		<span class="keyword">throw</span> e;</span><br><span class="line">	&#125; <span class="keyword">catch</span> (Throwable e) &#123;Exceptions.throwIfFatal(e);</span><br><span class="line">		<span class="comment">// can't call onError because no way to know if a Disposable has been set or not can't call onSubscribe because the call might have set a Subscription</span></span><br><span class="line">		already RxJavaPlugins.onError(e);</span><br><span class="line">		NullPointerException npe = <span class="keyword">new</span> NullPointerException(<span class="string">"Actually not, but can't throw other exceptions due to RS"</span>);</span><br><span class="line">			npe.initCause(e);</span><br><span class="line">			<span class="keyword">throw</span> npe;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>②create函数<br>onJust：<br>A.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SchedulerSupport</span>(SchedulerSupport.NONE)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Observable&lt;T&gt; <span class="title">just</span><span class="params">(T item)</span> </span>&#123;</span><br><span class="line">	ObjectHelper.requireNonNull(item, <span class="string">"The item is null"</span>);</span><br><span class="line">	<span class="keyword">return</span> RxJavaPlugins.onAssembly(<span class="keyword">new</span> ObservableJust&lt;T&gt;(item));----&gt;B</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>B.</strong><br>所有onXXXX的函数，都是hook function.<br>onAssembly这个函数：把传进来的各种new<br>ObservableXXX<t>转换为Observable<t></t></t></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Calls the associated hook function.</span><br><span class="line"><span class="comment">/* @param &lt;T&gt; the value type</span></span><br><span class="line"><span class="comment">   @param source the hook's input value</span></span><br><span class="line"><span class="comment">   @return the value returned by the hook</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(&#123; <span class="string">"rawtypes"</span>, <span class="string">"unchecked"</span> &#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Observable&lt;T&gt; <span class="title">onAssembly</span><span class="params">(Observable&lt;T&gt; source)</span> </span>&#123;</span><br><span class="line">	Function&lt;Observable, Observable&gt; f = onObservableAssembly; <span class="comment">// 初始值是null</span></span><br><span class="line">	<span class="keyword">if</span> (f != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> apply(f,source); ---\&gt;C,函数f是源码自带的onObservableAssembly</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> source;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>C.</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Wraps the call to the function in try-catch and propagates thrown checked exceptions as RuntimeException.</span></span><br><span class="line"><span class="comment">@param &lt;T&gt; the input type</span></span><br><span class="line"><span class="comment">@param &lt;R&gt; the output type</span></span><br><span class="line"><span class="comment">@param f the function to call, not null (not verified)</span></span><br><span class="line"><span class="comment">@param t the parameter value to the function</span></span><br><span class="line"><span class="comment">@return the result of the function call</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">static &lt;T, R&gt; R apply(Function&lt;T, R&gt; f, T t) &#123;</span></span><br><span class="line"><span class="comment">	try &#123;</span></span><br><span class="line"><span class="comment">		return f.apply(t); ---&gt;D，自带的函数f进行apply</span></span><br><span class="line"><span class="comment">	&#125; catch (Throwable ex) &#123;</span></span><br><span class="line"><span class="comment">		throw ExceptionHelper.wrapOrThrow(ex);</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br></pre></td></tr></table></figure></p>
<p><strong>D.</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* A functional interface that takes a value and returns another value, possibly with a different type and allows throwing a checked exception.</span></span><br><span class="line"><span class="comment">@param &lt;T&gt; the input value type</span></span><br><span class="line"><span class="comment">@param &lt;R&gt; the output value type</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">public interface Function&lt;T, R&gt; &#123;</span></span><br><span class="line"><span class="comment">/* Apply some calculation to the input value and return some other value.*/</span></span><br><span class="line">	<span class="meta">@param</span> t the input value</span><br><span class="line">	<span class="meta">@return</span> the output value</span><br><span class="line">	<span class="meta">@throws</span> Exception on error</span><br><span class="line">	</span><br><span class="line">	<span class="function">R <span class="title">apply</span><span class="params">(T t)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>E.subscribeOn:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@param</span> scheduler the &#123;<span class="meta">@link</span> Scheduler&#125; to perform subscription actions on</span><br><span class="line"><span class="meta">@return</span> the source ObservableSource modified so that its subscriptions happen on the specified &#123;<span class="meta">@link</span> Scheduler&#125;</span><br><span class="line">@see &lt;a href="http://reactivex.io/documentation/operators/subscribeon.html"&gt;ReactiveX operators documentation: SubscribeOn&lt;/a&gt;</span><br><span class="line">@see &lt;a href="http://www.grahamlea.com/2014/07/rxjava-threading-examples/"&gt;RxJava Threading Examples&lt;/a&gt;</span><br><span class="line">@see #observeOn</span><br><span class="line"><span class="meta">@SchedulerSupport</span>(SchedulerSupport.CUSTOM)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Observable&lt;T&gt; <span class="title">subscribeOn</span><span class="params">(Scheduler scheduler)</span> </span>&#123;</span><br><span class="line">	ObjectHelper.requireNonNull(scheduler, <span class="string">"scheduler is null"</span>);</span><br><span class="line">		<span class="keyword">return</span> RxJavaPlugins.onAssembly(<span class="keyword">new</span> ObservableSubscribeOn&lt;T&gt;(<span class="keyword">this</span>,scheduler));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>onAssembly就是刚才分析的那个，把当前的observable和scheduler整合，并且以observable<t>的形式返回。</t></p>
<p><strong>F.</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@param</span> &lt;R&gt; the value type of the inner ObservableSources and the output type</span><br><span class="line"><span class="meta">@param</span> mapper a function that, when applied to an item emitted by the source</span><br><span class="line">ObservableSource, returns an ObservableSource</span><br><span class="line"><span class="meta">@return</span> an Observable that emits the result of applying the transformation function to each item emitted by the source ObservableSource and merging the results of the</span><br><span class="line">ObservableSources obtained from <span class="keyword">this</span> transformation</span><br><span class="line">@see &lt;a href="http://reactivex.io/documentation/operators/flatmap.html"\&gt;ReactiveX operators documentation: FlatMap&lt;/a&gt;</span><br><span class="line"><span class="meta">@SchedulerSupport</span>(SchedulerSupport.NONE)</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> &lt;R&gt; <span class="function">Observable&lt;R&gt; <span class="title">flatMap</span><span class="params">(Function&lt;? <span class="keyword">super</span></span></span></span><br><span class="line"><span class="function"><span class="params">T, ? extends ObservableSource&lt;? extends R&gt;&gt; mapper)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> flatMap(mapper, <span class="keyword">false</span>); ----&gt; G</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>G.</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SchedulerSupport</span>(SchedulerSupport.NONE)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> &lt;R&gt; <span class="function">Observable&lt;R&gt; <span class="title">flatMap</span><span class="params">(Function&lt;? <span class="keyword">super</span> T, ? extends ObservableSource&lt;? extends R&gt;&gt; mapper, <span class="keyword">boolean</span> delayErrors, <span class="keyword">int</span> maxConcurrency, <span class="keyword">int</span> bufferSize)</span> </span>&#123;</span><br><span class="line">	ObjectHelper.requireNonNull(mapper, <span class="string">"mapper is null"</span>);</span><br><span class="line">	ObjectHelper.verifyPositive(maxConcurrency, <span class="string">"maxConcurrency"</span>);</span><br><span class="line">	ObjectHelper.verifyPositive(bufferSize, <span class="string">"bufferSize"</span>);</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span> <span class="keyword">instanceof</span> ScalarCallable) &#123;</span><br><span class="line">		<span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">		T v = ((ScalarCallable&lt;T&gt;)<span class="keyword">this</span>).call(); ----&gt;<span class="keyword">this</span>可能会重写call函数（这不就是flatmap实际使用时重写的call函数吗....(lambda传入的那个函数）</span><br><span class="line">		<span class="keyword">if</span> (v == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> empty(); ---&gt; H</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> ObservableScalarXMap.scalarXMap(v,mapper); ---&gt; I</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> RxJavaPlugins.onAssembly(<span class="keyword">new</span> ObservableFlatMap&lt;T, R&gt;(<span class="keyword">this</span>, mapper, delayErrors, maxConcurrency, bufferSize));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>H.</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@param</span> &lt;T&gt; <span class="function">the type of the <span class="title">items</span> <span class="params">(ostensibly)</span> emitted by the ObservableSource</span></span><br><span class="line"><span class="function">@return an Observable that emits no items to the </span>&#123;\<span class="meta">@link</span> Observer&#125; but immediately invokes the &#123;<span class="meta">@link</span> Observer&#125;<span class="string">'s &#123;@link Observer#onComplete() onComplete&#125; method</span></span><br><span class="line"><span class="string">@see &lt;a href="http://reactivex.io/documentation/operators/empty-never-throw.html"&gt;ReactiveX operators documentation: Empty&lt;/a&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">@SchedulerSupport(SchedulerSupport.NONE)</span></span><br><span class="line"><span class="string">@SuppressWarnings("unchecked")</span></span><br><span class="line"><span class="string">public static &lt;T&gt; Observable&lt;T&gt; empty() &#123;</span></span><br><span class="line"><span class="string">	return RxJavaPlugins.onAssembly((Observable&lt;T&gt; ObservableEmpty.INSTANCE);</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure></p>
<p><strong>I.</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*Maps a scalar value into an Observable and emits its values.*/</span></span><br><span class="line"><span class="meta">@param</span> &lt;T&gt; the scalar value type</span><br><span class="line"><span class="meta">@param</span> &lt;U&gt; the output value type</span><br><span class="line"><span class="meta">@param</span> value the scalar value to map</span><br><span class="line"><span class="meta">@param</span> mapper the function that gets the scalar value and should <span class="keyword">return</span> an ObservableSource that gets streamed</span><br><span class="line"><span class="meta">@return</span> the <span class="keyword">new</span> Observable instance*/</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T, U&gt; <span class="function">Observable&lt;U&gt; <span class="title">scalarXMap</span><span class="params">(T value, Function&lt;? <span class="keyword">super</span> T, ? extends ObservableSource&lt;? extends U&gt;&gt;</span></span></span><br><span class="line"><span class="function"><span class="params">mapper)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> RxJavaPlugins.onAssembly(<span class="keyword">new</span> ScalarXMapObservable&lt;T,</span><br><span class="line">U&gt;(value, mapper));---&gt;J 同样的，<span class="keyword">new</span>一个observable</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>J.</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 把标准值T映射为observableSource，并且订阅他 Maps a scalar value to an ObservableSource and subscribes to it.*/</span></span><br><span class="line"><span class="meta">@param</span> &lt;T&gt; the scalar value type</span><br><span class="line"><span class="meta">@param</span> \&lt;R\&gt; the mapped ObservableSource<span class="string">'s element type.</span></span><br><span class="line"><span class="string">static final class ScalarXMapObservable &lt;T, R&gt; extends</span></span><br><span class="line"><span class="string">Observable&lt;R&gt; &#123;</span></span><br><span class="line"><span class="string">	final T value;</span></span><br><span class="line"><span class="string">	final Function&lt;? super T, ? extends ObservableSource&lt;? extends R&gt;&gt; mapper;</span></span><br><span class="line"><span class="string">	ScalarXMapObservable(T value, Function &lt;? super T, ? extends ObservableSource&lt;? extends R&gt;&gt; mapper) &#123;</span></span><br><span class="line"><span class="string">		this.value = value;</span></span><br><span class="line"><span class="string">		this.mapper = mapper;</span></span><br><span class="line"><span class="string">	&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>2A.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public final class ObservableCreate&lt;T&gt; extends Observable&lt;T&gt; &#123;&#125;</span><br><span class="line">@Override</span><br><span class="line">protected void subscribeActual(Observer&lt;? super T&gt; observer) &#123;</span><br><span class="line">	//创建发射器，这个observer是我们在应用层自己定义的observer（重写了onNext,onSuccess等函数)</span><br><span class="line">	CreateEmitter&lt;T&gt; parent = new CreateEmitter&lt;T&gt;(observer);</span><br><span class="line">	observer.onSubscribe(parent); // 每个observer都要重写的四个函数之一</span><br><span class="line">	try &#123;</span><br><span class="line">		source.subscribe(parent); // 这个source是每个onXXXX(new ObservableXXX(ffff))中new这个类时传入的参数（其实就是我们在应用层调用create（ffff）时的参数ffff,那么，每个类，比如create的参数类ObservableOnSubscribe&lt;T&gt;，都会重写属于自己的subscribe函数。这样就创建了一个emmiter</span><br><span class="line">	&#125; catch (Throwable ex) &#123;</span><br><span class="line">		Exceptions.throwIfFatal(ex);</span><br><span class="line">		parent.onError(ex);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>K.</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ScalarDisposable</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">AtomicInteger</span></span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">QueueDisposable</span> &lt;<span class="title">T</span>&gt;, <span class="title">Runnable</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ScalarDisposable</span><span class="params">(Observer &lt;? <span class="keyword">super</span> T&gt; observer, T</span></span></span><br><span class="line"><span class="function"><span class="params">value)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.observer = observer;</span><br><span class="line">	<span class="keyword">this</span>.value = value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>L.</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 继承了原子类，又用了CAS = =</span></span><br><span class="line">	<span class="keyword">if</span> (get() == START &amp;&amp; compareAndSet(START, ON_NEXT)) &#123;</span><br><span class="line">		observer.onNext(value);</span><br><span class="line">		<span class="keyword">if</span> (get() == ON_NEXT) &#123;</span><br><span class="line">			lazySet(ON_COMPLETE); </span><br><span class="line">			bserver.onComplete();</span><br><span class="line">		&#125;	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>复习一下原子类<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lazySet</span><span class="params">(<span class="keyword">int</span> newValue)</span> </span>&#123;</span><br><span class="line">	U.putOrderedInt(<span class="keyword">this</span>, VALUE, newValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>原子类设置值的时候像volatile一样，可以保证其他线程读取到最新的值，这个putOrderedInt其实是volatile的延迟版，也就是其他线程可能在值改变后仍然读到旧值。这有什么好处呢？性能：在多核处理器下，内存以及cpu缓存的读和写常常是顺序执行的，所以在多个cpu缓存之间同步一个内存值的代价是很昂贵的。</p>
<p><strong>2B.</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ScalarDisposable</span><span class="params">(Observer&lt;? <span class="keyword">super</span> T&gt; observer, T</span></span></span><br><span class="line"><span class="function"><span class="params">value)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.observer = observer;</span><br><span class="line">	<span class="keyword">this</span>.value = value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>static final class ScalarXMapObservable&lt;T, R&gt; extends<br>Observable<r> {}</r></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribeActual</span><span class="params">(Observer&lt;? <span class="keyword">super</span> R&gt; s)</span></span>&#123;</span><br><span class="line">ObservableSource&lt;? extends R&gt; other;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		other = ObjectHelper.requireNonNull(mapper.apply(value), <span class="string">"The mapper returned</span></span><br><span class="line"><span class="string">		a null ObservableSource"</span>); <span class="comment">//这个函数mapper就不再是源码自带的，而是我自己传的参数function</span></span><br><span class="line">	&#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">		EmptyDisposable.error(e, s);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (other <span class="keyword">instanceof</span> Callable) &#123;</span><br><span class="line">		R u;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			u = ((Callable&lt;R&gt;)other).call(); <span class="comment">//调用这个Function的call函数（我们重写的)</span></span><br><span class="line">		&#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">			Exceptions.throwIfFatal(ex);</span><br><span class="line">			EmptyDisposable.error(ex, s);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">		<span class="keyword">if</span> (u == <span class="keyword">null</span>) &#123;</span><br><span class="line">			EmptyDisposable.complete(s);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		ScalarDisposable&lt;R&gt; sd = <span class="keyword">new</span> ScalarDisposable&lt;R&gt;(s,u);---&gt;K</span><br><span class="line">		s.onSubscribe(sd); <span class="comment">//observer都会重写onSubscribe函数（好像也没有...迷）</span></span><br><span class="line">		sd.run(); -----&gt;L</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		other.subscribe(s);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>总结一下几个常用的操作符：</strong><br>总结几个点：</p>
<ul>
<li><p>操作符的参数，就是我们应用层使用时候传入的参数</p>
</li>
<li><p>这个参数，又会被传进各种ObservableXXX的类进行改造（new<br>….），这些类，通常都会进行source （以及value等的存储），这个source，就是<br>subscribeActual中最后 source.subscribe(parent);<br>时的source(parent就是我们subscribe时写的四个函数的包装）</p>
</li>
</ul>
<p><strong>1）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SchedulerSupport</span>(SchedulerSupport.NONE)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Observable&lt;T&gt; <span class="title">create</span><span class="params">(ObservableOnSubscribe&lt;T&gt;</span></span></span><br><span class="line"><span class="function"><span class="params">source)</span> </span>&#123;</span><br><span class="line">	ObjectHelper.requireNonNull(source, <span class="string">"source is null"</span>);</span><br><span class="line">		<span class="keyword">return</span> RxJavaPlugins.onAssembly(<span class="keyword">new</span> ObservableCreate&lt;T&gt;(source));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SchedulerSupport</span>(SchedulerSupport.NONE)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Observable&lt;T&gt; <span class="title">just</span><span class="params">(T item)</span> </span>&#123;</span><br><span class="line">	ObjectHelper.requireNonNull(item, <span class="string">"The item is null"</span>);</span><br><span class="line">		<span class="keyword">return</span> RxJavaPlugins.onAssembly(<span class="keyword">new</span> ObservableJust&lt;T&gt;(item));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>3）</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SchedulerSupport</span>(SchedulerSupport.CUSTOM)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Observable&lt;T&gt; <span class="title">subscribeOn</span><span class="params">(Scheduler scheduler)</span></span>&#123;</span><br><span class="line">	ObjectHelper.requireNonNull(scheduler, <span class="string">"scheduler is null"</span>);</span><br><span class="line">		<span class="keyword">return</span> RxJavaPlugins.onAssembly(<span class="keyword">new</span> ObservableSubscribeOn&lt;T&gt;(<span class="keyword">this</span>,scheduler));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>4）</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SchedulerSupport</span>(SchedulerSupport.CUSTOM)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Observable&lt;T&gt; <span class="title">observeOn</span><span class="params">(Scheduler scheduler, <span class="keyword">boolean</span></span></span></span><br><span class="line"><span class="function"><span class="params">delayError, <span class="keyword">int</span> bufferSize)</span> </span>&#123;</span><br><span class="line">	ObjectHelper.requireNonNull(scheduler, <span class="string">"scheduler is null"</span>);</span><br><span class="line">	ObjectHelper.verifyPositive(bufferSize, <span class="string">"bufferSize"</span>);</span><br><span class="line">	<span class="keyword">return</span> RxJavaPlugins.onAssembly(<span class="keyword">new</span> ObservableObserveOn&lt;T&gt;(<span class="keyword">this</span>,scheduler, delayError, bufferSize));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>思考一、为什么一定要调用subscribe？</strong></p>
<p><strong>看源码可以看出，</strong><br>observer = RxJavaPlugins.onSubscribe(this,observer);<br><strong>和</strong><br>subscribeActual(observer);<br><strong>这两句</strong></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/11/查找算法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ke Yu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coco">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/11/查找算法/" itemprop="url">常见查找算法总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-09-11T19:31:14+08:00">
                2017-09-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="一、静态查找"><a href="#一、静态查找" class="headerlink" title="一、静态查找"></a>一、静态查找</h3><h4 id="1）顺序查找：时间复杂度O（N）"><a href="#1）顺序查找：时间复杂度O（N）" class="headerlink" title="1）顺序查找：时间复杂度O（N）"></a>1）顺序查找：<strong>时间复杂度O（N）</strong></h4><p><strong>平均查找长度：(n+1）/2  </strong><br><strong>优点：对表的结构没有要求</strong></p>
<h4 id="2）二分查找：期望时间复杂度O（logN）这是一定的！"><a href="#2）二分查找：期望时间复杂度O（logN）这是一定的！" class="headerlink" title="2）二分查找：期望时间复杂度O（logN）这是一定的！"></a>2）二分查找：<strong>期望时间复杂度O（logN）这是一定的！</strong></h4><p><strong>平均查找长度：log(N+1)-1</strong><br><strong>成功查找为log(N）+1</strong><br><strong>不成功查找为log(N）+1</strong></p>
<p>如果需要添加或者删除一个数据，整个结构都要重建，代价太大。<br>优点：时间性能比顺序查找好，效率较高<br>缺点：只适用于顺序存储结构</p>
<p>扩展：</p>
<p><strong>插值查找</strong>， 不从1/2处断开，而是从1/3,1/4等等地方分开。<br>时间复杂度为O（log(logN))<br><strong>适合于关键字分布又均匀的表。</strong> 如果分布不均匀，那么不适合用插值查找。<br>mid=(low+high)/2, 即mid=low+1/2*(high-low);<br>通过类比，我们可以将查找的点改进为如下：<br>mid=low+<strong>(key-a[low])/(a[high]-a[low])</strong>*(high-low)，<br>斐波那契查找，按黄金比例进行分割。</p>
<h4 id="3）分块查找"><a href="#3）分块查找" class="headerlink" title="3）分块查找"></a>3）分块查找</h4><p>也称索引顺序查找。是1）和2）的改进。<br>把线性表分为若干块；块内无序；块间有序<br>建立一个索引表，存储<strong>每块内的最大值和这块的起始地址</strong>。</p>
<p><strong>时间复杂度为O（N）~ O（logN）</strong><br><strong>平均查找长度：(n/s+s)/2+1 ( s是每块的元素个数）</strong><br><strong>优点：顺序存储和链式存储都适用；查找效率高</strong><br><strong>缺点：需要将表分块排序，并且需要为索引表增加存储空间</strong></p>
<p><img src="http://ovwunej09.bkt.clouddn.com/search01.png" alt="conclusion"></p>
<h3 id="二、动态查找"><a href="#二、动态查找" class="headerlink" title="二、动态查找"></a>二、动态查找</h3><h4 id="3）二叉查找树：便于插入和删除，解决了2）的问题"><a href="#3）二叉查找树：便于插入和删除，解决了2）的问题" class="headerlink" title="3）二叉查找树：便于插入和删除，解决了2）的问题"></a>3）二叉查找树：便于插入和删除，解决了2）的问题</h4><p>树可能退化为线性结构，<strong>此时是最坏情况，O（N）</strong><br><strong>最好情况是O（logN）</strong></p>
<h4 id="4）平衡二叉树-AVL-其实是平衡二叉查找树）"><a href="#4）平衡二叉树-AVL-其实是平衡二叉查找树）" class="headerlink" title="4）平衡二叉树(AVL,其实是平衡二叉查找树）"></a>4）平衡二叉树(AVL,其实是平衡二叉查找树）</h4><p>不会出现3的最坏情况。<br><strong>时间复杂度是O（logN） </strong><br>插入、删除时需要做左旋和右旋等操作。</p>
<p>平衡二叉树又被称为AVL树（有别于AVL算法），且具有以下性质：<strong>它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。</strong></p>
<h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>(1) 查找代价：</p>
<p>AVL是严格平衡的BST（平衡因子不超过1）。那么查找过程与BST一样，只是AVL不会出现最差情况的BST(单支树)。因此<strong>查找效率最好，最坏情况都是O(logN)数量级的。</strong></p>
<p>(2) 插入代价：</p>
<p>AVL必须要保证严格平衡<strong>(|bf|\&lt;=1)</strong>，那么每一次插入数据使得AVL中某些结点的平衡因子超过1就必须进行旋转操作。事实上，AVL的每一次插入结点操作最多只需要旋转1次(单旋转或双旋转)。<strong>因此，总体上插入操作的代价仍然在O(logN)级别上</strong>(插入结点需要首先查找插入的位置)。</p>
<p>(3) 删除代价：</p>
<p>AVL删除结点的算法可以参见BST的删除结点，但是<strong>删除之后必须检查从删除结点开始到根结点路径上的所有结点的平衡因子。因此删除的代价稍微要大一些。每一次删除操作最多需要O(logN)次旋转。因此，删除操作的时间复杂度为O(logN)+O(logN)=O(2logN)</strong></p>
<p>缺点：</p>
<ul>
<li>为了保持平衡性，动态插入和删除的代价过高；</li>
<li>二叉查找树的查找代价都与树高有关，所以需要减小树高。</li>
</ul>
<h4 id="5）红黑树：并不完全平衡"><a href="#5）红黑树：并不完全平衡" class="headerlink" title="5）红黑树：并不完全平衡"></a>5）红黑树：并不完全平衡</h4><p>根节点为黑色；所有叶子节点是黑色；每个红色节点的两个子节点是黑色；<br><strong>时间复杂度：O（logN)进行搜索、插入、删除。</strong></p>
<h5 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h5><p><strong>(1) 查找代价：</strong></p>
<p><strong>由于红黑树的性质(最长路径长度不超过最短路径长度的2倍)，可以说明红黑树虽然不像AVL一样是严格平衡的，但平衡性能还是要比BST要好。其查找代价基本维持在O(logN)左右，但在最差情况下(最长路径是最短路径的2倍少1)，比AVL要略逊色一点。</strong></p>
<p><strong>(2) 插入代价：</strong></p>
<p><strong>RBT插入结点时，需要旋转操作和变色操作。但由于只需要保证RBT基本平衡就可以了。因此插入结点最多只需要2次旋转，这一点和AVL的插入操作一样。虽然变色操作需要O(logN)，但是变色操作十分简单，代价很小。</strong></p>
<p><strong>(3) 删除代价：</strong></p>
<p><strong>RBT的删除操作代价要比AVL要好的多，删除一个结点最多只需要3次旋转操作。</strong></p>
<h4 id="6）多路查找树（B-B"><a href="#6）多路查找树（B-B" class="headerlink" title="6）多路查找树（B~,B+)"></a>6）多路查找树（B~,B+)</h4><p>一个节点上拥有多于2个节点的二叉查找树。<br>B（B-）树：待插入结构图</p>
<h5 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h5><p>(1) 查找代价：</p>
<p>B-Tree作为一个平衡多路查找树(m-叉)。B树的查找分成两种：一种是从一个结点查找另一结点的地址的时候，需要定位磁盘地址(查找地址)，查找代价极高。另一种是将结点中的有序关键字序列放入内存，进行优化查找(可以用折半)，相比查找代价极低。而<strong>B树的高度很小，因此在这一背景下，B树比任何二叉结构查找树的效率都要高很多。而且B+树作为B树的变种，其查找效率更高。</strong></p>
<p>(2)插入代价：</p>
<p><strong>B-Tree的插入会发生结点的分裂操作。当插入操作引起了s个节点的分裂时，磁盘访问的次数为h(读取搜索路径上的节点)＋2s(回写两个分裂出的新节点)＋1（回写新的根节点或插入后没有导致分裂的节点）。因此，所需要的磁盘访问次数是h+2s+1，最多可达到3h+1。因此插入的代价是很大的。</strong></p>
<p>(3)删除代价：</p>
<p><strong>B-Tree的删除会发生结点合并操作。最坏情况下磁盘访问次数是3h＝（找到包含被删除元素需要h次读访问）+（获取第2至h层的最相邻兄弟需要h-1次读访问）+（在第3至h层的合并需要h-2次写访问）+（对修改过的根节点和第2层的两个节点进行3次写访问）。</strong></p>
<p>B+：待插入结构图</p>
<p>应用场景：<br>来自知乎<a href="https://www.zhihu.com/question/30527705/answer/52750388：" target="_blank" rel="noopener">https://www.zhihu.com/question/30527705/answer/52750388：</a><br>AVL是一种高度平衡的二叉树，所以通常的结果是，维护这种高度平衡所付出的代价比从中获得的效率收益还大，故而实际的应用不多，更多的地方是用追求局部而不是非常严格整体平衡的红黑树。当然，如果场景中对插入删除不频繁，只是对查找特别有要求，AVL还是优于红黑的。<br>红黑树的应用就很多了，除了上面同学提到的STL，还有</p>
<ul>
<li>著名的linux进程调度<a href="https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Completely_Fair_Scheduler" target="_blank" rel="noopener">Completely Fair<br>Scheduler</a>,用红黑树管理进程控制块</li>
<li>epoll在内核中的实现，用红黑树管理事件块</li>
<li>nginx中，用红黑树管理timer等</li>
<li>Java的TreeMap实现<br>B和B+主要用在文件系统以及数据库中做索引等，比如Mysql：<a href="https://link.zhihu.com/?target=https%3A//guptavikas.wordpress.com/2012/12/17/b-tree-index-in-mysql/" target="_blank" rel="noopener">B-Tree Index in<br>MySql</a></li>
</ul>
<p>trie树的一个典型应用是前缀匹配，比如下面这个很常见的场景，在我们输入时，搜索引擎会给予提示</p>
<h4 id="7）哈希"><a href="#7）哈希" class="headerlink" title="7）哈希"></a>7）哈希</h4><p>查找复杂度<strong>为O（1）</strong>，可以通过变换哈希函数在空间和时间上做出权衡。</p>
<p><img src="media/20d9923d23ee1ed7437cb641fa9dd379.png" alt="clipboard.png"></p>
<p>平均查找长度：<strong>等概率</strong>下一次查找<strong>所有元素</strong>的比较次数。<br>二分查找，查找成功的最大次数为：logN（取下限），logN（取下限）+1。</p>
<h4 id="相关题目（基础知识应用）"><a href="#相关题目（基础知识应用）" class="headerlink" title="相关题目（基础知识应用）"></a>相关题目（基础知识应用）</h4><p>1.长度为12的无重复有序表，查找成功的平均比较次数为：37/12<br>把1到12的查找次数都算出来相加除以12（这方法太傻<br>注意：查找1的次数为3,2的次数为2，所以二分法用的是法1， 不是法2<br>画二叉树来计算：</p>
<pre><code>      6

3             9
</code></pre><p>   2    5     7         11</p>
<p>1     4          8   10  12</p>
<p>1*1+2*2+4*3+5*4=37</p>
<p>2.但是找77 ，34,99 这三个数的时候又是用法二…</p>
<p>3.顺序查找都是将target与元素逐一比较，所以无论表是有序还是无序，查找长度都是n</p>
<p>4.设有关键字n=2\^h-1，<br>构成二叉排序树……，概率相等，查找成功的ASL最大是n：错。<br>注意读题！ASL是平均查找长度，最坏为线性查找（n+1)/2,<br>时间复杂度为O（n），注意n和O（n）是不同的！！</p>
<p>5.找82的那个数，比较4次，用的方法2…</p>
<p>6.从n个数中找最大的两个数理论上需要几次比较：<br>找最大的：n-1    找第二大的：logn-1<br>一共n+logn-2</p>
<p>7.顺序查找中，有序表和无序表的查找失败的平均查找长度不同：<br>对于有序表，如果找不到，可以直接退出<br>对于无序表，要全部遍历完才可以确定查找失败。</p>
<p>8.既希望较快的查找又便于<strong>线性表</strong>动态变化的查找方法是：<strong>索引顺序查找。</strong></p>
<p><strong>不是哈希！如果哈希的存储不是链式，一般情况随着关键字的增多，冲突频繁发生，查找性能会下降，并且利于动态变化。</strong></p>
<p>9.<strong>n个顶点的树一定有n-1条边</strong>，所以如果n个顶点m条边的全连通图需要去掉m-(n-1)条边</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/10/eventBus/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ke Yu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coco">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/10/eventBus/" itemprop="url">EventBus源码解析(1)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-09-10T20:19:30+08:00">
                2017-09-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>3.EventBus</strong></p>
<p>由于没有用过，所以先在这里理解一下几个重点名词：</p>
<p>event：我们想监听的事件，比如点击按钮，网页请求返回了响应</p>
<p>eventType：我们想监听的事件的类型</p>
<p>subscrible：订阅者，订阅事件的对象，当订阅者订阅的事件发生后，就会执行订阅者的响应函数，onEvent。</p>
<p><strong>使用第一步：在接收消息的activity中(onStart())</strong></p>
<p><strong>EventBus.getDefault().register(this); —>B</strong></p>
<p><strong>字母开头和1字母开头的，都是rigister的延伸。</strong></p>
<p><strong>使用第二步：在发送消息的activity中，</strong></p>
<p><strong>EventBus.getDefault().post(new Event(“Event btn clicked”)); ——>2A</strong></p>
<p><strong>2字母开头的，都是这个的延伸。</strong></p>
<p><strong>使用第三步：在接收消息的activity中（onStop())</strong></p>
<p><strong>EventBus.getDefault().unregister(this);——->3A</strong></p>
<p><strong>①EventBus.JAVA</strong></p>
<p><strong>A.</strong></p>
<p>单例模式，双重检查+volatile ，获取eventBus的实例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">volatile</span> EventBus defaultInstance;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> EventBus <span class="title">getDefault</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (defaultInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">synchronized</span> (EventBus.class) &#123;</span><br><span class="line">			<span class="keyword">if</span> (defaultInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">				defaultInstance = <span class="keyword">new</span> EventBus();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> defaultInstance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>3A.</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Unregisters the given subscriber from all event classes. 这是通过订阅者找出订阅类型来注销这个订阅者的所有订阅*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">unregister</span><span class="params">(Object subscriber)</span> </span>&#123;</span><br><span class="line"><span class="comment">//取出订阅者订阅的所有事件类型</span></span><br><span class="line">List&lt;Class&lt;?&gt;&gt; subscribedTypes = typesBySubscriber.get(subscriber);</span><br><span class="line">	<span class="keyword">if</span> (subscribedTypes != <span class="keyword">null</span>) &#123;</span><br><span class="line">	<span class="comment">//遍历所有事件类型，注销订阅</span></span><br><span class="line">	<span class="keyword">for</span> (Class&lt;?&gt; eventType : subscribedTypes) &#123;</span><br><span class="line">		unsubscribeByEventType(subscriber, eventType);----&gt;<span class="number">3</span>B</span><br><span class="line">	&#125;</span><br><span class="line">	typesBySubscriber.remove(subscriber);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123; <span class="comment">//这个订阅者没有订阅过任何事件。</span></span><br><span class="line">	但是，没有订阅过，有可能register啊...？？？？</span><br><span class="line">	Log.w(TAG, <span class="string">"Subscriber to unregister was not registered before: "</span> + subscriber.getClass());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>3B.</strong></p>
<p><strong>更新subscriptionsByEventType，而不是typesBySubscriber，typesBySubscriber在3A中（unregister)更新了</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Only updates subscriptionsByEventType, not typesBySubscriber! Caller must</span></span><br><span class="line"><span class="comment">update typesBySubscriber. 这是通过事件类型找出所有订阅者来取消订阅*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unsubscribeByEventType</span><span class="params">(Object subscriber, Class&lt;?&gt; eventType)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//通过事件类型取出订阅该类型的所有subscriptions，**注意，定义的时候，value是copyOnWriteList,这里就直接List了？？**</span></span><br><span class="line">List&lt;Subscription&gt; subscriptions =</span><br><span class="line">subscriptionsByEventType.get(eventType);</span><br><span class="line">	<span class="keyword">if</span> (subscriptions != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">int</span> size = subscriptions.size();</span><br><span class="line"><span class="comment">//遍历subscription,找到当前要注销的subcriber，更改active状态，并且从这个list中将它移出</span></span><br><span class="line"><span class="comment">// 这个find并且remove的过程- -真是清新自然，没有更简单的方法？？</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">			Subscription subscription = subscriptions.get(i);</span><br><span class="line">			<span class="keyword">if</span> (subscription.subscriber == subscriber) &#123;</span><br><span class="line">				subscription.active = <span class="keyword">false</span>;</span><br><span class="line">				subscriptions.remove(i);</span><br><span class="line">				i--;</span><br><span class="line">				size--;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2A.</strong></p>
<p><strong>从这里到2I，都是这个函数的延伸。</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">post</span><span class="params">(Object event)</span> </span>&#123;</span><br><span class="line">	PostingThreadState postingState =</span><br><span class="line">	currentPostingThreadState.get();---&gt;<span class="number">2</span>B</span><br><span class="line">	List&lt;Object&gt; eventQueue = postingState.eventQueue; <span class="comment">//postingThread的queue</span></span><br><span class="line">	eventQueue.add(event); <span class="comment">//向这个List添加事件</span></span><br><span class="line">	<span class="keyword">if</span> (!postingState.isPosting) &#123;</span><br><span class="line">		<span class="comment">//这个boolean值，都没有被赋值过...所以是取默认值？？boolean的默认值是false，所以就说得通了。</span></span><br><span class="line">		<span class="comment">//判断进行post的线程是否主线程</span></span><br><span class="line">		postingState.isMainThread = Looper.getMainLooper() == Looper.myLooper();</span><br><span class="line">		<span class="comment">//当前线程的isPosting为真</span></span><br><span class="line">		postingState.isPosting = <span class="keyword">true</span>;</span><br><span class="line">		<span class="comment">//如果取消了，抛出异常。</span></span><br><span class="line">		<span class="keyword">if</span> (postingState.canceled) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">"Internal error. Abort state was not reset"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">while</span> (!eventQueue.isEmpty()) &#123;</span><br><span class="line">				<span class="comment">//如果当前线程要post的事件队列不为空，取出队首，执行了postSingleEventForEventType，然后在里面又执行了postToSubscription，完成了post</span></span><br><span class="line">				postSingleEvent(eventQueue.remove(<span class="number">0</span>), postingState);---&gt;<span class="number">2</span>D</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			<span class="comment">//finally里面初始化成员变量</span></span><br><span class="line">			postingState.isPosting = <span class="keyword">false</span>;</span><br><span class="line">			postingState.isMainThread = <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>2D.</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postSingleEvent</span><span class="params">(Object event, PostingThreadState postingState)</span> <span class="keyword">throws</span> Error </span>&#123;</span><br><span class="line">	Class&lt;?&gt; eventClass = event.getClass();</span><br><span class="line">	<span class="keyword">boolean</span> subscriptionFound = <span class="keyword">false</span>;</span><br><span class="line">	<span class="keyword">if</span> (eventInheritance) &#123;</span><br><span class="line">	List&lt;Class&lt;?&gt;&gt; eventTypes = lookupAllEventTypes(eventClass);---&gt;<span class="number">2</span>E,得到这个eventClass的所有超类和父接口（也就是它可以对应的所有事件类型）</span><br><span class="line">	<span class="keyword">int</span> countTypes = eventTypes.size();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> h = <span class="number">0</span>; h &lt; countTypes; h++) &#123;</span><br><span class="line">			Class&lt;?&gt; clazz = eventTypes.get(h);</span><br><span class="line">			subscriptionFound |= postSingleEventForEventType(event, postingState, clazz);----&gt;<span class="number">2</span>G，在postSingleEventForEventType里面遍历所有监听了这个事件类型的subcription,通过postToSubscription去找线程调用订阅者的响应方法</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123; <span class="comment">//没有进入else，就直接调用postSingleEventForEventType	</span></span><br><span class="line">		subscriptionFound = postSingleEventForEventType(event, postingState, eventClass);----&gt;<span class="number">2</span>G</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!subscriptionFound) &#123;<span class="comment">//如果</span></span><br><span class="line">postSingleEventForEventType没执行成功，也就是这个事件没有订阅者订阅这类事件！！</span><br><span class="line">		<span class="keyword">if</span> (logNoSubscriberMessages) &#123;</span><br><span class="line">			Log.d(TAG, <span class="string">"No subscribers registered for event "</span> + eventClass);</span><br><span class="line">		&#125;</span><br><span class="line"><span class="comment">//这个判断有点奇怪。 eventClass 和 NoSubscriberEvent.class</span></span><br><span class="line">,怎么可能相等...不过看到post(<span class="keyword">new</span>...）就明白了，最开始的时候当然都是！=，不过重新<span class="keyword">new</span>了NoSubscriberEvent去post，当然可能==了。</span><br><span class="line">		<span class="keyword">if</span> (sendNoSubscriberEvent &amp;&amp; eventClass != NoSubscriberEvent.class &amp;&amp; eventClass != SubscriberExceptionEvent.class) &#123;----&gt;<span class="number">2</span>H，<span class="number">2</span>I</span><br><span class="line">			post(<span class="keyword">new</span> NoSubscriberEvent(<span class="keyword">this</span>,event));<span class="comment">//用当前类（调用post的类）和被post的event构造NoSubscriberEvent，所以有可能出现if中的第二种情况!!厉害了。但是第三种呢？？</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2H.</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 被post的事件没有订阅者订阅 哈哈哈哈哈 好惨</span></span><br><span class="line"><span class="comment"> This Event is posted by EventBus when no subscriber is found for a posted event.</span></span><br><span class="line"><span class="comment"> @author Markus</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NoSubscriberEvent</span> </span>&#123;</span><br><span class="line"><span class="comment">/* The &#123;\@link EventBus&#125; instance to with the original event was posted to.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">final</span> EventBus eventBus;</span><br><span class="line">	<span class="comment">/* The original event that could not be delivered to any subscriber. */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">final</span> Object originalEvent;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">NoSubscriberEvent</span><span class="params">(EventBus eventBus, Object originalEvent)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.eventBus = eventBus;</span><br><span class="line">		<span class="keyword">this</span>.originalEvent = originalEvent;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2I.</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 这个post的事件在订阅者响应函数中出现异常（需要理解下...</span></span><br><span class="line"><span class="comment"> This Event is posted by EventBus when an exception occurs inside a subscriber's event handling method.*</span></span><br><span class="line"><span class="comment"> @author Markus*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SubscriberExceptionEvent</span> </span>&#123;</span><br><span class="line"><span class="comment">/* The &#123;\@link EventBus&#125; instance to with the original event was posted to.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">final</span> EventBus eventBus;</span><br><span class="line">	<span class="comment">/* The Throwable thrown by a subscriber.*/</span></span><br><span class="line">	<span class="comment">//订阅者抛出的异常</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">final</span> Throwable throwable;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* The original event that could not be delivered to any subscriber. */</span></span><br><span class="line">	<span class="comment">//无法再被post给任何订阅者的event</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">final</span> Object causingEvent;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* The subscriber that threw the Throwable. */</span></span><br><span class="line">	<span class="comment">//抛出异常的订阅者</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">final</span> Object causingSubscriber;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">SubscriberExceptionEvent</span><span class="params">(EventBus eventBus, Throwable throwable,Object causingEvent,Object causingSubscriber)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.eventBus = eventBus;</span><br><span class="line">		<span class="keyword">this</span>.throwable = throwable;</span><br><span class="line">		<span class="keyword">this</span>.causingEvent = causingEvent;</span><br><span class="line">		<span class="keyword">this</span>.causingSubscriber = causingSubscriber;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2G.</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">postSingleEventForEventType</span><span class="params">(Object event, PostingThreadState postingState, Class&lt;?&gt; eventClass)</span> </span>&#123;</span><br><span class="line">	CopyOnWriteArrayList&lt;Subscription&gt; subscriptions;</span><br><span class="line">	<span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">	<span class="comment">//取出这个事件class所涉及的所有subscription(里面存储了订阅者和处理这个事件的方法）</span></span><br><span class="line">		subscriptions = subscriptionsByEventType.get(eventClass);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 这个if里面，不是一个意思？？？</span></span><br><span class="line">	<span class="comment">// 存在订阅这种事件类型的订阅者</span></span><br><span class="line">	<span class="keyword">if</span> (subscriptions != <span class="keyword">null</span> &amp;&amp; !subscriptions.isEmpty()) &#123;</span><br><span class="line">		<span class="keyword">for</span> (Subscription subscription : subscriptions) &#123;</span><br><span class="line">			<span class="comment">//遍历所有的subscription,设置postingState的参数</span></span><br><span class="line">			postingState.event = event;</span><br><span class="line">			postingState.subscription = subscription;</span><br><span class="line">			<span class="keyword">boolean</span> aborted = <span class="keyword">false</span>;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				postToSubscription(subscription, event,postingState.isMainThread);----&gt;<span class="number">1</span>D,在subscribe(..）粘性事件那里分析过了，所以那里的疑惑就解决了....那里的post是由于“粘性”立即post最近的event给订阅者，这里的postToSubscription是发送信息的一方直接调用post导致的</span><br><span class="line">				aborted = postingState.canceled; <span class="comment">//判断是否abort</span></span><br><span class="line">			&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">				<span class="comment">//当前状态的变量置为null，由于if可能结束循环，所以在finally中置空，避免内存泄漏。个人觉得...为什么不直接for循环外面置空，一定要置空了再赋值？？</span></span><br><span class="line">				postingState.event = <span class="keyword">null</span>;</span><br><span class="line">				postingState.subscription = <span class="keyword">null</span>;</span><br><span class="line">				postingState.canceled = <span class="keyword">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (aborted) &#123;</span><br><span class="line">				<span class="keyword">break</span>;<span class="comment">//如果abort了，那么这个事件的post就结束了</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//for循环结束，返回true</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//没进入if，返回false</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>2E.</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Looks up all Class objects including super classes and interfaces. Should also work for interfaces. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;Class&lt;?&gt;&gt; lookupAllEventTypes(Class&lt;?&gt; eventClass)&#123;</span><br><span class="line">	<span class="keyword">synchronized</span> (eventTypesCache) &#123;</span><br><span class="line">		<span class="comment">//从事件类的缓存中，根据事件class取出队列</span></span><br><span class="line">		List&lt;Class&lt;?&gt;&gt; eventTypes = eventTypesCache.get(eventClass);</span><br><span class="line">		<span class="keyword">if</span> (eventTypes == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="comment">//如果没有该类型的event，新建List</span></span><br><span class="line">			eventTypes = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">			Class&lt;?&gt; clazz = eventClass;</span><br><span class="line">			<span class="keyword">while</span> (clazz != <span class="keyword">null</span>) &#123;</span><br><span class="line">				eventTypes.add(clazz); <span class="comment">// 把当前事件类加到这个list中</span></span><br><span class="line">				<span class="comment">//clazz.getInterfaces(),又是反射机制，可以获得这个class实现自哪些接口。</span></span><br><span class="line">				addInterfaces(eventTypes,clazz.getInterfaces());---&gt;<span class="number">2F</span>，递归获得事件类的所有父接口，加到eventTypes这个list中</span><br><span class="line">				clazz = clazz.getSuperclass();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//然后把这个eventClass以及它可以对应的所有事件类型（List集合保存)加入cache</span></span><br><span class="line">			eventTypesCache.put(eventClass, eventTypes);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> eventTypes;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>2F.</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Recurses through super interfaces. */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addInterfaces</span><span class="params">(List&lt;Class&lt;?&gt;&gt; eventTypes, Class&lt;?&gt;[]</span></span></span><br><span class="line"><span class="function"><span class="params">interfaces)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (Class&lt;?&gt; interfaceClass : interfaces) &#123;</span><br><span class="line">	<span class="comment">//遍历事件类实现的接口，如果这个事件类型的List中不包含有这个接口</span></span><br><span class="line">		<span class="keyword">if</span> (!eventTypes.contains(interfaceClass)) &#123;</span><br><span class="line">			eventTypes.add(interfaceClass);<span class="comment">// 把这个接口添加进list</span></span><br><span class="line">		<span class="comment">// 继续用interfaceClass.getInterfaces()得到interfaceClass实现的接口</span></span><br><span class="line">		<span class="comment">//迭代这个方法</span></span><br><span class="line">			addInterfaces(eventTypes, interfaceClass.getInterfaces());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>2B</strong>.一个成员变量，<strong>PostingThreadState类型—&gt;2C</strong>的ThreadLocal<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ThreadLocal&lt;PostingThreadState&gt;</span><br><span class="line">currentPostingThreadState = <span class="keyword">new</span> ThreadLocal&lt;PostingThreadState&gt;() &#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> PostingThreadState <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//这个ThreadLocal的初始化就是new一个新的PostingThreadState();</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> PostingThreadState();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><strong>2C.一个静态常量内部类</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* For ThreadLocal, much faster to set (and get multiple values). */</span></span><br><span class="line"><span class="comment">//为了ThreadLocal可以更快的set和get？这里就是之前看threadLocal时提到的，postingThreadState用到了threadLocal</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PostingThreadState</span> </span>&#123;</span><br><span class="line">	<span class="keyword">final</span> List&lt;Object&gt; eventQueue = <span class="keyword">new</span> ArrayList&lt;Object&gt;();</span><br><span class="line">	<span class="keyword">boolean</span> isPosting;</span><br><span class="line">	<span class="keyword">boolean</span> isMainThread;</span><br><span class="line">	Subscription subscription;</span><br><span class="line">	Object event;</span><br><span class="line">	<span class="keyword">boolean</span> canceled;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>B</strong>.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(Object subscriber)</span> </span>&#123;</span><br><span class="line"><span class="comment">//首先通过反射，获取订阅者的类</span></span><br><span class="line">Class&lt;?&gt; subscriberClass = subscriber.getClass();</span><br><span class="line"><span class="comment">// 然后通过类，找类的方法，不是简单的用getMethod()</span></span><br><span class="line">List\&lt;SubscriberMethod\&gt; subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriberClass);---&gt;C，C~S都是这个函数的延伸，主要是两种方法来查找订阅者的方法</span><br><span class="line">	<span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">		<span class="keyword">for</span> (SubscriberMethod subscriberMethod : subscriberMethods) &#123;</span><br><span class="line">			<span class="comment">// 遍历订阅者的方法，然后执行subscribe---&gt;1A，重点就是处理subscriberMethod，其实不知道放进去在哪一步被执行...</span></span><br><span class="line">			subscribe(subscriber, subscriberMethod);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>1A.</strong><br><strong>1开头的，都是这个函数延伸出去的调用。</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 涉及到数据结构：private final Map&lt;Class&lt;?&gt;, CopyOnWriteArrayList&lt;Subscription&gt;&gt; subscriptionsByEventType;</span></span><br><span class="line"><span class="comment">/* Must be called in synchronized block*</span></span><br><span class="line"><span class="comment">*订阅者subscriber*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(Object subscriber, SubscriberMethod subscriberMethod)</span></span>&#123;</span><br><span class="line">	<span class="comment">//订阅者的方法要订阅的事件类</span></span><br><span class="line">	Class&lt;?&gt; eventType = subscriberMethod.eventType;</span><br><span class="line">	Subscription newSubscription = <span class="keyword">new</span> Subscription(subscriber,</span><br><span class="line">	subscriberMethod);---&gt;<span class="number">1</span>B,封装了这个订阅者和订阅者的响应函数以及是否订阅这三个信息</span><br><span class="line">	CopyOnWriteArrayList&lt;Subscription&gt; subscriptions =</span><br><span class="line">	subscriptionsByEventType.get(eventType); </span><br><span class="line">	<span class="comment">//根据eventType取出订阅这个情况的所有订阅情况</span></span><br><span class="line">	<span class="keyword">if</span> (subscriptions == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="comment">//如果这个event还从未被订阅，自然新建一个它所对应的subscription</span></span><br><span class="line">		subscriptions = <span class="keyword">new</span> CopyOnWriteArrayList&lt;&gt;();	</span><br><span class="line">		subscriptionsByEventType.put(eventType, subscriptions);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">//如果这个订阅关系已经存在， 抛出异常。Subscriber..already registered to event，和自己理解的一样~~~~ 开心</span></span><br><span class="line">		<span class="keyword">if</span> (subscriptions.contains(newSubscription)) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">"Subscriber "</span> + subscriber.getClass() +<span class="string">"already registered to event "</span>+ eventType);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 这个事件有多少个订阅方法（\@subscribe的方法或者onEvent..)</span></span><br><span class="line">	<span class="keyword">int</span> size = subscriptions.size();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= size; i++) &#123;</span><br><span class="line">		<span class="comment">// 如果当前这个订阅方法的优先级比当前这个订阅方法的优先级高，就把它加入到第i位（也就是倒数第二位），然后break。</span></span><br><span class="line">		<span class="comment">// 如果直接到了size，说明当前方法优先级最低，直接插入尾部。</span></span><br><span class="line">		<span class="keyword">if</span> (i == size || subscriberMethod.priority &gt; subscriptions.get(i).subscriberMethod.priority) &#123;</span><br><span class="line">			subscriptions.add(i, newSubscription);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//涉及到private final Map&lt;Object, List&lt;Class&lt;?&gt;&gt;&gt; typesBySubscriber;</span></span><br><span class="line">	<span class="comment">//查看这个订阅者要订阅的事件类型</span></span><br><span class="line">	List&lt;Class&lt;?&gt;&gt; subscribedEvents = typesBySubscriber.get(subscriber);</span><br><span class="line">	<span class="keyword">if</span> (subscribedEvents == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="comment">//原来这个subscriber没有订阅过事件，那么现在增加订阅者的 subscribedEvents(是一个list）</span></span><br><span class="line">		subscribedEvents = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		typesBySubscriber.put(subscriber, subscribedEvents);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//不管subscriber是否订阅过事件,都把这个事件类型加入到这个subscriber的订阅事件列表中</span></span><br><span class="line">	subscribedEvents.add(eventType);</span><br><span class="line">	<span class="comment">//如果这个响应函数是粘性的。 如果不是粘性的？？哪里涉及到线程去执行？</span></span><br><span class="line">	<span class="comment">//个人理解：</span></span><br><span class="line">	这是<span class="number">3.0</span>增加的新特性：从代码可以看出stickyEvents的entry，其实是一个map，map的key是事件类型（<span class="class"><span class="keyword">class</span>\&lt;?\&gt;），<span class="title">value</span>是事件实例(<span class="title">Object</span>),由于是粘性事件，那么，当这个<span class="title">subscriberMethod</span>订阅这个事件类型，就把最近的事件类型的事件（<span class="title">Object</span>)</span></span><br><span class="line"><span class="class">通过<span class="title">checkPostStickyEventToSubscription</span>立刻将这个事件找到对应的处理线程，进行排队（有可能排）后，由对应的<span class="title">subcriberMethod</span>进行处理。</span></span><br><span class="line"><span class="class">	<span class="title">if</span> (<span class="title">subscriberMethod</span>.<span class="title">sticky</span>) </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (eventInheritance) &#123;</span><br><span class="line">		<span class="comment">/* Existing sticky events of all subclasses of eventType have to be</span></span><br><span class="line"><span class="comment">		considered.这个事件类型的所有子类的粘性事件都要考虑</span></span><br><span class="line"><span class="comment">		Note: Iterating over all events may be inefficient with lots of sticky events, 如果粘性事件比较多，遍历所有的事件可能不够高效</span></span><br><span class="line"><span class="comment">		thus data structure should be changed to allow a more efficient lookup*应该更改数据结构，进行更高效的遍历  (e.g. an additional map storing sub classes of super classes: Class -&gt; List&lt;Class&gt;).*/</span></span><br><span class="line">			Set&lt;Map.Entry&lt;Class&lt;?&gt;, Object&gt;&gt; entries = stickyEvents.entrySet();</span><br><span class="line">		    <span class="comment">//取出保存粘性事件的set</span></span><br><span class="line">			<span class="keyword">for</span> (Map.Entry&lt;Class&lt;?&gt;, Object&gt; entry : entries) &#123;</span><br><span class="line">			<span class="comment">//遍历set中每个元素，取出每个元素的key，也就是事件类型class&lt;?&gt;</span></span><br><span class="line">				Class&lt;?&gt; candidateEventType = entry.getKey();</span><br><span class="line">				<span class="comment">//如果当前订阅方法监听的事件类型，是之前存在的事件的 父类</span></span><br><span class="line">				<span class="keyword">if</span> (eventType.isAssignableFrom(candidateEventType)) &#123;</span><br><span class="line">					<span class="comment">// 取出value,也就是这个事件类型的实例</span></span><br><span class="line">					Object stickyEvent = entry.getValue();</span><br><span class="line">					checkPostStickyEventToSubscription(newSubscription, stickyEvent);----&gt;<span class="number">1</span>C</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			Object stickyEvent = stickyEvents.get(eventType);</span><br><span class="line">			checkPostStickyEventToSubscription(newSubscription, stickyEvent);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>1C. 主要是调用了postToSubscription，选择了合适的线程，执行了post</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkPostStickyEventToSubscription</span><span class="params">(Subscription</span></span></span><br><span class="line"><span class="function"><span class="params">newSubscription, Object stickyEvent)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (stickyEvent != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="comment">/*If the subscriber is trying to abort the event, it will fail (event is not tracked in posting state) 如果订阅者想阻止这个事件，将会失败--&gt; Strange corner case, which we don't take care of here.奇怪的case，我们不用在意？？？ 这注释有点迷...*/</span></span><br><span class="line">		postToSubscription(newSubscription, stickyEvent, Looper.getMainLooper() == Looper.myLooper());---&gt;<span class="number">1</span>D,真正处理event的函数（终于涉及了线程），赞！</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>1D.根据订阅者方法的threadMode，决定这个方法由哪个线程执行。</strong></p>
<p><strong>由各个poster去处理pengdingPost，可能由handler执行，也可能是线程池去执行runnable</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postToSubscription</span><span class="params">(Subscription subscription, Object event,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">boolean</span> isMainThread)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">switch</span> (subscription.subscriberMethod.threadMode) &#123;</span><br><span class="line">		<span class="keyword">case</span> POSTING:</span><br><span class="line">			invokeSubscriber(subscription,event);---&gt;<span class="number">1</span>E，通过java反射机制，使用method.invoke()调用了subscirber对象中的参数为event订阅方法</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> MAIN:</span><br><span class="line">			<span class="keyword">if</span> (isMainThread) &#123;</span><br><span class="line">				<span class="comment">//如果当前就是主线程，那么就当前线程执行subscription.subscriberMethod</span></span><br><span class="line">				invokeSubscriber(subscription, event);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">//mainThreadPoster = new HandlerPoster(this, Looper.getMainLooper(), 10);有主线程的looper</span></span><br><span class="line">				mainThreadPoster.enqueue(subscription, event);----&gt;<span class="number">1F</span>，插入给主线程的handler，会将这个事件和方法放入queue，等待主线程执行，如果主线程的queue之前为空，那么就直接sendMsg。</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> BACKGROUND:</span><br><span class="line">			<span class="keyword">if</span> (isMainThread) &#123;</span><br><span class="line">				<span class="comment">//backgroundPoster = new BackgroundPoster(this);同理，这是后台线程的handler</span></span><br><span class="line">				backgroundPoster.enqueue(subscription, event);---&gt;<span class="number">1</span>I</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">//如果当前线程不是主线程，就直接用当前线程执行，invokeSubscriber是当前的eventBus中的函数</span></span><br><span class="line">				invokeSubscriber(subscription, event);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> ASYNC:</span><br><span class="line">			asyncPoster.enqueue(subscription, event);---&gt;<span class="number">1</span>J</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Unknown thread mode: "</span> + subscription.subscriberMethod.threadMode);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>1E.</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">invokeSubscriber</span><span class="params">(Subscription subscription, Object event)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">//method.invoke(Object obj, Object... args) 是反射机制的一个函数</span></span><br><span class="line">		<span class="comment">//对这个指定的对象obj，调用方法method，args是这个方法需要的参数数组。</span></span><br><span class="line">		<span class="comment">//也就是，调用subscriber这个对象的subscription.subscriberMethod.method方法，其中event是这个方法的参数...JAVA反射好厉害-</span></span><br><span class="line">		subscription.subscriberMethod.method.invoke(subscription.subscriber, event);</span><br><span class="line">	&#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">		handleSubscriberException(subscription, event, e.getCause());</span><br><span class="line">	&#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Unexpected exception"</span>, e);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>1K. 差点以为是1E…</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">invokeSubscriber</span><span class="params">(PendingPost pendingPost)</span> </span>&#123;</span><br><span class="line">	Object event = pendingPost.event; <span class="comment">//取出这个post对应的event obj</span></span><br><span class="line">	<span class="comment">//再取出对应的订阅信息</span></span><br><span class="line">	Subscription subscription = pendingPost.subscription;</span><br><span class="line">	PendingPost.releasePendingPost(pendingPost);----&gt;<span class="number">1L</span></span><br><span class="line">	<span class="keyword">if</span> (subscription.active) &#123;</span><br><span class="line">	<span class="comment">//这个变量注释就说是这里会用到，为了避免race conditions（资源竞争）</span></span><br><span class="line">		invokeSubscriber(subscription, event);---&gt;<span class="number">1</span>E</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>SubscriberMethodFinder.JAVA</strong></p>
<p><strong>C.</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">List&lt;SubscriberMethod&gt; <span class="title">findSubscriberMethods</span><span class="params">(Class&lt;?&gt; subscriberClass)</span></span>&#123;</span><br><span class="line">	<span class="comment">//先直接从缓存中取</span></span><br><span class="line">	List&lt;SubscriberMethod&gt; subscriberMethods = METHOD_CACHE.get(subscriberClass);</span><br><span class="line">	<span class="keyword">if</span> (subscriberMethods != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> subscriberMethods;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//如果没有的话，判断是否要忽略注解器：</span></span><br><span class="line">	<span class="keyword">if</span> (ignoreGeneratedIndex) &#123;</span><br><span class="line">		<span class="comment">//忽略的话，用反射来获取类的方法信息</span></span><br><span class="line">		subscriberMethods = findUsingReflection(subscriberClass);---&gt;D</span><br><span class="line">		<span class="comment">/*D~N，都是利用反射找方法的过程，主要是通过findState，把subscriberClass放进去，找到对应方法，再找它的父类，依次向上。总体来说findUsingReflection就是一个while循环遍历所有相关类，根据类找方法时需要用到反射和注解...*/</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		subscriberMethods = findUsingInfo(subscriberClass); ---&gt;O</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (subscriberMethods.isEmpty()) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">"Subscriber "</span> + subscriberClass + <span class="string">" and its super classes have no public methods with the \@Subscribe annotation"</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		METHOD_CACHE.put(subscriberClass, subscriberMethods);</span><br><span class="line">		<span class="keyword">return</span> subscriberMethods;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>P.</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> SubscriberInfo <span class="title">getSubscriberInfo</span><span class="params">(FindState findState)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 看描述subscriberInfo本来就一直为null啊... 是一个接口的变量</span></span><br><span class="line">	<span class="comment">// getSuperSubscriberInfo()是接口的一个函数，AbstractSubscriberInfo是接口实现</span></span><br><span class="line">	<span class="keyword">if</span> (findState.subscriberInfo != <span class="keyword">null</span> &amp;&amp; findState.subscriberInfo.getSuperSubscriberInfo() != <span class="keyword">null</span>) &#123; ----&gt;Q</span><br><span class="line">		<span class="comment">//如果订阅者信息不为空且订阅者信息子类不为空</span></span><br><span class="line">		SubscriberInfo superclassInfo = findState.subscriberInfo.getSuperSubscriberInfo();</span><br><span class="line">		<span class="comment">//如果findstate当前的clazz和订阅者子类一样，返回这个子类信息。</span></span><br><span class="line">		<span class="keyword">if</span> (findState.clazz == superclassInfo.getSubscriberClass()) &#123;</span><br><span class="line">			<span class="keyword">return</span> superclassInfo;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//如果订阅者信息下标不为空（是一个List),那么遍历List，通过index取出clazz的信息，并返回。</span></span><br><span class="line">	<span class="keyword">if</span> (subscriberInfoIndexes != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">for</span> (SubscriberInfoIndex index : subscriberInfoIndexes) &#123;</span><br><span class="line">			SubscriberInfo info = index.getSubscriberInfo(findState.clazz);</span><br><span class="line">			<span class="keyword">if</span> (info != <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">return</span> info;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>O.看看和DList<subscribermethod> findUsingReflection(Class&lt;?&gt;<br>subscriberClass)有什么不同</subscribermethod></strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> List&lt;SubscriberMethod&gt; <span class="title">findUsingInfo</span><span class="params">(Class&lt;?&gt; subscriberClass)</span> </span>&#123;</span><br><span class="line">	FindState findState = prepareFindState(); <span class="comment">// same</span></span><br><span class="line">	findState.initForSubscriber(subscriberClass); <span class="comment">// same</span></span><br><span class="line">	<span class="keyword">while</span> (findState.clazz != <span class="keyword">null</span>) &#123; <span class="comment">// same</span></span><br><span class="line">		findState.subscriberInfo =</span><br><span class="line">getSubscriberInfo(findState);---&gt;P,经过PQ，取到订阅者的信息</span><br><span class="line">		<span class="keyword">if</span> (findState.subscriberInfo != <span class="keyword">null</span>) &#123; <span class="comment">//订阅者信息不为空</span></span><br><span class="line">			SubscriberMethod[] array = findState.subscriberInfo.getSubscriberMethods();---&gt;R<span class="comment">//调用接口函数，根据方法信息构建方法，并返回</span></span><br><span class="line">		<span class="keyword">for</span> (SubscriberMethod subscriberMethod : array) &#123;</span><br><span class="line">		<span class="comment">// 遍历方法，但是否能将订阅者方法和要监听的事件类型添加到findState中</span></span><br><span class="line">			<span class="keyword">if</span> (findState.checkAdd(subscriberMethod.method, subscriberMethod.eventType)) &#123;</span><br><span class="line">			<span class="comment">// 将这个方法加入到findState的list中去</span></span><br><span class="line">				findState.subscriberMethods.add(subscriberMethod);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="comment">//订阅者信息为空，那就通过这个方法，用反射得到findState.clazz的相关信息，并构造订阅方法（new SubscriberMethod（....)），add进findState中</span></span><br><span class="line">		findUsingReflectionInSingleClass(findState);</span><br><span class="line">	&#125;</span><br><span class="line">	findState.moveToSuperclass(); <span class="comment">//继续往上找</span></span><br><span class="line">&#125;</span><br><span class="line">	<span class="keyword">return</span> getMethodsAndRelease(findState); <span class="comment">//释放这个findState</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">D.</span><br><span class="line"><span class="function"><span class="keyword">private</span> List&lt;SubscriberMethod&gt; <span class="title">findUsingReflection</span><span class="params">(Class&lt;?&gt;</span></span></span><br><span class="line"><span class="function"><span class="params">subscriberClass)</span> </span>&#123;</span><br><span class="line">	FindState findState = prepareFindState();----&gt;E,得到一个FindState</span><br><span class="line">	findState.initForSubscriber(subscriberClass);---&gt;F,为这个findstate赋值它记在的订阅类，也就是subscriberClass，这是起点，此时findState中的clazz就是它</span><br><span class="line">	<span class="keyword">while</span> (findState.clazz != <span class="keyword">null</span>) &#123;</span><br><span class="line">		findUsingReflectionInSingleClass(findState);----&gt;G</span><br><span class="line">	<span class="comment">/*G到K，终于把subscriberClass里面的订阅方法加入到相应的findState了</span></span><br><span class="line"><span class="comment">	findState.moveToSuperclass();---&gt;L,把findState的clazz换成clazz的父类（超类不能为系统类）</span></span><br><span class="line"><span class="comment">	注意这是一个while循环，所以是从子类开始一直向上，把相应clazz的方法加入到findState*/</span></span><br><span class="line">&#125;</span><br><span class="line">	<span class="keyword">return</span> getMethodsAndRelease(findState);-----&gt;M，释放findstate,<span class="keyword">while</span>循环结束它就功成身退了，把它还给statePool</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>E.从findStatePool中取出第一个不为空的state，取出后把池中这个位置的state置为空。<br>有可能池为空，那么直接new一个FindState();</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> FindState <span class="title">prepareFindState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">synchronized</span> (FIND_STATE_POOL) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; POOL_SIZE; i++) &#123;	</span><br><span class="line">			FindState state = FIND_STATE_POOL[i];</span><br><span class="line">			<span class="keyword">if</span> (state != <span class="keyword">null</span>) &#123;</span><br><span class="line">				FIND_STATE_POOL[i] = <span class="keyword">null</span>;</span><br><span class="line">				<span class="keyword">return</span> state;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> FindState();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>G.利用反射原理取出当前findState中的订阅类的方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">findUsingReflectionInSingleClass</span><span class="params">(FindState findState)</span> </span>&#123;</span><br><span class="line">	Method[] methods;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">	<span class="comment">// This is faster than getMethods, especially when subscribers are fat classes</span></span><br><span class="line">	like Activities</span><br><span class="line">	<span class="comment">/*getMethods()返回某个类的所有公用（public）方法包括其继承类的公用方法，当然也包括它所实现接口的方法。getDeclaredMethods()对象表示的类或接口声明的所有方法，包括公共、保护、默认（包）访问和私有方法，但不包括继承的方法。当然也包括它所实现接口的方法。*/</span></span><br><span class="line">	methods = findState.clazz.getDeclaredMethods();</span><br><span class="line">	&#125; <span class="keyword">catch</span> (Throwable th) &#123;</span><br><span class="line">	<span class="comment">/* Workaround for java.lang.NoClassDefFoundError, see</span></span><br><span class="line"><span class="comment">	https://github.com/greenrobot/EventBus/issues/149*</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">		methods = findState.clazz.getMethods();</span><br><span class="line">		findState.skipSuperClasses = <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">	<span class="comment">//返回类或接口的以整数编码的JAVA语言修饰符，比如得到整数i=1，那么Modefier.toString(i)可以得到String的public</span></span><br><span class="line">	<span class="keyword">int</span> modifiers = method.getModifiers();</span><br><span class="line">	<span class="comment">//如果是public，不是abstract,不是static，不是BRIDGE,不是SYNTHETIC？</span></span><br><span class="line">	<span class="keyword">if</span> ((modifiers &amp; Modifier.PUBLIC) != <span class="number">0</span> &amp;&amp; (modifiers &amp; MODIFIERS_IGNORE)</span><br><span class="line">== <span class="number">0</span>)&#123;</span><br><span class="line">	<span class="comment">//获得方法的各参数的类型数组，不管类型是否一样，都算1，比如 int string</span></span><br><span class="line">	<span class="keyword">int</span>，那么共<span class="number">3</span>个</span><br><span class="line">	Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();</span><br><span class="line">	<span class="comment">// 3.0开始，不是onEvent..开头的方法，也可以作为响应函数了</span></span><br><span class="line">	<span class="comment">// 但是必须只有一个参数（也就是监听的事件event这个参数</span></span><br><span class="line">	<span class="keyword">if</span> (parameterTypes.length == <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="comment">//获得Subscribe.class的注解，这个注解标签（定义的名称）是Subscribe。</span></span><br><span class="line">		<span class="comment">// 有@Subscribe 注解的，都是响应函数，也就是不仅能用onEvent..这四个函数了</span></span><br><span class="line">		Subscribe subscribeAnnotation = method.getAnnotation(Subscribe.class);</span><br><span class="line">		<span class="keyword">if</span> (subscribeAnnotation != <span class="keyword">null</span>) &#123; <span class="comment">// 如果\@Subscribe不为空</span></span><br><span class="line">			Class&lt;?&gt; eventType = parameterTypes[<span class="number">0</span>]; <span class="comment">//取出参数对应的类</span></span><br><span class="line">			<span class="keyword">if</span> (findState.checkAdd(method, eventType)) &#123;-----&gt;H，一系列检查看是否能为这个事件类型添加对应的方法</span><br><span class="line">				ThreadMode threadMode = subscribeAnnotation.threadMode();---&gt;</span><br><span class="line">			findState.subscriberMethods.add(<span class="keyword">new</span> SubscriberMethod(method, eventType,</span><br><span class="line">threadMode,subscribeAnnotation.priority(), subscribeAnnotation.sticky()));</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="comment">//把这个订阅方法以及相关的事件类型、响应模式等封装后，加入到findState保存的订阅者方法的list中去，这是newSubscriberMethod的起点，顺便去看看这个类</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (strictMethodVerification &amp;&amp; method.isAnnotationPresent(Subscribe.class)) &#123;</span><br><span class="line">			<span class="comment">// 如果不止一个参数类型并且.....</span></span><br><span class="line">			<span class="comment">// 获取这个方法的所在的类名，以及方法名</span></span><br><span class="line">			String methodName = method.getDeclaringClass().getName() + <span class="string">"."</span> +</span><br><span class="line">		method.getName();</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">"\@Subscribe method "</span> + methodName +</span><br><span class="line">			<span class="string">"must have exactly 1 parameter but has "</span> + parameterTypes.length);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (strictMethodVerification &amp;&amp;</span><br><span class="line">		method.isAnnotationPresent(Subscribe.class)) &#123; </span><br><span class="line">			<span class="comment">//这个elseif对应的是最外层那个public &amp;&amp; 非abstract ....</span></span><br><span class="line">			String methodName = method.getDeclaringClass().getName() + <span class="string">"."</span> + method.getName();</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(methodName + <span class="string">" is a illegal \@Subscribe method: must be public, non-static, and non-abstract"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>M.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> List&lt;SubscriberMethod&gt; <span class="title">getMethodsAndRelease</span><span class="params">(FindState findState)</span></span>&#123;</span><br><span class="line">	<span class="comment">//把findState里面的subscriberMethods列表复制过来</span></span><br><span class="line">	List&lt;SubscriberMethod&gt; subscriberMethods = <span class="keyword">new</span></span><br><span class="line">	ArrayList&lt;&gt;(findState.subscriberMethods);</span><br><span class="line">	findState.recycle(); ---&gt;N ,就是把findState的各个成员变量清空。</span><br><span class="line">	<span class="keyword">synchronized</span> (FIND_STATE_POOL) &#123;</span><br><span class="line">		<span class="comment">// 从前开始遍历，把这个findstate还给这个pool</span></span><br><span class="line">		<span class="comment">// 之前取的时候，把[i]位置置为了null，所以这里还回去时候找值为null的=</span></span><br><span class="line">		<span class="comment">// 这思路真是简单易懂- -</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; POOL_SIZE; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (FIND_STATE_POOL[i] == <span class="keyword">null</span>) &#123;</span><br><span class="line">				FIND_STATE_POOL[i] = findState;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> subscriberMethods;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>SubscriberMethodFinder.java中的一个静态内部类：<br>static class FindState {}<br>成员变量：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//subscriber的订阅方法</span></span><br><span class="line"><span class="keyword">final</span> List&lt;SubscriberMethod&gt; subscriberMethods = <span class="keyword">new</span></span><br><span class="line">ArrayList&lt;&gt;();</span><br><span class="line"><span class="comment">//订阅方法的事件类型</span></span><br><span class="line"><span class="keyword">final</span> Map&lt;Class, Object&gt; anyMethodByEventType = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="keyword">final</span> Map&lt;String, Class&gt; subscriberClassByMethodKey = <span class="keyword">new</span></span><br><span class="line">HashMap&lt;&gt;();</span><br><span class="line"><span class="keyword">final</span> StringBuilder methodKeyBuilder = <span class="keyword">new</span> StringBuilder(<span class="number">128</span>);</span><br><span class="line">Class&lt;?&gt; subscriberClass;</span><br><span class="line">Class&lt;?&gt; clazz;</span><br><span class="line"><span class="keyword">boolean</span> skipSuperClasses;</span><br><span class="line">SubscriberInfo subscriberInfo;</span><br><span class="line"><span class="comment">//主要保存了订阅类的所有订阅方法信息.</span></span><br></pre></td></tr></table></figure></p>
<p><strong>N.</strong><br><strong><em>集合类用clear()，builder用setLength(0),对象实例用null。</em></strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">recycle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	subscriberMethods.clear();</span><br><span class="line">	anyMethodByEventType.clear();</span><br><span class="line">	subscriberClassByMethodKey.clear();</span><br><span class="line">	methodKeyBuilder.setLength(<span class="number">0</span>);</span><br><span class="line">	subscriberClass = <span class="keyword">null</span>;</span><br><span class="line">	clazz = <span class="keyword">null</span>;</span><br><span class="line">	skipSuperClasses = <span class="keyword">false</span>;</span><br><span class="line">	subscriberInfo = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>F</strong>.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initForSubscriber</span><span class="params">(Class&lt;?&gt; subscriberClass)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.subscriberClass = clazz = subscriberClass;</span><br><span class="line">	skipSuperClasses = <span class="keyword">false</span>;</span><br><span class="line">	subscriberInfo = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>H</strong>.<br><strong>检查是否添加这个方法，</strong>checkAddWithMethodSignature这个方法有点迷惑…记得回来看</p>
<p>两层检查，第一层检查事件类型，第二层检查签名（方法名称+参数类型）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">checkAdd</span><span class="params">(Method method, Class&lt;?&gt; eventType)</span> </span>&#123;</span><br><span class="line">	<span class="comment">/* 2 level check: 1st level with event type only (fast), 2nd level with</span></span><br><span class="line"><span class="comment">	complete signature when required.</span></span><br><span class="line"><span class="comment">	Usually a subscriber doesn't have methods listening to the same event type.*/</span></span><br><span class="line">	<span class="comment">// map的put方法，如果之前Key没有对应的value，那么返回null，否则返回之前对应的值</span></span><br><span class="line">	Object existing = anyMethodByEventType.put(eventType, method);</span><br><span class="line">	<span class="keyword">if</span> (existing == <span class="keyword">null</span>) &#123;</span><br><span class="line">	<span class="comment">//说明之前这个key没有对应值，那么这个类型可以对应这个方法</span></span><br><span class="line">	<span class="comment">//也就是这个事件只有当前这种方法订阅了</span></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="comment">// 如果之前订阅这个事件A的method和当前想订阅事件A的method类型一样</span></span><br><span class="line">		<span class="keyword">if</span> (existing <span class="keyword">instanceof</span> Method) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!checkAddWithMethodSignature((Method) existing, eventType))-----&gt;I&#123; <span class="comment">// 如果之前的classOld是现在methodClass的子类，那么抛出异常</span></span><br><span class="line">				<span class="comment">// Paranoia check</span></span><br><span class="line">				<span class="comment">// 也就是之前存在的classOld是当前方法的子类时，不用重新订阅，需要遵循子类覆写。</span></span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// Put any non-Method object to "consume" the existing Method</span></span><br><span class="line">			<span class="comment">//没有出现父类想和子类抢同一个事件的异常，那么这个事件类型的订阅者就是this</span></span><br><span class="line">			anyMethodByEventType.put(eventType, <span class="keyword">this</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> checkAddWithMethodSignature(method, eventType);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>I.方法签名的检查</strong></p>
<p>这是一个优化，如果现在保存的是旧的子类，那么保存新的，返回true<br>否则没必要保存，直接保存旧的那个父类就行了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">checkAddWithMethodSignature</span><span class="params">(Method method, Class&lt;?&gt; eventType)</span> </span>&#123;</span><br><span class="line">	methodKeyBuilder.setLength(<span class="number">0</span>);</span><br><span class="line">	methodKeyBuilder.append(method.getName()); <span class="comment">//方法名</span></span><br><span class="line">	methodKeyBuilder.append(<span class="string">'&gt;'</span>).append(eventType.getName());</span><br><span class="line">	<span class="comment">// 类名即事件类型名称</span></span><br><span class="line">	<span class="comment">// 用这两个值当做key</span></span><br><span class="line">	String methodKey = methodKeyBuilder.toString();</span><br><span class="line">	<span class="comment">// 得到这个方法所对应的类对象</span></span><br><span class="line">	Class&lt;?&gt; methodClass = method.getDeclaringClass();</span><br><span class="line">	Class&lt;?&gt; methodClassOld = subscriberClassByMethodKey.put(methodKey, methodClass);</span><br><span class="line">	<span class="comment">//methodClassOld为空，或者是父类</span></span><br><span class="line">	<span class="comment">//methodClassOld为空时：说明这个方法签名（methodKey=方法名+事件类型)之前没有彼此对应。那么允许为这个方法添加订阅事件，返回true</span></span><br><span class="line">	<span class="keyword">if</span> (methodClassOld == <span class="keyword">null</span> ||</span><br><span class="line">	methodClassOld.isAssignableFrom(methodClass)) &#123;</span><br><span class="line">		<span class="comment">//这个函数，Class.isAssignableFrom()是用来判断一个类Class1是否Class2的superClass或者superInterface，或者是相同类或者接口。</span></span><br><span class="line">		格式为： Class1.isAssignableFrom(Class2)</span><br><span class="line">		这是判断类之间的关系，<span class="keyword">instanceof</span>是判断实例之间的关系</span><br><span class="line">		<span class="comment">// Only add if not already found in a sub class</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// Revert the put, old class is further down the class hierarchy</span></span><br><span class="line">		<span class="comment">/*methodClassOld不为空，并且它是新的methodClass的子类，把methodClassOld放回去并且返回false，**代表子类classOld覆写了父类的订阅方法，让子类method的订阅方法订阅这个事件而不是父类。*/</span></span><br><span class="line">		subscriberClassByMethodKey.put(methodKey,methodClassOld);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>L.</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">moveToSuperclass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (skipSuperClasses) &#123;</span><br><span class="line">		clazz = <span class="keyword">null</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		clazz = clazz.getSuperclass();</span><br><span class="line">		String clazzName = clazz.getName();</span><br><span class="line">		<span class="comment">/* Skip system classes, this just degrades performance. */</span></span><br><span class="line">		<span class="comment">//跳过系统类，也就是以java, javax,android开头的类</span></span><br><span class="line">		<span class="keyword">if</span> (clazzName.startsWith(<span class="string">"java."</span>) ||clazzName.startsWith(<span class="string">"javax."</span>) || clazzName.startsWith(<span class="string">"android."</span>)) &#123;</span><br><span class="line">			clazz = <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>③注解类\@Subscribe</strong></p>
<p><strong>J.</strong></p>
<p>终于遇到注解了！！看别人的分析，注解中应该还有<br>String[] actions() default {};  </p>
<p>这个版本好像没有了！！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.*RUNTIME*)</span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.*METHOD*&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Subscribe &#123;</span><br><span class="line">	<span class="function">ThreadMode <span class="title">threadMode</span><span class="params">()</span> <span class="keyword">default</span></span></span><br><span class="line"><span class="function">	ThreadMode.POSTING</span>;---&gt;K</span><br><span class="line">	<span class="comment">/*如果是真，如果有订阅者在这个sticky事件发布后才订阅这个事件，那么依然会把最近的这个事件类型的sticky事件发送给这个subscriber*/</span></span><br><span class="line">	<span class="comment">/* If true, delivers the most recent sticky event (posted with &#123;\@link EventBus #postSticky(Object)&#125;) to this subscriber (if event available).*/</span></span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">sticky</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line">	<span class="comment">/* 对于同一个传送线程，优先级高的订阅者更快地接收到事件</span></span><br><span class="line"><span class="comment">	Subscriber priority to influence the order of event delivery.*/</span></span><br><span class="line">	<span class="comment">/* Within the same delivery thread (&#123;\@link ThreadMode&#125;), higher priority subscribers will receive events before*/</span> others with a lower priority. The <span class="keyword">default</span> priority is <span class="number">0</span>. Note: the priority</span><br><span class="line">	does \*NOT\* affect the order of delivery among subscribers with different &#123;\<span class="meta">@link</span> ThreadMode&#125;s! */</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">priority</span><span class="params">()</span> <span class="keyword">default</span> 0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>K.</strong><br>public enum ThreadMode{}<br>枚举类型，共四种：<br><em>POSTING</em>：订阅者的响应函数直接由发起post事件的线程执行，如果发起post的是主线程，那么响应函数不应该是耗时操作。如果要执行的task耗时很短，建议使用这种模式。<br><em>MAIN</em>: 订阅者的响应函数由主线程执行。如果posting<br>thread是主线程，事件响应函数将会直接被这个线程call。<br><em>BACKGROUND</em>：订阅者的响应函数由后台线程执行，如果posting<br>thread不是主线程，事件响应函数将会直接被这个线程call。如果posting<br>thread是主线程，那么eventBus将会使用一个单独的single后台线程，这个线程会按序执行这些响应函数。但还是不建议有很耗时的操作，以避免阻塞这个后台线程。<br><em>ASYNC：</em><br>订阅者的响应函数由一个独立的线程去执行，这个线程不是主线程，也不是posting<br>thread。如果有比较耗时的操作，建议用这种模式，比如网络访问。EventBus使用了线程池来重用线程进行异步操作。</p>
<p><strong>SubscriberMethod.JAVA</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubscriberMethod</span> </span>&#123;</span><br><span class="line">	<span class="keyword">final</span> Method method;</span><br><span class="line">	<span class="keyword">final</span> ThreadMode threadMode;</span><br><span class="line">	<span class="keyword">final</span> Class&lt;?&gt; eventType;</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">int</span> priority;</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">boolean</span> sticky;</span><br><span class="line">	<span class="comment">/* Used for efficient comparison */</span></span><br><span class="line">	String methodString;</span><br><span class="line">....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>构造函数就是对前五个变量进行赋值，很好理解。</p>
<p><strong>AbstractSubscriberInfo.JAVA，实现SubscriberInfo接口</strong><br>public abstract class AbstractSubscriberInfo implements SubscriberInfo<br>{}<br>private final Class subscriberClass;<br>private final Class&lt;? extends SubscriberInfo&gt;<br>superSubscriberInfoClass;<br>private final boolean shouldCheckSuperclass;<br>主要是三个成员变量：<br>订阅者对应的类；订阅者信息的子类（这是什么鬼…); 检查超类的布尔变量</p>
<p><strong>P.</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SubscriberInfo <span class="title">getSuperSubscriberInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 如果没有信息子类，直接返回Null</span></span><br><span class="line">	<span class="keyword">if</span>(superSubscriberInfoClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> superSubscriberInfoClass.newInstance();</span><br><span class="line">	&#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">	&#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>S.</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">simpleSubscriberInfo中的getSubscriberMethods()会调用该函数：</span><br><span class="line"><span class="function"><span class="keyword">protected</span> SubscriberMethod <span class="title">createSubscriberMethod</span><span class="params">(String methodName, Class&lt;?&gt; eventType, ThreadMode threadMode,<span class="keyword">int</span> priority, <span class="keyword">boolean</span> sticky)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		Method method = subscriberClass.getDeclaredMethod(methodName, eventType);</span><br><span class="line">		<span class="comment">//通过方法名称，和方法参数列表（其实就是方法签名）从class中找到类</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> SubscriberMethod(method, eventType, threadMode, priority, sticky); <span class="comment">//然后构造subscriber方法，似乎比第一种通过反射的方式简单</span></span><br><span class="line">	&#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(**<span class="string">"Could not find subscriber method in "</span> + subscriberClass + <span class="string">". Maybe a missing ProGuard rule?"</span>, e);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>**⑥SimpleSubscriberInfo.JAVA<br>又继承了AbstractSubscriberInfo（就不能一次写完吗…)<br>一个成员变量：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> SubscriberMethodInfo[] methodInfos;</span><br><span class="line"><span class="comment">// 存储了订阅者所有的方法信息，用数组保存。</span></span><br></pre></td></tr></table></figure></p>
<p><strong>R.</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> SubscriberMethod[] getSubscriberMethods() &#123;</span><br><span class="line">	<span class="keyword">int</span> length = methodInfos.length;</span><br><span class="line">	<span class="comment">//建立一个方法数组（不是方法信息）</span></span><br><span class="line">	SubscriberMethod[] methods = <span class="keyword">new</span> SubscriberMethod[length];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">		<span class="comment">//取出方法信息	</span></span><br><span class="line">		SubscriberMethodInfo info = methodInfos[i];</span><br><span class="line">		<span class="comment">//根据信息建立方法（调用父类的createSubscriberMethod）</span></span><br><span class="line">		methods[i] = createSubscriberMethod(info.methodName, info.eventType, info.threadMode, info.priority, info.sticky);----&gt;S</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> methods; <span class="comment">//根据信息构造了方法数组，返回去。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>⑦Subscription.JAVA</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Subscription</span> </span>&#123;&#125;</span><br><span class="line"><span class="comment">//三个成员变量：</span></span><br><span class="line"><span class="keyword">final</span> Object subscriber; <span class="comment">//注册的订阅者</span></span><br><span class="line"><span class="keyword">final</span> SubscriberMethod subscriberMethod; <span class="comment">//订阅者响应事件的函数</span></span><br><span class="line"><span class="comment">/*Becomes false as soon as &#123;@link EventBus#unregister(Object)&#125; is called, which is checked by queued event delivery &#123;@link EventBus#invokeSubscriber(PendingPost)&#125; to prevent race conditions.*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">boolean</span> active; <span class="comment">// unrigester之后为false</span></span><br></pre></td></tr></table></figure></p>
<p><strong>1B.</strong></p>
<p>构造函数就是为这三个变量赋值：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Subscription(Object subscriber, SubscriberMethod subscriberMethod)&#123;</span><br><span class="line">	<span class="keyword">this</span>.subscriber = subscriber;</span><br><span class="line">	<span class="keyword">this</span>.subscriberMethod = subscriberMethod;</span><br><span class="line">	active = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>⑧HandlerPoster.JAVA</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HandlerPoster</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;&#125;</span><br><span class="line">	<span class="comment">//四个成员变量：</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> PendingPostQueue queue;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> maxMillisInsideHandleMessage;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> EventBus eventBus;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">boolean</span> handlerActive;</span><br></pre></td></tr></table></figure>
<p><strong>1F.</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Subscription subscription, Object event)</span> </span>&#123;</span><br><span class="line">	PendingPost pendingPost = PendingPost.obtainPendingPost(subscription, event);---&gt; <span class="number">1</span>G,根据订阅信息和event取出pendingPost，</span><br><span class="line">		<span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">			queue.enqueue(pendingPost); <span class="comment">//插入等待队列</span></span><br><span class="line">			<span class="keyword">if</span> (!handlerActive) &#123;</span><br><span class="line">			<span class="comment">//如果handler不活跃，就打开它（可能之前没有msg给handler处理）直接发送消息进行处理</span></span><br><span class="line">				handlerActive = <span class="keyword">true</span>;</span><br><span class="line">			<span class="keyword">if</span> (!sendMessage(obtainMessage())) &#123; </span><br><span class="line">			<span class="comment">//handler发送msg出去----&gt;1H</span></span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(**<span class="string">"Could not send handler message"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>1H.消息处理函数</strong>，但是handleMessage有三个级别,handler的是最不优先的- -</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">boolean</span> rescheduled = <span class="keyword">false</span>;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="keyword">long</span> started = SystemClock.uptimeMillis();</span><br><span class="line">		<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">			PendingPost pendingPost = queue.poll();</span><br><span class="line">			<span class="comment">//移出并返回队头，如果queue是空的，就返回null，不会抛异常</span></span><br><span class="line">			<span class="keyword">if</span> (pendingPost == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="comment">//如果队列为空</span></span><br><span class="line">				<span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123; <span class="comment">//锁住当前handler</span></span><br><span class="line">				<span class="comment">// Check again, this time in synchronized*</span></span><br><span class="line">					pendingPost = queue.poll(); <span class="comment">//再取？</span></span><br><span class="line">					<span class="keyword">if</span> (pendingPost == <span class="keyword">null</span>) &#123;</span><br><span class="line">					<span class="comment">//还是空，那么这个handler没事干了</span></span><br><span class="line">						handlerActive = <span class="keyword">false</span>;</span><br><span class="line">						<span class="keyword">return</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="comment">//又调用eventBus的invokeSubscriber函数，1E已经分析了。利用反射调用订阅方法。</span></span><br><span class="line">		eventBus.invokeSubscriber(pendingPost);----&gt;不是<span class="number">1</span>E！参数不同！<span class="number">1</span>K,不过最终还是可能调用<span class="number">1</span>E</span><br><span class="line">		<span class="keyword">long</span> timeInMethod = SystemClock.uptimeMillis() - started;</span><br><span class="line">		<span class="comment">//如果执行method的时间大于了handleMsg规定的时间</span></span><br><span class="line">		<span class="keyword">if</span> (timeInMethod &gt;= maxMillisInsideHandleMessage) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!sendMessage(obtainMessage())) &#123; <span class="comment">//又发送出去执行？？</span></span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">"Could not send handler message"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			rescheduled = <span class="keyword">true</span>;<span class="comment">// 重新调度了</span></span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">	handlerActive = rescheduled; <span class="comment">//如果发生了重新调度，handlerActive为真</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>⑨PendingPost.JAVA</strong></p>
<p>四个成员变量：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> List&lt;PendingPost&gt; pendingPostPool = <span class="keyword">new</span></span><br><span class="line">ArrayList&lt;PendingPost&gt;();</span><br><span class="line">Object event;</span><br><span class="line">Subscription subscription;</span><br><span class="line">PendingPost next;</span><br></pre></td></tr></table></figure></p>
<p>一个构造函数：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">PendingPost</span><span class="params">(Object event, Subscription subscription)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.event = event;</span><br><span class="line">	<span class="keyword">this</span>.subscription = subscription;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>1G.</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> PendingPost <span class="title">obtainPendingPost</span><span class="params">(Subscription subscription, Object event)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">synchronized</span> (pendingPostPool) &#123;</span><br><span class="line">		<span class="keyword">int</span> size = pendingPostPool.size();</span><br><span class="line">		<span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="comment">//取出postPool中最后一个pendingPost</span></span><br><span class="line">			PendingPost pendingPost = pendingPostPool.remove(size - <span class="number">1</span>);</span><br><span class="line">			pendingPost.event = event;</span><br><span class="line">			pendingPost.subscription = subscription;</span><br><span class="line">			pendingPost.next = <span class="keyword">null</span>;</span><br><span class="line">			<span class="keyword">return</span> pendingPost;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//如果pengdingPostPool为空，直接用事件和订阅信息new一个新的pendingPost</span></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> PendingPost(event, subscription);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>1L.</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">releasePendingPost</span><span class="params">(PendingPost pendingPost)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//将pendingPost的各变量置为null</span></span><br><span class="line">	pendingPost.event = <span class="keyword">null</span>;</span><br><span class="line">	pendingPost.subscription = <span class="keyword">null</span>;</span><br><span class="line">	pendingPost.next = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">synchronized</span> (pendingPostPool) &#123;</span><br><span class="line">		<span class="comment">/*锁住postPool，把这个pendingPost放进去= =话说，为什么不直接pendingPost=null...恩，如果里面的这三个变量不为null，那么应该无法回收，但是也可以先把变量置为null,再把pendingPost=null</span></span><br><span class="line"><span class="comment">		但是这里直接把变量置为null然后重用？ 所以这是传说中的对象池...恩</span></span><br><span class="line"><span class="comment">		// Don't let the pool grow indefinitely</span></span><br><span class="line"><span class="comment">		if (pendingPostPool.size() &lt; 10000) &#123;</span></span><br><span class="line"><span class="comment">			pendingPostPool.add(pendingPost);</span></span><br><span class="line"><span class="comment">		&#125;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br></pre></td></tr></table></figure>
<p><strong>⑩BackgroundPoster.java</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">BackgroundPoster</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;&#125;</span><br><span class="line"><span class="comment">//是一个线程,三个成员变量：</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> PendingPostQueue queue; <span class="comment">//等到这个线程处理的事件队列</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> EventBus eventBus;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> executorRunning;</span><br></pre></td></tr></table></figure>
<p>构造函数：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BackgroundPoster(EventBus eventBus) &#123;</span><br><span class="line">	<span class="keyword">this</span>.eventBus = eventBus;</span><br><span class="line">	queue = <span class="keyword">new</span> PendingPostQueue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>持有了eventBus的引用，也许有内存泄漏？</p>
<p><strong>1I.</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Subscription subscription, Object event)</span> </span>&#123;</span><br><span class="line">PendingPost pendingPost = PendingPost.obtainPendingPost(subscription, event);</span><br><span class="line"><span class="comment">//根据subscription和要发布的事件构造pendingPost</span></span><br><span class="line">	<span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">		queue.enqueue(pendingPost); <span class="comment">//入队</span></span><br><span class="line">		<span class="keyword">if</span> (!executorRunning) &#123; <span class="comment">//这个runnable此时没有在执行</span></span><br><span class="line">			executorRunning = <span class="keyword">true</span>;<span class="comment">//那么可以利用起来了</span></span><br><span class="line">			<span class="comment">//eventBus的线程池执行当前runnable</span></span><br><span class="line">			eventBus.getExecutorService().execute(**<span class="keyword">this</span>**);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>⑪AsyncPoster.JAVA</strong></p>
<p>三个成员变量：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> PendingPostQueue queue;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> EventBus eventBus;</span><br></pre></td></tr></table></figure></p>
<p>构造函数：持有了eventBus的引用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">AsyncPoster(EventBus eventBus) &#123;</span><br><span class="line">	<span class="keyword">this</span>.eventBus = eventBus;</span><br><span class="line">	queue = <span class="keyword">new</span> PendingPostQueue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>1J.</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造了pendingPost后直接进入队列，执行让eventBus的线程池执行它= =</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Subscription subscription, Object event)</span> </span>&#123;</span><br><span class="line">	PendingPost pendingPost = PendingPost.obtainPendingPost(subscription, event);</span><br><span class="line">	queue.enqueue(pendingPost);</span><br><span class="line">	eventBus.getExecutorService().execute(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//从队列里面取出pendingPost</span></span><br><span class="line">	PendingPost pendingPost = queue.poll();</span><br><span class="line">	<span class="keyword">if</span>(pendingPost == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"No pending post available"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*1E分析过，反射机制执行subscription里面的method（打脸，这不是1E</span></span><br><span class="line"><span class="comment">	eventBus.invokeSubscriber(pendingPost);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.jpg"
                alt="Ke Yu" />
            
              <p class="site-author-name" itemprop="name">Ke Yu</p>
              <p class="site-description motion-element" itemprop="description">Keep moving. Don't settle.</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">37</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">7</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">51</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Ke Yu</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
