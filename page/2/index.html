<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="en">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="Keep moving.Don&apos;t settle.">
<meta property="og:type" content="website">
<meta property="og:title" content="Coco">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="Coco">
<meta property="og:description" content="Keep moving.Don&apos;t settle.">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Coco">
<meta name="twitter:description" content="Keep moving.Don&apos;t settle.">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/2/"/>





  <title>Coco</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Coco</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Hello world</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/24/车辆检测9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ke Yu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coco">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/24/车辆检测9/" itemprop="url">车辆检测论文（7）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-10-24T15:23:54+08:00">
                2017-10-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/图像/" itemprop="url" rel="index">
                    <span itemprop="name">图像</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Efficient L-Shape Fitting for Vehicle Detection Using Laser Scanners BY Xiao Zhang, Wenda Xu, Chiyu Dong and John M. Dolan<br>2017</p>
<h4 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h4><p>自动驾驶中，周围汽车的检测是一项重要的任务，最近引起了广泛的关注。当使用雷达扫描器时，L-Shape装置是基于模型的车辆检测和追踪的关键步骤，需要彻底的调查和综合的研究。在本篇论文中，我们将L-shape装置公式化为一个最优问题，寻找这个最优解的方法被提出。我们的方法不依赖于雷达扫描序列信息，并且支持多雷达扫描器的便捷数据融合。这非常的高效，并且几乎不涉及通信参数。同时此方法非常的灵活，可以适用于多种多样的条件不同的装置。使用产品分数的雷达扫描器的路上实验显示了这个方法的有效性和鲁棒性。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/24/车辆检测6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ke Yu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coco">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/24/车辆检测6/" itemprop="url">车辆检测论文（6）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-10-24T14:33:23+08:00">
                2017-10-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/图像/" itemprop="url" rel="index">
                    <span itemprop="name">图像</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Automated Vehicle Detection Using Optical Fiber<br>Communication<br>BY Samarth Gupta ， Professor Vikas Upadhyaya<br>Electronics and Communication Department NIIT University<br>Neemrana, India</p>
<h4 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h4><p>汽车自动探测是很有挑战性的领域，由于复杂的交通情况，交通监控系统检测更复杂更有挑战性。在本次研究中，我们探索到光纤技术可以用于负荷传感器来测量车辆以普通速度前进时的种类。用于传感器的光纤的光学特性在一个纤维弯曲实验中第一次获得并且与在示波器中检测到的各种各样的传播特性比如振幅、相移等相关联。实验在使用光纤来用来做负荷传感器的情况下进行。实验结果也体现了当传统传感器不能捕捉精确的的数据时使用光纤纤维网络来传递数据的好处。于是我们试图找到使用车辆的重量进行车辆检测并且克服在军事战争中用来检测车辆传感器的错误的可能性。</p>
<h4 id="文章结构"><a href="#文章结构" class="headerlink" title="文章结构"></a>文章结构</h4><ul>
<li>一 介绍</li>
<li>二 系统需要和工作</li>
<li>三 结果和结论</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/24/Android源码设计模式解析与实战----状态模式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ke Yu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coco">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/24/Android源码设计模式解析与实战----状态模式/" itemprop="url">常见查找算法总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-10-24T13:21:34+08:00">
                2017-10-24
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><pre><code>多个对象都可以处理同一个请求，但具体由哪个对象处理则在运行时动态处理。
</code></pre><h3 id="Android源码解析"><a href="#Android源码解析" class="headerlink" title="Android源码解析"></a>Android源码解析</h3><pre><code>常说的View的分发机制，就是使用了责任链模式。一层一层的往下找处理事件的目标，当onTouchEvent返回false的时候，就代表这个view不是目标，不处理这个事件。
</code></pre><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><pre><code>通过有序的BroadcastReceiver可以实现全局责任链模式。因为有序广播可以决定消息是否继续传下去。
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/11/RxJava/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ke Yu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coco">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/11/RxJava/" itemprop="url">RxJAVA初步理解(1)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-09-11T23:29:17+08:00">
                2017-09-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>RxJAVA</strong></p>
<p>① subscribe函数：</p>
<p>调用了observable.onSubscribe.call(subscriber)<br>observable:最后一个变换后的observable<br>onSubscribe创建最后一个observable时传入的参数<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SchedulerSupport</span>(SchedulerSupport.NONE)</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(Observer&lt;? <span class="keyword">super</span> T&gt; observer)</span> </span>&#123;</span><br><span class="line">	ObjectHelper.requireNonNull(observer, <span class="string">"observer is null"</span>);</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">	<span class="comment">// onXXXX相关的，和刚才的onAssembly是一个套路，同样的使用了Hook</span></span><br><span class="line">		observer = RxJavaPlugins.onSubscribe(<span class="keyword">this</span>, observer);</span><br><span class="line">		ObjectHelper.requireNonNull(observer, <span class="string">"Plugin returned null Observer"</span>);</span><br><span class="line">		<span class="comment">//开始订阅，这个subscribeActual函数，作为onAssembly()的参数时的类，都有重写，</span></span><br><span class="line">		subscribeActual(observer);-----&gt; <span class="number">2</span>A</span><br><span class="line">	&#125; <span class="keyword">catch</span> (NullPointerException e) &#123; <span class="comment">// NOPMD</span></span><br><span class="line">		<span class="keyword">throw</span> e;</span><br><span class="line">	&#125; <span class="keyword">catch</span> (Throwable e) &#123;Exceptions.throwIfFatal(e);</span><br><span class="line">		<span class="comment">// can't call onError because no way to know if a Disposable has been set or not can't call onSubscribe because the call might have set a Subscription</span></span><br><span class="line">		already RxJavaPlugins.onError(e);</span><br><span class="line">		NullPointerException npe = <span class="keyword">new</span> NullPointerException(<span class="string">"Actually not, but can't throw other exceptions due to RS"</span>);</span><br><span class="line">			npe.initCause(e);</span><br><span class="line">			<span class="keyword">throw</span> npe;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>②create函数<br>onJust：<br>A.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SchedulerSupport</span>(SchedulerSupport.NONE)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Observable&lt;T&gt; <span class="title">just</span><span class="params">(T item)</span> </span>&#123;</span><br><span class="line">	ObjectHelper.requireNonNull(item, <span class="string">"The item is null"</span>);</span><br><span class="line">	<span class="keyword">return</span> RxJavaPlugins.onAssembly(<span class="keyword">new</span> ObservableJust&lt;T&gt;(item));----&gt;B</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>B.</strong><br>所有onXXXX的函数，都是hook function.<br>onAssembly这个函数：把传进来的各种new<br>ObservableXXX<t>转换为Observable<t></t></t></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Calls the associated hook function.</span><br><span class="line"><span class="comment">/* @param &lt;T&gt; the value type</span></span><br><span class="line"><span class="comment">   @param source the hook's input value</span></span><br><span class="line"><span class="comment">   @return the value returned by the hook</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(&#123; <span class="string">"rawtypes"</span>, <span class="string">"unchecked"</span> &#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Observable&lt;T&gt; <span class="title">onAssembly</span><span class="params">(Observable&lt;T&gt; source)</span> </span>&#123;</span><br><span class="line">	Function&lt;Observable, Observable&gt; f = onObservableAssembly; <span class="comment">// 初始值是null</span></span><br><span class="line">	<span class="keyword">if</span> (f != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> apply(f,source); ---\&gt;C,函数f是源码自带的onObservableAssembly</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> source;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>C.</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Wraps the call to the function in try-catch and propagates thrown checked exceptions as RuntimeException.</span></span><br><span class="line"><span class="comment">@param &lt;T&gt; the input type</span></span><br><span class="line"><span class="comment">@param &lt;R&gt; the output type</span></span><br><span class="line"><span class="comment">@param f the function to call, not null (not verified)</span></span><br><span class="line"><span class="comment">@param t the parameter value to the function</span></span><br><span class="line"><span class="comment">@return the result of the function call</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">static &lt;T, R&gt; R apply(Function&lt;T, R&gt; f, T t) &#123;</span></span><br><span class="line"><span class="comment">	try &#123;</span></span><br><span class="line"><span class="comment">		return f.apply(t); ---&gt;D，自带的函数f进行apply</span></span><br><span class="line"><span class="comment">	&#125; catch (Throwable ex) &#123;</span></span><br><span class="line"><span class="comment">		throw ExceptionHelper.wrapOrThrow(ex);</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br></pre></td></tr></table></figure></p>
<p><strong>D.</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* A functional interface that takes a value and returns another value, possibly with a different type and allows throwing a checked exception.</span></span><br><span class="line"><span class="comment">@param &lt;T&gt; the input value type</span></span><br><span class="line"><span class="comment">@param &lt;R&gt; the output value type</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">public interface Function&lt;T, R&gt; &#123;</span></span><br><span class="line"><span class="comment">/* Apply some calculation to the input value and return some other value.*/</span></span><br><span class="line">	<span class="meta">@param</span> t the input value</span><br><span class="line">	<span class="meta">@return</span> the output value</span><br><span class="line">	<span class="meta">@throws</span> Exception on error</span><br><span class="line">	</span><br><span class="line">	<span class="function">R <span class="title">apply</span><span class="params">(T t)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>E.subscribeOn:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@param</span> scheduler the &#123;<span class="meta">@link</span> Scheduler&#125; to perform subscription actions on</span><br><span class="line"><span class="meta">@return</span> the source ObservableSource modified so that its subscriptions happen on the specified &#123;<span class="meta">@link</span> Scheduler&#125;</span><br><span class="line">@see &lt;a href="http://reactivex.io/documentation/operators/subscribeon.html"&gt;ReactiveX operators documentation: SubscribeOn&lt;/a&gt;</span><br><span class="line">@see &lt;a href="http://www.grahamlea.com/2014/07/rxjava-threading-examples/"&gt;RxJava Threading Examples&lt;/a&gt;</span><br><span class="line">@see #observeOn</span><br><span class="line"><span class="meta">@SchedulerSupport</span>(SchedulerSupport.CUSTOM)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Observable&lt;T&gt; <span class="title">subscribeOn</span><span class="params">(Scheduler scheduler)</span> </span>&#123;</span><br><span class="line">	ObjectHelper.requireNonNull(scheduler, <span class="string">"scheduler is null"</span>);</span><br><span class="line">		<span class="keyword">return</span> RxJavaPlugins.onAssembly(<span class="keyword">new</span> ObservableSubscribeOn&lt;T&gt;(<span class="keyword">this</span>,scheduler));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>onAssembly就是刚才分析的那个，把当前的observable和scheduler整合，并且以observable<t>的形式返回。</t></p>
<p><strong>F.</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@param</span> &lt;R&gt; the value type of the inner ObservableSources and the output type</span><br><span class="line"><span class="meta">@param</span> mapper a function that, when applied to an item emitted by the source</span><br><span class="line">ObservableSource, returns an ObservableSource</span><br><span class="line"><span class="meta">@return</span> an Observable that emits the result of applying the transformation function to each item emitted by the source ObservableSource and merging the results of the</span><br><span class="line">ObservableSources obtained from <span class="keyword">this</span> transformation</span><br><span class="line">@see &lt;a href="http://reactivex.io/documentation/operators/flatmap.html"\&gt;ReactiveX operators documentation: FlatMap&lt;/a&gt;</span><br><span class="line"><span class="meta">@SchedulerSupport</span>(SchedulerSupport.NONE)</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> &lt;R&gt; <span class="function">Observable&lt;R&gt; <span class="title">flatMap</span><span class="params">(Function&lt;? <span class="keyword">super</span></span></span></span><br><span class="line"><span class="function"><span class="params">T, ? extends ObservableSource&lt;? extends R&gt;&gt; mapper)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> flatMap(mapper, <span class="keyword">false</span>); ----&gt; G</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>G.</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SchedulerSupport</span>(SchedulerSupport.NONE)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> &lt;R&gt; <span class="function">Observable&lt;R&gt; <span class="title">flatMap</span><span class="params">(Function&lt;? <span class="keyword">super</span> T, ? extends ObservableSource&lt;? extends R&gt;&gt; mapper, <span class="keyword">boolean</span> delayErrors, <span class="keyword">int</span> maxConcurrency, <span class="keyword">int</span> bufferSize)</span> </span>&#123;</span><br><span class="line">	ObjectHelper.requireNonNull(mapper, <span class="string">"mapper is null"</span>);</span><br><span class="line">	ObjectHelper.verifyPositive(maxConcurrency, <span class="string">"maxConcurrency"</span>);</span><br><span class="line">	ObjectHelper.verifyPositive(bufferSize, <span class="string">"bufferSize"</span>);</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span> <span class="keyword">instanceof</span> ScalarCallable) &#123;</span><br><span class="line">		<span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">		T v = ((ScalarCallable&lt;T&gt;)<span class="keyword">this</span>).call(); ----&gt;<span class="keyword">this</span>可能会重写call函数（这不就是flatmap实际使用时重写的call函数吗....(lambda传入的那个函数）</span><br><span class="line">		<span class="keyword">if</span> (v == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> empty(); ---&gt; H</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> ObservableScalarXMap.scalarXMap(v,mapper); ---&gt; I</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> RxJavaPlugins.onAssembly(<span class="keyword">new</span> ObservableFlatMap&lt;T, R&gt;(<span class="keyword">this</span>, mapper, delayErrors, maxConcurrency, bufferSize));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>H.</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@param</span> &lt;T&gt; <span class="function">the type of the <span class="title">items</span> <span class="params">(ostensibly)</span> emitted by the ObservableSource</span></span><br><span class="line"><span class="function">@return an Observable that emits no items to the </span>&#123;\<span class="meta">@link</span> Observer&#125; but immediately invokes the &#123;<span class="meta">@link</span> Observer&#125;<span class="string">'s &#123;@link Observer#onComplete() onComplete&#125; method</span></span><br><span class="line"><span class="string">@see &lt;a href="http://reactivex.io/documentation/operators/empty-never-throw.html"&gt;ReactiveX operators documentation: Empty&lt;/a&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">@SchedulerSupport(SchedulerSupport.NONE)</span></span><br><span class="line"><span class="string">@SuppressWarnings("unchecked")</span></span><br><span class="line"><span class="string">public static &lt;T&gt; Observable&lt;T&gt; empty() &#123;</span></span><br><span class="line"><span class="string">	return RxJavaPlugins.onAssembly((Observable&lt;T&gt; ObservableEmpty.INSTANCE);</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure></p>
<p><strong>I.</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*Maps a scalar value into an Observable and emits its values.*/</span></span><br><span class="line"><span class="meta">@param</span> &lt;T&gt; the scalar value type</span><br><span class="line"><span class="meta">@param</span> &lt;U&gt; the output value type</span><br><span class="line"><span class="meta">@param</span> value the scalar value to map</span><br><span class="line"><span class="meta">@param</span> mapper the function that gets the scalar value and should <span class="keyword">return</span> an ObservableSource that gets streamed</span><br><span class="line"><span class="meta">@return</span> the <span class="keyword">new</span> Observable instance*/</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T, U&gt; <span class="function">Observable&lt;U&gt; <span class="title">scalarXMap</span><span class="params">(T value, Function&lt;? <span class="keyword">super</span> T, ? extends ObservableSource&lt;? extends U&gt;&gt;</span></span></span><br><span class="line"><span class="function"><span class="params">mapper)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> RxJavaPlugins.onAssembly(<span class="keyword">new</span> ScalarXMapObservable&lt;T,</span><br><span class="line">U&gt;(value, mapper));---&gt;J 同样的，<span class="keyword">new</span>一个observable</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>J.</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 把标准值T映射为observableSource，并且订阅他 Maps a scalar value to an ObservableSource and subscribes to it.*/</span></span><br><span class="line"><span class="meta">@param</span> &lt;T&gt; the scalar value type</span><br><span class="line"><span class="meta">@param</span> \&lt;R\&gt; the mapped ObservableSource<span class="string">'s element type.</span></span><br><span class="line"><span class="string">static final class ScalarXMapObservable &lt;T, R&gt; extends</span></span><br><span class="line"><span class="string">Observable&lt;R&gt; &#123;</span></span><br><span class="line"><span class="string">	final T value;</span></span><br><span class="line"><span class="string">	final Function&lt;? super T, ? extends ObservableSource&lt;? extends R&gt;&gt; mapper;</span></span><br><span class="line"><span class="string">	ScalarXMapObservable(T value, Function &lt;? super T, ? extends ObservableSource&lt;? extends R&gt;&gt; mapper) &#123;</span></span><br><span class="line"><span class="string">		this.value = value;</span></span><br><span class="line"><span class="string">		this.mapper = mapper;</span></span><br><span class="line"><span class="string">	&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>2A.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public final class ObservableCreate&lt;T&gt; extends Observable&lt;T&gt; &#123;&#125;</span><br><span class="line">@Override</span><br><span class="line">protected void subscribeActual(Observer&lt;? super T&gt; observer) &#123;</span><br><span class="line">	//创建发射器，这个observer是我们在应用层自己定义的observer（重写了onNext,onSuccess等函数)</span><br><span class="line">	CreateEmitter&lt;T&gt; parent = new CreateEmitter&lt;T&gt;(observer);</span><br><span class="line">	observer.onSubscribe(parent); // 每个observer都要重写的四个函数之一</span><br><span class="line">	try &#123;</span><br><span class="line">		source.subscribe(parent); // 这个source是每个onXXXX(new ObservableXXX(ffff))中new这个类时传入的参数（其实就是我们在应用层调用create（ffff）时的参数ffff,那么，每个类，比如create的参数类ObservableOnSubscribe&lt;T&gt;，都会重写属于自己的subscribe函数。这样就创建了一个emmiter</span><br><span class="line">	&#125; catch (Throwable ex) &#123;</span><br><span class="line">		Exceptions.throwIfFatal(ex);</span><br><span class="line">		parent.onError(ex);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>K.</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ScalarDisposable</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">AtomicInteger</span></span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">QueueDisposable</span> &lt;<span class="title">T</span>&gt;, <span class="title">Runnable</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ScalarDisposable</span><span class="params">(Observer &lt;? <span class="keyword">super</span> T&gt; observer, T</span></span></span><br><span class="line"><span class="function"><span class="params">value)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.observer = observer;</span><br><span class="line">	<span class="keyword">this</span>.value = value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>L.</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 继承了原子类，又用了CAS = =</span></span><br><span class="line">	<span class="keyword">if</span> (get() == START &amp;&amp; compareAndSet(START, ON_NEXT)) &#123;</span><br><span class="line">		observer.onNext(value);</span><br><span class="line">		<span class="keyword">if</span> (get() == ON_NEXT) &#123;</span><br><span class="line">			lazySet(ON_COMPLETE); </span><br><span class="line">			bserver.onComplete();</span><br><span class="line">		&#125;	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>复习一下原子类<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lazySet</span><span class="params">(<span class="keyword">int</span> newValue)</span> </span>&#123;</span><br><span class="line">	U.putOrderedInt(<span class="keyword">this</span>, VALUE, newValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>原子类设置值的时候像volatile一样，可以保证其他线程读取到最新的值，这个putOrderedInt其实是volatile的延迟版，也就是其他线程可能在值改变后仍然读到旧值。这有什么好处呢？性能：在多核处理器下，内存以及cpu缓存的读和写常常是顺序执行的，所以在多个cpu缓存之间同步一个内存值的代价是很昂贵的。</p>
<p><strong>2B.</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ScalarDisposable</span><span class="params">(Observer&lt;? <span class="keyword">super</span> T&gt; observer, T</span></span></span><br><span class="line"><span class="function"><span class="params">value)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.observer = observer;</span><br><span class="line">	<span class="keyword">this</span>.value = value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>static final class ScalarXMapObservable&lt;T, R&gt; extends<br>Observable<r> {}</r></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribeActual</span><span class="params">(Observer&lt;? <span class="keyword">super</span> R&gt; s)</span></span>&#123;</span><br><span class="line">ObservableSource&lt;? extends R&gt; other;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		other = ObjectHelper.requireNonNull(mapper.apply(value), <span class="string">"The mapper returned</span></span><br><span class="line"><span class="string">		a null ObservableSource"</span>); <span class="comment">//这个函数mapper就不再是源码自带的，而是我自己传的参数function</span></span><br><span class="line">	&#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">		EmptyDisposable.error(e, s);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (other <span class="keyword">instanceof</span> Callable) &#123;</span><br><span class="line">		R u;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			u = ((Callable&lt;R&gt;)other).call(); <span class="comment">//调用这个Function的call函数（我们重写的)</span></span><br><span class="line">		&#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">			Exceptions.throwIfFatal(ex);</span><br><span class="line">			EmptyDisposable.error(ex, s);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">		<span class="keyword">if</span> (u == <span class="keyword">null</span>) &#123;</span><br><span class="line">			EmptyDisposable.complete(s);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		ScalarDisposable&lt;R&gt; sd = <span class="keyword">new</span> ScalarDisposable&lt;R&gt;(s,u);---&gt;K</span><br><span class="line">		s.onSubscribe(sd); <span class="comment">//observer都会重写onSubscribe函数（好像也没有...迷）</span></span><br><span class="line">		sd.run(); -----&gt;L</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		other.subscribe(s);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>总结一下几个常用的操作符：</strong><br>总结几个点：</p>
<ul>
<li><p>操作符的参数，就是我们应用层使用时候传入的参数</p>
</li>
<li><p>这个参数，又会被传进各种ObservableXXX的类进行改造（new<br>….），这些类，通常都会进行source （以及value等的存储），这个source，就是<br>subscribeActual中最后 source.subscribe(parent);<br>时的source(parent就是我们subscribe时写的四个函数的包装）</p>
</li>
</ul>
<p><strong>1）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SchedulerSupport</span>(SchedulerSupport.NONE)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Observable&lt;T&gt; <span class="title">create</span><span class="params">(ObservableOnSubscribe&lt;T&gt;</span></span></span><br><span class="line"><span class="function"><span class="params">source)</span> </span>&#123;</span><br><span class="line">	ObjectHelper.requireNonNull(source, <span class="string">"source is null"</span>);</span><br><span class="line">		<span class="keyword">return</span> RxJavaPlugins.onAssembly(<span class="keyword">new</span> ObservableCreate&lt;T&gt;(source));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SchedulerSupport</span>(SchedulerSupport.NONE)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Observable&lt;T&gt; <span class="title">just</span><span class="params">(T item)</span> </span>&#123;</span><br><span class="line">	ObjectHelper.requireNonNull(item, <span class="string">"The item is null"</span>);</span><br><span class="line">		<span class="keyword">return</span> RxJavaPlugins.onAssembly(<span class="keyword">new</span> ObservableJust&lt;T&gt;(item));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>3）</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SchedulerSupport</span>(SchedulerSupport.CUSTOM)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Observable&lt;T&gt; <span class="title">subscribeOn</span><span class="params">(Scheduler scheduler)</span></span>&#123;</span><br><span class="line">	ObjectHelper.requireNonNull(scheduler, <span class="string">"scheduler is null"</span>);</span><br><span class="line">		<span class="keyword">return</span> RxJavaPlugins.onAssembly(<span class="keyword">new</span> ObservableSubscribeOn&lt;T&gt;(<span class="keyword">this</span>,scheduler));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>4）</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SchedulerSupport</span>(SchedulerSupport.CUSTOM)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Observable&lt;T&gt; <span class="title">observeOn</span><span class="params">(Scheduler scheduler, <span class="keyword">boolean</span></span></span></span><br><span class="line"><span class="function"><span class="params">delayError, <span class="keyword">int</span> bufferSize)</span> </span>&#123;</span><br><span class="line">	ObjectHelper.requireNonNull(scheduler, <span class="string">"scheduler is null"</span>);</span><br><span class="line">	ObjectHelper.verifyPositive(bufferSize, <span class="string">"bufferSize"</span>);</span><br><span class="line">	<span class="keyword">return</span> RxJavaPlugins.onAssembly(<span class="keyword">new</span> ObservableObserveOn&lt;T&gt;(<span class="keyword">this</span>,scheduler, delayError, bufferSize));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>思考一、为什么一定要调用subscribe？</strong></p>
<p><strong>看源码可以看出，</strong><br>observer = RxJavaPlugins.onSubscribe(this,observer);<br><strong>和</strong><br>subscribeActual(observer);<br><strong>这两句</strong></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/11/查找算法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ke Yu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coco">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/11/查找算法/" itemprop="url">常见查找算法总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-09-11T19:31:14+08:00">
                2017-09-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="一、静态查找"><a href="#一、静态查找" class="headerlink" title="一、静态查找"></a>一、静态查找</h3><h4 id="1）顺序查找：时间复杂度O（N）"><a href="#1）顺序查找：时间复杂度O（N）" class="headerlink" title="1）顺序查找：时间复杂度O（N）"></a>1）顺序查找：<strong>时间复杂度O（N）</strong></h4><p><strong>平均查找长度：(n+1）/2  </strong><br><strong>优点：对表的结构没有要求</strong></p>
<h4 id="2）二分查找：期望时间复杂度O（logN）这是一定的！"><a href="#2）二分查找：期望时间复杂度O（logN）这是一定的！" class="headerlink" title="2）二分查找：期望时间复杂度O（logN）这是一定的！"></a>2）二分查找：<strong>期望时间复杂度O（logN）这是一定的！</strong></h4><p><strong>平均查找长度：log(N+1)-1</strong><br><strong>成功查找为log(N）+1</strong><br><strong>不成功查找为log(N）+1</strong></p>
<p>如果需要添加或者删除一个数据，整个结构都要重建，代价太大。<br>优点：时间性能比顺序查找好，效率较高<br>缺点：只适用于顺序存储结构</p>
<p>扩展：</p>
<p><strong>插值查找</strong>， 不从1/2处断开，而是从1/3,1/4等等地方分开。<br>时间复杂度为O（log(logN))<br><strong>适合于关键字分布又均匀的表。</strong> 如果分布不均匀，那么不适合用插值查找。<br>mid=(low+high)/2, 即mid=low+1/2*(high-low);<br>通过类比，我们可以将查找的点改进为如下：<br>mid=low+<strong>(key-a[low])/(a[high]-a[low])</strong>*(high-low)，<br>斐波那契查找，按黄金比例进行分割。</p>
<h4 id="3）分块查找"><a href="#3）分块查找" class="headerlink" title="3）分块查找"></a>3）分块查找</h4><p>也称索引顺序查找。是1）和2）的改进。<br>把线性表分为若干块；块内无序；块间有序<br>建立一个索引表，存储<strong>每块内的最大值和这块的起始地址</strong>。</p>
<p><strong>时间复杂度为O（N）~ O（logN）</strong><br><strong>平均查找长度：(n/s+s)/2+1 ( s是每块的元素个数）</strong><br><strong>优点：顺序存储和链式存储都适用；查找效率高</strong><br><strong>缺点：需要将表分块排序，并且需要为索引表增加存储空间</strong></p>
<p><img src="http://ovwunej09.bkt.clouddn.com/search01.png" alt="conclusion"></p>
<h3 id="二、动态查找"><a href="#二、动态查找" class="headerlink" title="二、动态查找"></a>二、动态查找</h3><h4 id="3）二叉查找树：便于插入和删除，解决了2）的问题"><a href="#3）二叉查找树：便于插入和删除，解决了2）的问题" class="headerlink" title="3）二叉查找树：便于插入和删除，解决了2）的问题"></a>3）二叉查找树：便于插入和删除，解决了2）的问题</h4><p>树可能退化为线性结构，<strong>此时是最坏情况，O（N）</strong><br><strong>最好情况是O（logN）</strong></p>
<h4 id="4）平衡二叉树-AVL-其实是平衡二叉查找树）"><a href="#4）平衡二叉树-AVL-其实是平衡二叉查找树）" class="headerlink" title="4）平衡二叉树(AVL,其实是平衡二叉查找树）"></a>4）平衡二叉树(AVL,其实是平衡二叉查找树）</h4><p>不会出现3的最坏情况。<br><strong>时间复杂度是O（logN） </strong><br>插入、删除时需要做左旋和右旋等操作。</p>
<p>平衡二叉树又被称为AVL树（有别于AVL算法），且具有以下性质：<strong>它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。</strong></p>
<h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>(1) 查找代价：</p>
<p>AVL是严格平衡的BST（平衡因子不超过1）。那么查找过程与BST一样，只是AVL不会出现最差情况的BST(单支树)。因此<strong>查找效率最好，最坏情况都是O(logN)数量级的。</strong></p>
<p>(2) 插入代价：</p>
<p>AVL必须要保证严格平衡<strong>(|bf|\&lt;=1)</strong>，那么每一次插入数据使得AVL中某些结点的平衡因子超过1就必须进行旋转操作。事实上，AVL的每一次插入结点操作最多只需要旋转1次(单旋转或双旋转)。<strong>因此，总体上插入操作的代价仍然在O(logN)级别上</strong>(插入结点需要首先查找插入的位置)。</p>
<p>(3) 删除代价：</p>
<p>AVL删除结点的算法可以参见BST的删除结点，但是<strong>删除之后必须检查从删除结点开始到根结点路径上的所有结点的平衡因子。因此删除的代价稍微要大一些。每一次删除操作最多需要O(logN)次旋转。因此，删除操作的时间复杂度为O(logN)+O(logN)=O(2logN)</strong></p>
<p>缺点：</p>
<ul>
<li>为了保持平衡性，动态插入和删除的代价过高；</li>
<li>二叉查找树的查找代价都与树高有关，所以需要减小树高。</li>
</ul>
<h4 id="5）红黑树：并不完全平衡"><a href="#5）红黑树：并不完全平衡" class="headerlink" title="5）红黑树：并不完全平衡"></a>5）红黑树：并不完全平衡</h4><p>根节点为黑色；所有叶子节点是黑色；每个红色节点的两个子节点是黑色；<br><strong>时间复杂度：O（logN)进行搜索、插入、删除。</strong></p>
<h5 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h5><p><strong>(1) 查找代价：</strong></p>
<p><strong>由于红黑树的性质(最长路径长度不超过最短路径长度的2倍)，可以说明红黑树虽然不像AVL一样是严格平衡的，但平衡性能还是要比BST要好。其查找代价基本维持在O(logN)左右，但在最差情况下(最长路径是最短路径的2倍少1)，比AVL要略逊色一点。</strong></p>
<p><strong>(2) 插入代价：</strong></p>
<p><strong>RBT插入结点时，需要旋转操作和变色操作。但由于只需要保证RBT基本平衡就可以了。因此插入结点最多只需要2次旋转，这一点和AVL的插入操作一样。虽然变色操作需要O(logN)，但是变色操作十分简单，代价很小。</strong></p>
<p><strong>(3) 删除代价：</strong></p>
<p><strong>RBT的删除操作代价要比AVL要好的多，删除一个结点最多只需要3次旋转操作。</strong></p>
<h4 id="6）多路查找树（B-B"><a href="#6）多路查找树（B-B" class="headerlink" title="6）多路查找树（B~,B+)"></a>6）多路查找树（B~,B+)</h4><p>一个节点上拥有多于2个节点的二叉查找树。<br>B（B-）树：待插入结构图</p>
<h5 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h5><p>(1) 查找代价：</p>
<p>B-Tree作为一个平衡多路查找树(m-叉)。B树的查找分成两种：一种是从一个结点查找另一结点的地址的时候，需要定位磁盘地址(查找地址)，查找代价极高。另一种是将结点中的有序关键字序列放入内存，进行优化查找(可以用折半)，相比查找代价极低。而<strong>B树的高度很小，因此在这一背景下，B树比任何二叉结构查找树的效率都要高很多。而且B+树作为B树的变种，其查找效率更高。</strong></p>
<p>(2)插入代价：</p>
<p><strong>B-Tree的插入会发生结点的分裂操作。当插入操作引起了s个节点的分裂时，磁盘访问的次数为h(读取搜索路径上的节点)＋2s(回写两个分裂出的新节点)＋1（回写新的根节点或插入后没有导致分裂的节点）。因此，所需要的磁盘访问次数是h+2s+1，最多可达到3h+1。因此插入的代价是很大的。</strong></p>
<p>(3)删除代价：</p>
<p><strong>B-Tree的删除会发生结点合并操作。最坏情况下磁盘访问次数是3h＝（找到包含被删除元素需要h次读访问）+（获取第2至h层的最相邻兄弟需要h-1次读访问）+（在第3至h层的合并需要h-2次写访问）+（对修改过的根节点和第2层的两个节点进行3次写访问）。</strong></p>
<p>B+：待插入结构图</p>
<p>应用场景：<br>来自知乎<a href="https://www.zhihu.com/question/30527705/answer/52750388：" target="_blank" rel="noopener">https://www.zhihu.com/question/30527705/answer/52750388：</a><br>AVL是一种高度平衡的二叉树，所以通常的结果是，维护这种高度平衡所付出的代价比从中获得的效率收益还大，故而实际的应用不多，更多的地方是用追求局部而不是非常严格整体平衡的红黑树。当然，如果场景中对插入删除不频繁，只是对查找特别有要求，AVL还是优于红黑的。<br>红黑树的应用就很多了，除了上面同学提到的STL，还有</p>
<ul>
<li>著名的linux进程调度<a href="https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Completely_Fair_Scheduler" target="_blank" rel="noopener">Completely Fair<br>Scheduler</a>,用红黑树管理进程控制块</li>
<li>epoll在内核中的实现，用红黑树管理事件块</li>
<li>nginx中，用红黑树管理timer等</li>
<li>Java的TreeMap实现<br>B和B+主要用在文件系统以及数据库中做索引等，比如Mysql：<a href="https://link.zhihu.com/?target=https%3A//guptavikas.wordpress.com/2012/12/17/b-tree-index-in-mysql/" target="_blank" rel="noopener">B-Tree Index in<br>MySql</a></li>
</ul>
<p>trie树的一个典型应用是前缀匹配，比如下面这个很常见的场景，在我们输入时，搜索引擎会给予提示</p>
<h4 id="7）哈希"><a href="#7）哈希" class="headerlink" title="7）哈希"></a>7）哈希</h4><p>查找复杂度<strong>为O（1）</strong>，可以通过变换哈希函数在空间和时间上做出权衡。</p>
<p><img src="media/20d9923d23ee1ed7437cb641fa9dd379.png" alt="clipboard.png"></p>
<p>平均查找长度：<strong>等概率</strong>下一次查找<strong>所有元素</strong>的比较次数。<br>二分查找，查找成功的最大次数为：logN（取下限），logN（取下限）+1。</p>
<h4 id="相关题目（基础知识应用）"><a href="#相关题目（基础知识应用）" class="headerlink" title="相关题目（基础知识应用）"></a>相关题目（基础知识应用）</h4><p>1.长度为12的无重复有序表，查找成功的平均比较次数为：37/12<br>把1到12的查找次数都算出来相加除以12（这方法太傻<br>注意：查找1的次数为3,2的次数为2，所以二分法用的是法1， 不是法2<br>画二叉树来计算：</p>
<pre><code>      6

3             9
</code></pre><p>   2    5     7         11</p>
<p>1     4          8   10  12</p>
<p>1*1+2*2+4*3+5*4=37</p>
<p>2.但是找77 ，34,99 这三个数的时候又是用法二…</p>
<p>3.顺序查找都是将target与元素逐一比较，所以无论表是有序还是无序，查找长度都是n</p>
<p>4.设有关键字n=2\^h-1，<br>构成二叉排序树……，概率相等，查找成功的ASL最大是n：错。<br>注意读题！ASL是平均查找长度，最坏为线性查找（n+1)/2,<br>时间复杂度为O（n），注意n和O（n）是不同的！！</p>
<p>5.找82的那个数，比较4次，用的方法2…</p>
<p>6.从n个数中找最大的两个数理论上需要几次比较：<br>找最大的：n-1    找第二大的：logn-1<br>一共n+logn-2</p>
<p>7.顺序查找中，有序表和无序表的查找失败的平均查找长度不同：<br>对于有序表，如果找不到，可以直接退出<br>对于无序表，要全部遍历完才可以确定查找失败。</p>
<p>8.既希望较快的查找又便于<strong>线性表</strong>动态变化的查找方法是：<strong>索引顺序查找。</strong></p>
<p><strong>不是哈希！如果哈希的存储不是链式，一般情况随着关键字的增多，冲突频繁发生，查找性能会下降，并且利于动态变化。</strong></p>
<p>9.<strong>n个顶点的树一定有n-1条边</strong>，所以如果n个顶点m条边的全连通图需要去掉m-(n-1)条边</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/10/eventBus/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ke Yu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coco">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/10/eventBus/" itemprop="url">EventBus源码解析(1)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-09-10T20:19:30+08:00">
                2017-09-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>3.EventBus</strong></p>
<p>由于没有用过，所以先在这里理解一下几个重点名词：</p>
<p>event：我们想监听的事件，比如点击按钮，网页请求返回了响应</p>
<p>eventType：我们想监听的事件的类型</p>
<p>subscrible：订阅者，订阅事件的对象，当订阅者订阅的事件发生后，就会执行订阅者的响应函数，onEvent。</p>
<p><strong>使用第一步：在接收消息的activity中(onStart())</strong></p>
<p><strong>EventBus.getDefault().register(this); —>B</strong></p>
<p><strong>字母开头和1字母开头的，都是rigister的延伸。</strong></p>
<p><strong>使用第二步：在发送消息的activity中，</strong></p>
<p><strong>EventBus.getDefault().post(new Event(“Event btn clicked”)); ——>2A</strong></p>
<p><strong>2字母开头的，都是这个的延伸。</strong></p>
<p><strong>使用第三步：在接收消息的activity中（onStop())</strong></p>
<p><strong>EventBus.getDefault().unregister(this);——->3A</strong></p>
<p><strong>①EventBus.JAVA</strong></p>
<p><strong>A.</strong></p>
<p>单例模式，双重检查+volatile ，获取eventBus的实例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">volatile</span> EventBus defaultInstance;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> EventBus <span class="title">getDefault</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (defaultInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">synchronized</span> (EventBus.class) &#123;</span><br><span class="line">			<span class="keyword">if</span> (defaultInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">				defaultInstance = <span class="keyword">new</span> EventBus();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> defaultInstance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>3A.</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Unregisters the given subscriber from all event classes. 这是通过订阅者找出订阅类型来注销这个订阅者的所有订阅*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">unregister</span><span class="params">(Object subscriber)</span> </span>&#123;</span><br><span class="line"><span class="comment">//取出订阅者订阅的所有事件类型</span></span><br><span class="line">List&lt;Class&lt;?&gt;&gt; subscribedTypes = typesBySubscriber.get(subscriber);</span><br><span class="line">	<span class="keyword">if</span> (subscribedTypes != <span class="keyword">null</span>) &#123;</span><br><span class="line">	<span class="comment">//遍历所有事件类型，注销订阅</span></span><br><span class="line">	<span class="keyword">for</span> (Class&lt;?&gt; eventType : subscribedTypes) &#123;</span><br><span class="line">		unsubscribeByEventType(subscriber, eventType);----&gt;<span class="number">3</span>B</span><br><span class="line">	&#125;</span><br><span class="line">	typesBySubscriber.remove(subscriber);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123; <span class="comment">//这个订阅者没有订阅过任何事件。</span></span><br><span class="line">	但是，没有订阅过，有可能register啊...？？？？</span><br><span class="line">	Log.w(TAG, <span class="string">"Subscriber to unregister was not registered before: "</span> + subscriber.getClass());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>3B.</strong></p>
<p><strong>更新subscriptionsByEventType，而不是typesBySubscriber，typesBySubscriber在3A中（unregister)更新了</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Only updates subscriptionsByEventType, not typesBySubscriber! Caller must</span></span><br><span class="line"><span class="comment">update typesBySubscriber. 这是通过事件类型找出所有订阅者来取消订阅*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unsubscribeByEventType</span><span class="params">(Object subscriber, Class&lt;?&gt; eventType)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//通过事件类型取出订阅该类型的所有subscriptions，**注意，定义的时候，value是copyOnWriteList,这里就直接List了？？**</span></span><br><span class="line">List&lt;Subscription&gt; subscriptions =</span><br><span class="line">subscriptionsByEventType.get(eventType);</span><br><span class="line">	<span class="keyword">if</span> (subscriptions != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">int</span> size = subscriptions.size();</span><br><span class="line"><span class="comment">//遍历subscription,找到当前要注销的subcriber，更改active状态，并且从这个list中将它移出</span></span><br><span class="line"><span class="comment">// 这个find并且remove的过程- -真是清新自然，没有更简单的方法？？</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">			Subscription subscription = subscriptions.get(i);</span><br><span class="line">			<span class="keyword">if</span> (subscription.subscriber == subscriber) &#123;</span><br><span class="line">				subscription.active = <span class="keyword">false</span>;</span><br><span class="line">				subscriptions.remove(i);</span><br><span class="line">				i--;</span><br><span class="line">				size--;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2A.</strong></p>
<p><strong>从这里到2I，都是这个函数的延伸。</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">post</span><span class="params">(Object event)</span> </span>&#123;</span><br><span class="line">	PostingThreadState postingState =</span><br><span class="line">	currentPostingThreadState.get();---&gt;<span class="number">2</span>B</span><br><span class="line">	List&lt;Object&gt; eventQueue = postingState.eventQueue; <span class="comment">//postingThread的queue</span></span><br><span class="line">	eventQueue.add(event); <span class="comment">//向这个List添加事件</span></span><br><span class="line">	<span class="keyword">if</span> (!postingState.isPosting) &#123;</span><br><span class="line">		<span class="comment">//这个boolean值，都没有被赋值过...所以是取默认值？？boolean的默认值是false，所以就说得通了。</span></span><br><span class="line">		<span class="comment">//判断进行post的线程是否主线程</span></span><br><span class="line">		postingState.isMainThread = Looper.getMainLooper() == Looper.myLooper();</span><br><span class="line">		<span class="comment">//当前线程的isPosting为真</span></span><br><span class="line">		postingState.isPosting = <span class="keyword">true</span>;</span><br><span class="line">		<span class="comment">//如果取消了，抛出异常。</span></span><br><span class="line">		<span class="keyword">if</span> (postingState.canceled) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">"Internal error. Abort state was not reset"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">while</span> (!eventQueue.isEmpty()) &#123;</span><br><span class="line">				<span class="comment">//如果当前线程要post的事件队列不为空，取出队首，执行了postSingleEventForEventType，然后在里面又执行了postToSubscription，完成了post</span></span><br><span class="line">				postSingleEvent(eventQueue.remove(<span class="number">0</span>), postingState);---&gt;<span class="number">2</span>D</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			<span class="comment">//finally里面初始化成员变量</span></span><br><span class="line">			postingState.isPosting = <span class="keyword">false</span>;</span><br><span class="line">			postingState.isMainThread = <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>2D.</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postSingleEvent</span><span class="params">(Object event, PostingThreadState postingState)</span> <span class="keyword">throws</span> Error </span>&#123;</span><br><span class="line">	Class&lt;?&gt; eventClass = event.getClass();</span><br><span class="line">	<span class="keyword">boolean</span> subscriptionFound = <span class="keyword">false</span>;</span><br><span class="line">	<span class="keyword">if</span> (eventInheritance) &#123;</span><br><span class="line">	List&lt;Class&lt;?&gt;&gt; eventTypes = lookupAllEventTypes(eventClass);---&gt;<span class="number">2</span>E,得到这个eventClass的所有超类和父接口（也就是它可以对应的所有事件类型）</span><br><span class="line">	<span class="keyword">int</span> countTypes = eventTypes.size();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> h = <span class="number">0</span>; h &lt; countTypes; h++) &#123;</span><br><span class="line">			Class&lt;?&gt; clazz = eventTypes.get(h);</span><br><span class="line">			subscriptionFound |= postSingleEventForEventType(event, postingState, clazz);----&gt;<span class="number">2</span>G，在postSingleEventForEventType里面遍历所有监听了这个事件类型的subcription,通过postToSubscription去找线程调用订阅者的响应方法</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123; <span class="comment">//没有进入else，就直接调用postSingleEventForEventType	</span></span><br><span class="line">		subscriptionFound = postSingleEventForEventType(event, postingState, eventClass);----&gt;<span class="number">2</span>G</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!subscriptionFound) &#123;<span class="comment">//如果</span></span><br><span class="line">postSingleEventForEventType没执行成功，也就是这个事件没有订阅者订阅这类事件！！</span><br><span class="line">		<span class="keyword">if</span> (logNoSubscriberMessages) &#123;</span><br><span class="line">			Log.d(TAG, <span class="string">"No subscribers registered for event "</span> + eventClass);</span><br><span class="line">		&#125;</span><br><span class="line"><span class="comment">//这个判断有点奇怪。 eventClass 和 NoSubscriberEvent.class</span></span><br><span class="line">,怎么可能相等...不过看到post(<span class="keyword">new</span>...）就明白了，最开始的时候当然都是！=，不过重新<span class="keyword">new</span>了NoSubscriberEvent去post，当然可能==了。</span><br><span class="line">		<span class="keyword">if</span> (sendNoSubscriberEvent &amp;&amp; eventClass != NoSubscriberEvent.class &amp;&amp; eventClass != SubscriberExceptionEvent.class) &#123;----&gt;<span class="number">2</span>H，<span class="number">2</span>I</span><br><span class="line">			post(<span class="keyword">new</span> NoSubscriberEvent(<span class="keyword">this</span>,event));<span class="comment">//用当前类（调用post的类）和被post的event构造NoSubscriberEvent，所以有可能出现if中的第二种情况!!厉害了。但是第三种呢？？</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2H.</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 被post的事件没有订阅者订阅 哈哈哈哈哈 好惨</span></span><br><span class="line"><span class="comment"> This Event is posted by EventBus when no subscriber is found for a posted event.</span></span><br><span class="line"><span class="comment"> @author Markus</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NoSubscriberEvent</span> </span>&#123;</span><br><span class="line"><span class="comment">/* The &#123;\@link EventBus&#125; instance to with the original event was posted to.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">final</span> EventBus eventBus;</span><br><span class="line">	<span class="comment">/* The original event that could not be delivered to any subscriber. */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">final</span> Object originalEvent;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">NoSubscriberEvent</span><span class="params">(EventBus eventBus, Object originalEvent)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.eventBus = eventBus;</span><br><span class="line">		<span class="keyword">this</span>.originalEvent = originalEvent;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2I.</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 这个post的事件在订阅者响应函数中出现异常（需要理解下...</span></span><br><span class="line"><span class="comment"> This Event is posted by EventBus when an exception occurs inside a subscriber's event handling method.*</span></span><br><span class="line"><span class="comment"> @author Markus*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SubscriberExceptionEvent</span> </span>&#123;</span><br><span class="line"><span class="comment">/* The &#123;\@link EventBus&#125; instance to with the original event was posted to.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">final</span> EventBus eventBus;</span><br><span class="line">	<span class="comment">/* The Throwable thrown by a subscriber.*/</span></span><br><span class="line">	<span class="comment">//订阅者抛出的异常</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">final</span> Throwable throwable;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* The original event that could not be delivered to any subscriber. */</span></span><br><span class="line">	<span class="comment">//无法再被post给任何订阅者的event</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">final</span> Object causingEvent;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* The subscriber that threw the Throwable. */</span></span><br><span class="line">	<span class="comment">//抛出异常的订阅者</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">final</span> Object causingSubscriber;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">SubscriberExceptionEvent</span><span class="params">(EventBus eventBus, Throwable throwable,Object causingEvent,Object causingSubscriber)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.eventBus = eventBus;</span><br><span class="line">		<span class="keyword">this</span>.throwable = throwable;</span><br><span class="line">		<span class="keyword">this</span>.causingEvent = causingEvent;</span><br><span class="line">		<span class="keyword">this</span>.causingSubscriber = causingSubscriber;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2G.</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">postSingleEventForEventType</span><span class="params">(Object event, PostingThreadState postingState, Class&lt;?&gt; eventClass)</span> </span>&#123;</span><br><span class="line">	CopyOnWriteArrayList&lt;Subscription&gt; subscriptions;</span><br><span class="line">	<span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">	<span class="comment">//取出这个事件class所涉及的所有subscription(里面存储了订阅者和处理这个事件的方法）</span></span><br><span class="line">		subscriptions = subscriptionsByEventType.get(eventClass);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 这个if里面，不是一个意思？？？</span></span><br><span class="line">	<span class="comment">// 存在订阅这种事件类型的订阅者</span></span><br><span class="line">	<span class="keyword">if</span> (subscriptions != <span class="keyword">null</span> &amp;&amp; !subscriptions.isEmpty()) &#123;</span><br><span class="line">		<span class="keyword">for</span> (Subscription subscription : subscriptions) &#123;</span><br><span class="line">			<span class="comment">//遍历所有的subscription,设置postingState的参数</span></span><br><span class="line">			postingState.event = event;</span><br><span class="line">			postingState.subscription = subscription;</span><br><span class="line">			<span class="keyword">boolean</span> aborted = <span class="keyword">false</span>;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				postToSubscription(subscription, event,postingState.isMainThread);----&gt;<span class="number">1</span>D,在subscribe(..）粘性事件那里分析过了，所以那里的疑惑就解决了....那里的post是由于“粘性”立即post最近的event给订阅者，这里的postToSubscription是发送信息的一方直接调用post导致的</span><br><span class="line">				aborted = postingState.canceled; <span class="comment">//判断是否abort</span></span><br><span class="line">			&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">				<span class="comment">//当前状态的变量置为null，由于if可能结束循环，所以在finally中置空，避免内存泄漏。个人觉得...为什么不直接for循环外面置空，一定要置空了再赋值？？</span></span><br><span class="line">				postingState.event = <span class="keyword">null</span>;</span><br><span class="line">				postingState.subscription = <span class="keyword">null</span>;</span><br><span class="line">				postingState.canceled = <span class="keyword">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (aborted) &#123;</span><br><span class="line">				<span class="keyword">break</span>;<span class="comment">//如果abort了，那么这个事件的post就结束了</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//for循环结束，返回true</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//没进入if，返回false</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>2E.</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Looks up all Class objects including super classes and interfaces. Should also work for interfaces. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;Class&lt;?&gt;&gt; lookupAllEventTypes(Class&lt;?&gt; eventClass)&#123;</span><br><span class="line">	<span class="keyword">synchronized</span> (eventTypesCache) &#123;</span><br><span class="line">		<span class="comment">//从事件类的缓存中，根据事件class取出队列</span></span><br><span class="line">		List&lt;Class&lt;?&gt;&gt; eventTypes = eventTypesCache.get(eventClass);</span><br><span class="line">		<span class="keyword">if</span> (eventTypes == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="comment">//如果没有该类型的event，新建List</span></span><br><span class="line">			eventTypes = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">			Class&lt;?&gt; clazz = eventClass;</span><br><span class="line">			<span class="keyword">while</span> (clazz != <span class="keyword">null</span>) &#123;</span><br><span class="line">				eventTypes.add(clazz); <span class="comment">// 把当前事件类加到这个list中</span></span><br><span class="line">				<span class="comment">//clazz.getInterfaces(),又是反射机制，可以获得这个class实现自哪些接口。</span></span><br><span class="line">				addInterfaces(eventTypes,clazz.getInterfaces());---&gt;<span class="number">2F</span>，递归获得事件类的所有父接口，加到eventTypes这个list中</span><br><span class="line">				clazz = clazz.getSuperclass();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//然后把这个eventClass以及它可以对应的所有事件类型（List集合保存)加入cache</span></span><br><span class="line">			eventTypesCache.put(eventClass, eventTypes);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> eventTypes;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>2F.</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Recurses through super interfaces. */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addInterfaces</span><span class="params">(List&lt;Class&lt;?&gt;&gt; eventTypes, Class&lt;?&gt;[]</span></span></span><br><span class="line"><span class="function"><span class="params">interfaces)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (Class&lt;?&gt; interfaceClass : interfaces) &#123;</span><br><span class="line">	<span class="comment">//遍历事件类实现的接口，如果这个事件类型的List中不包含有这个接口</span></span><br><span class="line">		<span class="keyword">if</span> (!eventTypes.contains(interfaceClass)) &#123;</span><br><span class="line">			eventTypes.add(interfaceClass);<span class="comment">// 把这个接口添加进list</span></span><br><span class="line">		<span class="comment">// 继续用interfaceClass.getInterfaces()得到interfaceClass实现的接口</span></span><br><span class="line">		<span class="comment">//迭代这个方法</span></span><br><span class="line">			addInterfaces(eventTypes, interfaceClass.getInterfaces());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>2B</strong>.一个成员变量，<strong>PostingThreadState类型—&gt;2C</strong>的ThreadLocal<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ThreadLocal&lt;PostingThreadState&gt;</span><br><span class="line">currentPostingThreadState = <span class="keyword">new</span> ThreadLocal&lt;PostingThreadState&gt;() &#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> PostingThreadState <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//这个ThreadLocal的初始化就是new一个新的PostingThreadState();</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> PostingThreadState();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><strong>2C.一个静态常量内部类</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* For ThreadLocal, much faster to set (and get multiple values). */</span></span><br><span class="line"><span class="comment">//为了ThreadLocal可以更快的set和get？这里就是之前看threadLocal时提到的，postingThreadState用到了threadLocal</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PostingThreadState</span> </span>&#123;</span><br><span class="line">	<span class="keyword">final</span> List&lt;Object&gt; eventQueue = <span class="keyword">new</span> ArrayList&lt;Object&gt;();</span><br><span class="line">	<span class="keyword">boolean</span> isPosting;</span><br><span class="line">	<span class="keyword">boolean</span> isMainThread;</span><br><span class="line">	Subscription subscription;</span><br><span class="line">	Object event;</span><br><span class="line">	<span class="keyword">boolean</span> canceled;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>B</strong>.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(Object subscriber)</span> </span>&#123;</span><br><span class="line"><span class="comment">//首先通过反射，获取订阅者的类</span></span><br><span class="line">Class&lt;?&gt; subscriberClass = subscriber.getClass();</span><br><span class="line"><span class="comment">// 然后通过类，找类的方法，不是简单的用getMethod()</span></span><br><span class="line">List\&lt;SubscriberMethod\&gt; subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriberClass);---&gt;C，C~S都是这个函数的延伸，主要是两种方法来查找订阅者的方法</span><br><span class="line">	<span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">		<span class="keyword">for</span> (SubscriberMethod subscriberMethod : subscriberMethods) &#123;</span><br><span class="line">			<span class="comment">// 遍历订阅者的方法，然后执行subscribe---&gt;1A，重点就是处理subscriberMethod，其实不知道放进去在哪一步被执行...</span></span><br><span class="line">			subscribe(subscriber, subscriberMethod);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>1A.</strong><br><strong>1开头的，都是这个函数延伸出去的调用。</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 涉及到数据结构：private final Map&lt;Class&lt;?&gt;, CopyOnWriteArrayList&lt;Subscription&gt;&gt; subscriptionsByEventType;</span></span><br><span class="line"><span class="comment">/* Must be called in synchronized block*</span></span><br><span class="line"><span class="comment">*订阅者subscriber*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(Object subscriber, SubscriberMethod subscriberMethod)</span></span>&#123;</span><br><span class="line">	<span class="comment">//订阅者的方法要订阅的事件类</span></span><br><span class="line">	Class&lt;?&gt; eventType = subscriberMethod.eventType;</span><br><span class="line">	Subscription newSubscription = <span class="keyword">new</span> Subscription(subscriber,</span><br><span class="line">	subscriberMethod);---&gt;<span class="number">1</span>B,封装了这个订阅者和订阅者的响应函数以及是否订阅这三个信息</span><br><span class="line">	CopyOnWriteArrayList&lt;Subscription&gt; subscriptions =</span><br><span class="line">	subscriptionsByEventType.get(eventType); </span><br><span class="line">	<span class="comment">//根据eventType取出订阅这个情况的所有订阅情况</span></span><br><span class="line">	<span class="keyword">if</span> (subscriptions == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="comment">//如果这个event还从未被订阅，自然新建一个它所对应的subscription</span></span><br><span class="line">		subscriptions = <span class="keyword">new</span> CopyOnWriteArrayList&lt;&gt;();	</span><br><span class="line">		subscriptionsByEventType.put(eventType, subscriptions);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">//如果这个订阅关系已经存在， 抛出异常。Subscriber..already registered to event，和自己理解的一样~~~~ 开心</span></span><br><span class="line">		<span class="keyword">if</span> (subscriptions.contains(newSubscription)) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">"Subscriber "</span> + subscriber.getClass() +<span class="string">"already registered to event "</span>+ eventType);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 这个事件有多少个订阅方法（\@subscribe的方法或者onEvent..)</span></span><br><span class="line">	<span class="keyword">int</span> size = subscriptions.size();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= size; i++) &#123;</span><br><span class="line">		<span class="comment">// 如果当前这个订阅方法的优先级比当前这个订阅方法的优先级高，就把它加入到第i位（也就是倒数第二位），然后break。</span></span><br><span class="line">		<span class="comment">// 如果直接到了size，说明当前方法优先级最低，直接插入尾部。</span></span><br><span class="line">		<span class="keyword">if</span> (i == size || subscriberMethod.priority &gt; subscriptions.get(i).subscriberMethod.priority) &#123;</span><br><span class="line">			subscriptions.add(i, newSubscription);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//涉及到private final Map&lt;Object, List&lt;Class&lt;?&gt;&gt;&gt; typesBySubscriber;</span></span><br><span class="line">	<span class="comment">//查看这个订阅者要订阅的事件类型</span></span><br><span class="line">	List&lt;Class&lt;?&gt;&gt; subscribedEvents = typesBySubscriber.get(subscriber);</span><br><span class="line">	<span class="keyword">if</span> (subscribedEvents == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="comment">//原来这个subscriber没有订阅过事件，那么现在增加订阅者的 subscribedEvents(是一个list）</span></span><br><span class="line">		subscribedEvents = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		typesBySubscriber.put(subscriber, subscribedEvents);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//不管subscriber是否订阅过事件,都把这个事件类型加入到这个subscriber的订阅事件列表中</span></span><br><span class="line">	subscribedEvents.add(eventType);</span><br><span class="line">	<span class="comment">//如果这个响应函数是粘性的。 如果不是粘性的？？哪里涉及到线程去执行？</span></span><br><span class="line">	<span class="comment">//个人理解：</span></span><br><span class="line">	这是<span class="number">3.0</span>增加的新特性：从代码可以看出stickyEvents的entry，其实是一个map，map的key是事件类型（<span class="class"><span class="keyword">class</span>\&lt;?\&gt;），<span class="title">value</span>是事件实例(<span class="title">Object</span>),由于是粘性事件，那么，当这个<span class="title">subscriberMethod</span>订阅这个事件类型，就把最近的事件类型的事件（<span class="title">Object</span>)</span></span><br><span class="line"><span class="class">通过<span class="title">checkPostStickyEventToSubscription</span>立刻将这个事件找到对应的处理线程，进行排队（有可能排）后，由对应的<span class="title">subcriberMethod</span>进行处理。</span></span><br><span class="line"><span class="class">	<span class="title">if</span> (<span class="title">subscriberMethod</span>.<span class="title">sticky</span>) </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (eventInheritance) &#123;</span><br><span class="line">		<span class="comment">/* Existing sticky events of all subclasses of eventType have to be</span></span><br><span class="line"><span class="comment">		considered.这个事件类型的所有子类的粘性事件都要考虑</span></span><br><span class="line"><span class="comment">		Note: Iterating over all events may be inefficient with lots of sticky events, 如果粘性事件比较多，遍历所有的事件可能不够高效</span></span><br><span class="line"><span class="comment">		thus data structure should be changed to allow a more efficient lookup*应该更改数据结构，进行更高效的遍历  (e.g. an additional map storing sub classes of super classes: Class -&gt; List&lt;Class&gt;).*/</span></span><br><span class="line">			Set&lt;Map.Entry&lt;Class&lt;?&gt;, Object&gt;&gt; entries = stickyEvents.entrySet();</span><br><span class="line">		    <span class="comment">//取出保存粘性事件的set</span></span><br><span class="line">			<span class="keyword">for</span> (Map.Entry&lt;Class&lt;?&gt;, Object&gt; entry : entries) &#123;</span><br><span class="line">			<span class="comment">//遍历set中每个元素，取出每个元素的key，也就是事件类型class&lt;?&gt;</span></span><br><span class="line">				Class&lt;?&gt; candidateEventType = entry.getKey();</span><br><span class="line">				<span class="comment">//如果当前订阅方法监听的事件类型，是之前存在的事件的 父类</span></span><br><span class="line">				<span class="keyword">if</span> (eventType.isAssignableFrom(candidateEventType)) &#123;</span><br><span class="line">					<span class="comment">// 取出value,也就是这个事件类型的实例</span></span><br><span class="line">					Object stickyEvent = entry.getValue();</span><br><span class="line">					checkPostStickyEventToSubscription(newSubscription, stickyEvent);----&gt;<span class="number">1</span>C</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			Object stickyEvent = stickyEvents.get(eventType);</span><br><span class="line">			checkPostStickyEventToSubscription(newSubscription, stickyEvent);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>1C. 主要是调用了postToSubscription，选择了合适的线程，执行了post</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkPostStickyEventToSubscription</span><span class="params">(Subscription</span></span></span><br><span class="line"><span class="function"><span class="params">newSubscription, Object stickyEvent)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (stickyEvent != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="comment">/*If the subscriber is trying to abort the event, it will fail (event is not tracked in posting state) 如果订阅者想阻止这个事件，将会失败--&gt; Strange corner case, which we don't take care of here.奇怪的case，我们不用在意？？？ 这注释有点迷...*/</span></span><br><span class="line">		postToSubscription(newSubscription, stickyEvent, Looper.getMainLooper() == Looper.myLooper());---&gt;<span class="number">1</span>D,真正处理event的函数（终于涉及了线程），赞！</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>1D.根据订阅者方法的threadMode，决定这个方法由哪个线程执行。</strong></p>
<p><strong>由各个poster去处理pengdingPost，可能由handler执行，也可能是线程池去执行runnable</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postToSubscription</span><span class="params">(Subscription subscription, Object event,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">boolean</span> isMainThread)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">switch</span> (subscription.subscriberMethod.threadMode) &#123;</span><br><span class="line">		<span class="keyword">case</span> POSTING:</span><br><span class="line">			invokeSubscriber(subscription,event);---&gt;<span class="number">1</span>E，通过java反射机制，使用method.invoke()调用了subscirber对象中的参数为event订阅方法</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> MAIN:</span><br><span class="line">			<span class="keyword">if</span> (isMainThread) &#123;</span><br><span class="line">				<span class="comment">//如果当前就是主线程，那么就当前线程执行subscription.subscriberMethod</span></span><br><span class="line">				invokeSubscriber(subscription, event);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">//mainThreadPoster = new HandlerPoster(this, Looper.getMainLooper(), 10);有主线程的looper</span></span><br><span class="line">				mainThreadPoster.enqueue(subscription, event);----&gt;<span class="number">1F</span>，插入给主线程的handler，会将这个事件和方法放入queue，等待主线程执行，如果主线程的queue之前为空，那么就直接sendMsg。</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> BACKGROUND:</span><br><span class="line">			<span class="keyword">if</span> (isMainThread) &#123;</span><br><span class="line">				<span class="comment">//backgroundPoster = new BackgroundPoster(this);同理，这是后台线程的handler</span></span><br><span class="line">				backgroundPoster.enqueue(subscription, event);---&gt;<span class="number">1</span>I</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">//如果当前线程不是主线程，就直接用当前线程执行，invokeSubscriber是当前的eventBus中的函数</span></span><br><span class="line">				invokeSubscriber(subscription, event);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> ASYNC:</span><br><span class="line">			asyncPoster.enqueue(subscription, event);---&gt;<span class="number">1</span>J</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Unknown thread mode: "</span> + subscription.subscriberMethod.threadMode);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>1E.</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">invokeSubscriber</span><span class="params">(Subscription subscription, Object event)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">//method.invoke(Object obj, Object... args) 是反射机制的一个函数</span></span><br><span class="line">		<span class="comment">//对这个指定的对象obj，调用方法method，args是这个方法需要的参数数组。</span></span><br><span class="line">		<span class="comment">//也就是，调用subscriber这个对象的subscription.subscriberMethod.method方法，其中event是这个方法的参数...JAVA反射好厉害-</span></span><br><span class="line">		subscription.subscriberMethod.method.invoke(subscription.subscriber, event);</span><br><span class="line">	&#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">		handleSubscriberException(subscription, event, e.getCause());</span><br><span class="line">	&#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Unexpected exception"</span>, e);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>1K. 差点以为是1E…</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">invokeSubscriber</span><span class="params">(PendingPost pendingPost)</span> </span>&#123;</span><br><span class="line">	Object event = pendingPost.event; <span class="comment">//取出这个post对应的event obj</span></span><br><span class="line">	<span class="comment">//再取出对应的订阅信息</span></span><br><span class="line">	Subscription subscription = pendingPost.subscription;</span><br><span class="line">	PendingPost.releasePendingPost(pendingPost);----&gt;<span class="number">1L</span></span><br><span class="line">	<span class="keyword">if</span> (subscription.active) &#123;</span><br><span class="line">	<span class="comment">//这个变量注释就说是这里会用到，为了避免race conditions（资源竞争）</span></span><br><span class="line">		invokeSubscriber(subscription, event);---&gt;<span class="number">1</span>E</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>SubscriberMethodFinder.JAVA</strong></p>
<p><strong>C.</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">List&lt;SubscriberMethod&gt; <span class="title">findSubscriberMethods</span><span class="params">(Class&lt;?&gt; subscriberClass)</span></span>&#123;</span><br><span class="line">	<span class="comment">//先直接从缓存中取</span></span><br><span class="line">	List&lt;SubscriberMethod&gt; subscriberMethods = METHOD_CACHE.get(subscriberClass);</span><br><span class="line">	<span class="keyword">if</span> (subscriberMethods != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> subscriberMethods;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//如果没有的话，判断是否要忽略注解器：</span></span><br><span class="line">	<span class="keyword">if</span> (ignoreGeneratedIndex) &#123;</span><br><span class="line">		<span class="comment">//忽略的话，用反射来获取类的方法信息</span></span><br><span class="line">		subscriberMethods = findUsingReflection(subscriberClass);---&gt;D</span><br><span class="line">		<span class="comment">/*D~N，都是利用反射找方法的过程，主要是通过findState，把subscriberClass放进去，找到对应方法，再找它的父类，依次向上。总体来说findUsingReflection就是一个while循环遍历所有相关类，根据类找方法时需要用到反射和注解...*/</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		subscriberMethods = findUsingInfo(subscriberClass); ---&gt;O</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (subscriberMethods.isEmpty()) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">"Subscriber "</span> + subscriberClass + <span class="string">" and its super classes have no public methods with the \@Subscribe annotation"</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		METHOD_CACHE.put(subscriberClass, subscriberMethods);</span><br><span class="line">		<span class="keyword">return</span> subscriberMethods;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>P.</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> SubscriberInfo <span class="title">getSubscriberInfo</span><span class="params">(FindState findState)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 看描述subscriberInfo本来就一直为null啊... 是一个接口的变量</span></span><br><span class="line">	<span class="comment">// getSuperSubscriberInfo()是接口的一个函数，AbstractSubscriberInfo是接口实现</span></span><br><span class="line">	<span class="keyword">if</span> (findState.subscriberInfo != <span class="keyword">null</span> &amp;&amp; findState.subscriberInfo.getSuperSubscriberInfo() != <span class="keyword">null</span>) &#123; ----&gt;Q</span><br><span class="line">		<span class="comment">//如果订阅者信息不为空且订阅者信息子类不为空</span></span><br><span class="line">		SubscriberInfo superclassInfo = findState.subscriberInfo.getSuperSubscriberInfo();</span><br><span class="line">		<span class="comment">//如果findstate当前的clazz和订阅者子类一样，返回这个子类信息。</span></span><br><span class="line">		<span class="keyword">if</span> (findState.clazz == superclassInfo.getSubscriberClass()) &#123;</span><br><span class="line">			<span class="keyword">return</span> superclassInfo;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//如果订阅者信息下标不为空（是一个List),那么遍历List，通过index取出clazz的信息，并返回。</span></span><br><span class="line">	<span class="keyword">if</span> (subscriberInfoIndexes != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">for</span> (SubscriberInfoIndex index : subscriberInfoIndexes) &#123;</span><br><span class="line">			SubscriberInfo info = index.getSubscriberInfo(findState.clazz);</span><br><span class="line">			<span class="keyword">if</span> (info != <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">return</span> info;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>O.看看和DList<subscribermethod> findUsingReflection(Class&lt;?&gt;<br>subscriberClass)有什么不同</subscribermethod></strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> List&lt;SubscriberMethod&gt; <span class="title">findUsingInfo</span><span class="params">(Class&lt;?&gt; subscriberClass)</span> </span>&#123;</span><br><span class="line">	FindState findState = prepareFindState(); <span class="comment">// same</span></span><br><span class="line">	findState.initForSubscriber(subscriberClass); <span class="comment">// same</span></span><br><span class="line">	<span class="keyword">while</span> (findState.clazz != <span class="keyword">null</span>) &#123; <span class="comment">// same</span></span><br><span class="line">		findState.subscriberInfo =</span><br><span class="line">getSubscriberInfo(findState);---&gt;P,经过PQ，取到订阅者的信息</span><br><span class="line">		<span class="keyword">if</span> (findState.subscriberInfo != <span class="keyword">null</span>) &#123; <span class="comment">//订阅者信息不为空</span></span><br><span class="line">			SubscriberMethod[] array = findState.subscriberInfo.getSubscriberMethods();---&gt;R<span class="comment">//调用接口函数，根据方法信息构建方法，并返回</span></span><br><span class="line">		<span class="keyword">for</span> (SubscriberMethod subscriberMethod : array) &#123;</span><br><span class="line">		<span class="comment">// 遍历方法，但是否能将订阅者方法和要监听的事件类型添加到findState中</span></span><br><span class="line">			<span class="keyword">if</span> (findState.checkAdd(subscriberMethod.method, subscriberMethod.eventType)) &#123;</span><br><span class="line">			<span class="comment">// 将这个方法加入到findState的list中去</span></span><br><span class="line">				findState.subscriberMethods.add(subscriberMethod);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="comment">//订阅者信息为空，那就通过这个方法，用反射得到findState.clazz的相关信息，并构造订阅方法（new SubscriberMethod（....)），add进findState中</span></span><br><span class="line">		findUsingReflectionInSingleClass(findState);</span><br><span class="line">	&#125;</span><br><span class="line">	findState.moveToSuperclass(); <span class="comment">//继续往上找</span></span><br><span class="line">&#125;</span><br><span class="line">	<span class="keyword">return</span> getMethodsAndRelease(findState); <span class="comment">//释放这个findState</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">D.</span><br><span class="line"><span class="function"><span class="keyword">private</span> List&lt;SubscriberMethod&gt; <span class="title">findUsingReflection</span><span class="params">(Class&lt;?&gt;</span></span></span><br><span class="line"><span class="function"><span class="params">subscriberClass)</span> </span>&#123;</span><br><span class="line">	FindState findState = prepareFindState();----&gt;E,得到一个FindState</span><br><span class="line">	findState.initForSubscriber(subscriberClass);---&gt;F,为这个findstate赋值它记在的订阅类，也就是subscriberClass，这是起点，此时findState中的clazz就是它</span><br><span class="line">	<span class="keyword">while</span> (findState.clazz != <span class="keyword">null</span>) &#123;</span><br><span class="line">		findUsingReflectionInSingleClass(findState);----&gt;G</span><br><span class="line">	<span class="comment">/*G到K，终于把subscriberClass里面的订阅方法加入到相应的findState了</span></span><br><span class="line"><span class="comment">	findState.moveToSuperclass();---&gt;L,把findState的clazz换成clazz的父类（超类不能为系统类）</span></span><br><span class="line"><span class="comment">	注意这是一个while循环，所以是从子类开始一直向上，把相应clazz的方法加入到findState*/</span></span><br><span class="line">&#125;</span><br><span class="line">	<span class="keyword">return</span> getMethodsAndRelease(findState);-----&gt;M，释放findstate,<span class="keyword">while</span>循环结束它就功成身退了，把它还给statePool</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>E.从findStatePool中取出第一个不为空的state，取出后把池中这个位置的state置为空。<br>有可能池为空，那么直接new一个FindState();</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> FindState <span class="title">prepareFindState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">synchronized</span> (FIND_STATE_POOL) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; POOL_SIZE; i++) &#123;	</span><br><span class="line">			FindState state = FIND_STATE_POOL[i];</span><br><span class="line">			<span class="keyword">if</span> (state != <span class="keyword">null</span>) &#123;</span><br><span class="line">				FIND_STATE_POOL[i] = <span class="keyword">null</span>;</span><br><span class="line">				<span class="keyword">return</span> state;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> FindState();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>G.利用反射原理取出当前findState中的订阅类的方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">findUsingReflectionInSingleClass</span><span class="params">(FindState findState)</span> </span>&#123;</span><br><span class="line">	Method[] methods;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">	<span class="comment">// This is faster than getMethods, especially when subscribers are fat classes</span></span><br><span class="line">	like Activities</span><br><span class="line">	<span class="comment">/*getMethods()返回某个类的所有公用（public）方法包括其继承类的公用方法，当然也包括它所实现接口的方法。getDeclaredMethods()对象表示的类或接口声明的所有方法，包括公共、保护、默认（包）访问和私有方法，但不包括继承的方法。当然也包括它所实现接口的方法。*/</span></span><br><span class="line">	methods = findState.clazz.getDeclaredMethods();</span><br><span class="line">	&#125; <span class="keyword">catch</span> (Throwable th) &#123;</span><br><span class="line">	<span class="comment">/* Workaround for java.lang.NoClassDefFoundError, see</span></span><br><span class="line"><span class="comment">	https://github.com/greenrobot/EventBus/issues/149*</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">		methods = findState.clazz.getMethods();</span><br><span class="line">		findState.skipSuperClasses = <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">	<span class="comment">//返回类或接口的以整数编码的JAVA语言修饰符，比如得到整数i=1，那么Modefier.toString(i)可以得到String的public</span></span><br><span class="line">	<span class="keyword">int</span> modifiers = method.getModifiers();</span><br><span class="line">	<span class="comment">//如果是public，不是abstract,不是static，不是BRIDGE,不是SYNTHETIC？</span></span><br><span class="line">	<span class="keyword">if</span> ((modifiers &amp; Modifier.PUBLIC) != <span class="number">0</span> &amp;&amp; (modifiers &amp; MODIFIERS_IGNORE)</span><br><span class="line">== <span class="number">0</span>)&#123;</span><br><span class="line">	<span class="comment">//获得方法的各参数的类型数组，不管类型是否一样，都算1，比如 int string</span></span><br><span class="line">	<span class="keyword">int</span>，那么共<span class="number">3</span>个</span><br><span class="line">	Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();</span><br><span class="line">	<span class="comment">// 3.0开始，不是onEvent..开头的方法，也可以作为响应函数了</span></span><br><span class="line">	<span class="comment">// 但是必须只有一个参数（也就是监听的事件event这个参数</span></span><br><span class="line">	<span class="keyword">if</span> (parameterTypes.length == <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="comment">//获得Subscribe.class的注解，这个注解标签（定义的名称）是Subscribe。</span></span><br><span class="line">		<span class="comment">// 有@Subscribe 注解的，都是响应函数，也就是不仅能用onEvent..这四个函数了</span></span><br><span class="line">		Subscribe subscribeAnnotation = method.getAnnotation(Subscribe.class);</span><br><span class="line">		<span class="keyword">if</span> (subscribeAnnotation != <span class="keyword">null</span>) &#123; <span class="comment">// 如果\@Subscribe不为空</span></span><br><span class="line">			Class&lt;?&gt; eventType = parameterTypes[<span class="number">0</span>]; <span class="comment">//取出参数对应的类</span></span><br><span class="line">			<span class="keyword">if</span> (findState.checkAdd(method, eventType)) &#123;-----&gt;H，一系列检查看是否能为这个事件类型添加对应的方法</span><br><span class="line">				ThreadMode threadMode = subscribeAnnotation.threadMode();---&gt;</span><br><span class="line">			findState.subscriberMethods.add(<span class="keyword">new</span> SubscriberMethod(method, eventType,</span><br><span class="line">threadMode,subscribeAnnotation.priority(), subscribeAnnotation.sticky()));</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="comment">//把这个订阅方法以及相关的事件类型、响应模式等封装后，加入到findState保存的订阅者方法的list中去，这是newSubscriberMethod的起点，顺便去看看这个类</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (strictMethodVerification &amp;&amp; method.isAnnotationPresent(Subscribe.class)) &#123;</span><br><span class="line">			<span class="comment">// 如果不止一个参数类型并且.....</span></span><br><span class="line">			<span class="comment">// 获取这个方法的所在的类名，以及方法名</span></span><br><span class="line">			String methodName = method.getDeclaringClass().getName() + <span class="string">"."</span> +</span><br><span class="line">		method.getName();</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">"\@Subscribe method "</span> + methodName +</span><br><span class="line">			<span class="string">"must have exactly 1 parameter but has "</span> + parameterTypes.length);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (strictMethodVerification &amp;&amp;</span><br><span class="line">		method.isAnnotationPresent(Subscribe.class)) &#123; </span><br><span class="line">			<span class="comment">//这个elseif对应的是最外层那个public &amp;&amp; 非abstract ....</span></span><br><span class="line">			String methodName = method.getDeclaringClass().getName() + <span class="string">"."</span> + method.getName();</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(methodName + <span class="string">" is a illegal \@Subscribe method: must be public, non-static, and non-abstract"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>M.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> List&lt;SubscriberMethod&gt; <span class="title">getMethodsAndRelease</span><span class="params">(FindState findState)</span></span>&#123;</span><br><span class="line">	<span class="comment">//把findState里面的subscriberMethods列表复制过来</span></span><br><span class="line">	List&lt;SubscriberMethod&gt; subscriberMethods = <span class="keyword">new</span></span><br><span class="line">	ArrayList&lt;&gt;(findState.subscriberMethods);</span><br><span class="line">	findState.recycle(); ---&gt;N ,就是把findState的各个成员变量清空。</span><br><span class="line">	<span class="keyword">synchronized</span> (FIND_STATE_POOL) &#123;</span><br><span class="line">		<span class="comment">// 从前开始遍历，把这个findstate还给这个pool</span></span><br><span class="line">		<span class="comment">// 之前取的时候，把[i]位置置为了null，所以这里还回去时候找值为null的=</span></span><br><span class="line">		<span class="comment">// 这思路真是简单易懂- -</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; POOL_SIZE; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (FIND_STATE_POOL[i] == <span class="keyword">null</span>) &#123;</span><br><span class="line">				FIND_STATE_POOL[i] = findState;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> subscriberMethods;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>SubscriberMethodFinder.java中的一个静态内部类：<br>static class FindState {}<br>成员变量：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//subscriber的订阅方法</span></span><br><span class="line"><span class="keyword">final</span> List&lt;SubscriberMethod&gt; subscriberMethods = <span class="keyword">new</span></span><br><span class="line">ArrayList&lt;&gt;();</span><br><span class="line"><span class="comment">//订阅方法的事件类型</span></span><br><span class="line"><span class="keyword">final</span> Map&lt;Class, Object&gt; anyMethodByEventType = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="keyword">final</span> Map&lt;String, Class&gt; subscriberClassByMethodKey = <span class="keyword">new</span></span><br><span class="line">HashMap&lt;&gt;();</span><br><span class="line"><span class="keyword">final</span> StringBuilder methodKeyBuilder = <span class="keyword">new</span> StringBuilder(<span class="number">128</span>);</span><br><span class="line">Class&lt;?&gt; subscriberClass;</span><br><span class="line">Class&lt;?&gt; clazz;</span><br><span class="line"><span class="keyword">boolean</span> skipSuperClasses;</span><br><span class="line">SubscriberInfo subscriberInfo;</span><br><span class="line"><span class="comment">//主要保存了订阅类的所有订阅方法信息.</span></span><br></pre></td></tr></table></figure></p>
<p><strong>N.</strong><br><strong><em>集合类用clear()，builder用setLength(0),对象实例用null。</em></strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">recycle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	subscriberMethods.clear();</span><br><span class="line">	anyMethodByEventType.clear();</span><br><span class="line">	subscriberClassByMethodKey.clear();</span><br><span class="line">	methodKeyBuilder.setLength(<span class="number">0</span>);</span><br><span class="line">	subscriberClass = <span class="keyword">null</span>;</span><br><span class="line">	clazz = <span class="keyword">null</span>;</span><br><span class="line">	skipSuperClasses = <span class="keyword">false</span>;</span><br><span class="line">	subscriberInfo = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>F</strong>.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initForSubscriber</span><span class="params">(Class&lt;?&gt; subscriberClass)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.subscriberClass = clazz = subscriberClass;</span><br><span class="line">	skipSuperClasses = <span class="keyword">false</span>;</span><br><span class="line">	subscriberInfo = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>H</strong>.<br><strong>检查是否添加这个方法，</strong>checkAddWithMethodSignature这个方法有点迷惑…记得回来看</p>
<p>两层检查，第一层检查事件类型，第二层检查签名（方法名称+参数类型）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">checkAdd</span><span class="params">(Method method, Class&lt;?&gt; eventType)</span> </span>&#123;</span><br><span class="line">	<span class="comment">/* 2 level check: 1st level with event type only (fast), 2nd level with</span></span><br><span class="line"><span class="comment">	complete signature when required.</span></span><br><span class="line"><span class="comment">	Usually a subscriber doesn't have methods listening to the same event type.*/</span></span><br><span class="line">	<span class="comment">// map的put方法，如果之前Key没有对应的value，那么返回null，否则返回之前对应的值</span></span><br><span class="line">	Object existing = anyMethodByEventType.put(eventType, method);</span><br><span class="line">	<span class="keyword">if</span> (existing == <span class="keyword">null</span>) &#123;</span><br><span class="line">	<span class="comment">//说明之前这个key没有对应值，那么这个类型可以对应这个方法</span></span><br><span class="line">	<span class="comment">//也就是这个事件只有当前这种方法订阅了</span></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="comment">// 如果之前订阅这个事件A的method和当前想订阅事件A的method类型一样</span></span><br><span class="line">		<span class="keyword">if</span> (existing <span class="keyword">instanceof</span> Method) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!checkAddWithMethodSignature((Method) existing, eventType))-----&gt;I&#123; <span class="comment">// 如果之前的classOld是现在methodClass的子类，那么抛出异常</span></span><br><span class="line">				<span class="comment">// Paranoia check</span></span><br><span class="line">				<span class="comment">// 也就是之前存在的classOld是当前方法的子类时，不用重新订阅，需要遵循子类覆写。</span></span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// Put any non-Method object to "consume" the existing Method</span></span><br><span class="line">			<span class="comment">//没有出现父类想和子类抢同一个事件的异常，那么这个事件类型的订阅者就是this</span></span><br><span class="line">			anyMethodByEventType.put(eventType, <span class="keyword">this</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> checkAddWithMethodSignature(method, eventType);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>I.方法签名的检查</strong></p>
<p>这是一个优化，如果现在保存的是旧的子类，那么保存新的，返回true<br>否则没必要保存，直接保存旧的那个父类就行了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">checkAddWithMethodSignature</span><span class="params">(Method method, Class&lt;?&gt; eventType)</span> </span>&#123;</span><br><span class="line">	methodKeyBuilder.setLength(<span class="number">0</span>);</span><br><span class="line">	methodKeyBuilder.append(method.getName()); <span class="comment">//方法名</span></span><br><span class="line">	methodKeyBuilder.append(<span class="string">'&gt;'</span>).append(eventType.getName());</span><br><span class="line">	<span class="comment">// 类名即事件类型名称</span></span><br><span class="line">	<span class="comment">// 用这两个值当做key</span></span><br><span class="line">	String methodKey = methodKeyBuilder.toString();</span><br><span class="line">	<span class="comment">// 得到这个方法所对应的类对象</span></span><br><span class="line">	Class&lt;?&gt; methodClass = method.getDeclaringClass();</span><br><span class="line">	Class&lt;?&gt; methodClassOld = subscriberClassByMethodKey.put(methodKey, methodClass);</span><br><span class="line">	<span class="comment">//methodClassOld为空，或者是父类</span></span><br><span class="line">	<span class="comment">//methodClassOld为空时：说明这个方法签名（methodKey=方法名+事件类型)之前没有彼此对应。那么允许为这个方法添加订阅事件，返回true</span></span><br><span class="line">	<span class="keyword">if</span> (methodClassOld == <span class="keyword">null</span> ||</span><br><span class="line">	methodClassOld.isAssignableFrom(methodClass)) &#123;</span><br><span class="line">		<span class="comment">//这个函数，Class.isAssignableFrom()是用来判断一个类Class1是否Class2的superClass或者superInterface，或者是相同类或者接口。</span></span><br><span class="line">		格式为： Class1.isAssignableFrom(Class2)</span><br><span class="line">		这是判断类之间的关系，<span class="keyword">instanceof</span>是判断实例之间的关系</span><br><span class="line">		<span class="comment">// Only add if not already found in a sub class</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// Revert the put, old class is further down the class hierarchy</span></span><br><span class="line">		<span class="comment">/*methodClassOld不为空，并且它是新的methodClass的子类，把methodClassOld放回去并且返回false，**代表子类classOld覆写了父类的订阅方法，让子类method的订阅方法订阅这个事件而不是父类。*/</span></span><br><span class="line">		subscriberClassByMethodKey.put(methodKey,methodClassOld);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>L.</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">moveToSuperclass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (skipSuperClasses) &#123;</span><br><span class="line">		clazz = <span class="keyword">null</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		clazz = clazz.getSuperclass();</span><br><span class="line">		String clazzName = clazz.getName();</span><br><span class="line">		<span class="comment">/* Skip system classes, this just degrades performance. */</span></span><br><span class="line">		<span class="comment">//跳过系统类，也就是以java, javax,android开头的类</span></span><br><span class="line">		<span class="keyword">if</span> (clazzName.startsWith(<span class="string">"java."</span>) ||clazzName.startsWith(<span class="string">"javax."</span>) || clazzName.startsWith(<span class="string">"android."</span>)) &#123;</span><br><span class="line">			clazz = <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>③注解类\@Subscribe</strong></p>
<p><strong>J.</strong></p>
<p>终于遇到注解了！！看别人的分析，注解中应该还有<br>String[] actions() default {};  </p>
<p>这个版本好像没有了！！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.*RUNTIME*)</span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.*METHOD*&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Subscribe &#123;</span><br><span class="line">	<span class="function">ThreadMode <span class="title">threadMode</span><span class="params">()</span> <span class="keyword">default</span></span></span><br><span class="line"><span class="function">	ThreadMode.POSTING</span>;---&gt;K</span><br><span class="line">	<span class="comment">/*如果是真，如果有订阅者在这个sticky事件发布后才订阅这个事件，那么依然会把最近的这个事件类型的sticky事件发送给这个subscriber*/</span></span><br><span class="line">	<span class="comment">/* If true, delivers the most recent sticky event (posted with &#123;\@link EventBus #postSticky(Object)&#125;) to this subscriber (if event available).*/</span></span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">sticky</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line">	<span class="comment">/* 对于同一个传送线程，优先级高的订阅者更快地接收到事件</span></span><br><span class="line"><span class="comment">	Subscriber priority to influence the order of event delivery.*/</span></span><br><span class="line">	<span class="comment">/* Within the same delivery thread (&#123;\@link ThreadMode&#125;), higher priority subscribers will receive events before*/</span> others with a lower priority. The <span class="keyword">default</span> priority is <span class="number">0</span>. Note: the priority</span><br><span class="line">	does \*NOT\* affect the order of delivery among subscribers with different &#123;\<span class="meta">@link</span> ThreadMode&#125;s! */</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">priority</span><span class="params">()</span> <span class="keyword">default</span> 0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>K.</strong><br>public enum ThreadMode{}<br>枚举类型，共四种：<br><em>POSTING</em>：订阅者的响应函数直接由发起post事件的线程执行，如果发起post的是主线程，那么响应函数不应该是耗时操作。如果要执行的task耗时很短，建议使用这种模式。<br><em>MAIN</em>: 订阅者的响应函数由主线程执行。如果posting<br>thread是主线程，事件响应函数将会直接被这个线程call。<br><em>BACKGROUND</em>：订阅者的响应函数由后台线程执行，如果posting<br>thread不是主线程，事件响应函数将会直接被这个线程call。如果posting<br>thread是主线程，那么eventBus将会使用一个单独的single后台线程，这个线程会按序执行这些响应函数。但还是不建议有很耗时的操作，以避免阻塞这个后台线程。<br><em>ASYNC：</em><br>订阅者的响应函数由一个独立的线程去执行，这个线程不是主线程，也不是posting<br>thread。如果有比较耗时的操作，建议用这种模式，比如网络访问。EventBus使用了线程池来重用线程进行异步操作。</p>
<p><strong>SubscriberMethod.JAVA</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubscriberMethod</span> </span>&#123;</span><br><span class="line">	<span class="keyword">final</span> Method method;</span><br><span class="line">	<span class="keyword">final</span> ThreadMode threadMode;</span><br><span class="line">	<span class="keyword">final</span> Class&lt;?&gt; eventType;</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">int</span> priority;</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">boolean</span> sticky;</span><br><span class="line">	<span class="comment">/* Used for efficient comparison */</span></span><br><span class="line">	String methodString;</span><br><span class="line">....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>构造函数就是对前五个变量进行赋值，很好理解。</p>
<p><strong>AbstractSubscriberInfo.JAVA，实现SubscriberInfo接口</strong><br>public abstract class AbstractSubscriberInfo implements SubscriberInfo<br>{}<br>private final Class subscriberClass;<br>private final Class&lt;? extends SubscriberInfo&gt;<br>superSubscriberInfoClass;<br>private final boolean shouldCheckSuperclass;<br>主要是三个成员变量：<br>订阅者对应的类；订阅者信息的子类（这是什么鬼…); 检查超类的布尔变量</p>
<p><strong>P.</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SubscriberInfo <span class="title">getSuperSubscriberInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 如果没有信息子类，直接返回Null</span></span><br><span class="line">	<span class="keyword">if</span>(superSubscriberInfoClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> superSubscriberInfoClass.newInstance();</span><br><span class="line">	&#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">	&#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>S.</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">simpleSubscriberInfo中的getSubscriberMethods()会调用该函数：</span><br><span class="line"><span class="function"><span class="keyword">protected</span> SubscriberMethod <span class="title">createSubscriberMethod</span><span class="params">(String methodName, Class&lt;?&gt; eventType, ThreadMode threadMode,<span class="keyword">int</span> priority, <span class="keyword">boolean</span> sticky)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		Method method = subscriberClass.getDeclaredMethod(methodName, eventType);</span><br><span class="line">		<span class="comment">//通过方法名称，和方法参数列表（其实就是方法签名）从class中找到类</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> SubscriberMethod(method, eventType, threadMode, priority, sticky); <span class="comment">//然后构造subscriber方法，似乎比第一种通过反射的方式简单</span></span><br><span class="line">	&#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(**<span class="string">"Could not find subscriber method in "</span> + subscriberClass + <span class="string">". Maybe a missing ProGuard rule?"</span>, e);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>**⑥SimpleSubscriberInfo.JAVA<br>又继承了AbstractSubscriberInfo（就不能一次写完吗…)<br>一个成员变量：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> SubscriberMethodInfo[] methodInfos;</span><br><span class="line"><span class="comment">// 存储了订阅者所有的方法信息，用数组保存。</span></span><br></pre></td></tr></table></figure></p>
<p><strong>R.</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> SubscriberMethod[] getSubscriberMethods() &#123;</span><br><span class="line">	<span class="keyword">int</span> length = methodInfos.length;</span><br><span class="line">	<span class="comment">//建立一个方法数组（不是方法信息）</span></span><br><span class="line">	SubscriberMethod[] methods = <span class="keyword">new</span> SubscriberMethod[length];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">		<span class="comment">//取出方法信息	</span></span><br><span class="line">		SubscriberMethodInfo info = methodInfos[i];</span><br><span class="line">		<span class="comment">//根据信息建立方法（调用父类的createSubscriberMethod）</span></span><br><span class="line">		methods[i] = createSubscriberMethod(info.methodName, info.eventType, info.threadMode, info.priority, info.sticky);----&gt;S</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> methods; <span class="comment">//根据信息构造了方法数组，返回去。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>⑦Subscription.JAVA</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Subscription</span> </span>&#123;&#125;</span><br><span class="line"><span class="comment">//三个成员变量：</span></span><br><span class="line"><span class="keyword">final</span> Object subscriber; <span class="comment">//注册的订阅者</span></span><br><span class="line"><span class="keyword">final</span> SubscriberMethod subscriberMethod; <span class="comment">//订阅者响应事件的函数</span></span><br><span class="line"><span class="comment">/*Becomes false as soon as &#123;@link EventBus#unregister(Object)&#125; is called, which is checked by queued event delivery &#123;@link EventBus#invokeSubscriber(PendingPost)&#125; to prevent race conditions.*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">boolean</span> active; <span class="comment">// unrigester之后为false</span></span><br></pre></td></tr></table></figure></p>
<p><strong>1B.</strong></p>
<p>构造函数就是为这三个变量赋值：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Subscription(Object subscriber, SubscriberMethod subscriberMethod)&#123;</span><br><span class="line">	<span class="keyword">this</span>.subscriber = subscriber;</span><br><span class="line">	<span class="keyword">this</span>.subscriberMethod = subscriberMethod;</span><br><span class="line">	active = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>⑧HandlerPoster.JAVA</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HandlerPoster</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;&#125;</span><br><span class="line">	<span class="comment">//四个成员变量：</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> PendingPostQueue queue;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> maxMillisInsideHandleMessage;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> EventBus eventBus;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">boolean</span> handlerActive;</span><br></pre></td></tr></table></figure>
<p><strong>1F.</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Subscription subscription, Object event)</span> </span>&#123;</span><br><span class="line">	PendingPost pendingPost = PendingPost.obtainPendingPost(subscription, event);---&gt; <span class="number">1</span>G,根据订阅信息和event取出pendingPost，</span><br><span class="line">		<span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">			queue.enqueue(pendingPost); <span class="comment">//插入等待队列</span></span><br><span class="line">			<span class="keyword">if</span> (!handlerActive) &#123;</span><br><span class="line">			<span class="comment">//如果handler不活跃，就打开它（可能之前没有msg给handler处理）直接发送消息进行处理</span></span><br><span class="line">				handlerActive = <span class="keyword">true</span>;</span><br><span class="line">			<span class="keyword">if</span> (!sendMessage(obtainMessage())) &#123; </span><br><span class="line">			<span class="comment">//handler发送msg出去----&gt;1H</span></span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(**<span class="string">"Could not send handler message"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>1H.消息处理函数</strong>，但是handleMessage有三个级别,handler的是最不优先的- -</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">boolean</span> rescheduled = <span class="keyword">false</span>;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="keyword">long</span> started = SystemClock.uptimeMillis();</span><br><span class="line">		<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">			PendingPost pendingPost = queue.poll();</span><br><span class="line">			<span class="comment">//移出并返回队头，如果queue是空的，就返回null，不会抛异常</span></span><br><span class="line">			<span class="keyword">if</span> (pendingPost == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="comment">//如果队列为空</span></span><br><span class="line">				<span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123; <span class="comment">//锁住当前handler</span></span><br><span class="line">				<span class="comment">// Check again, this time in synchronized*</span></span><br><span class="line">					pendingPost = queue.poll(); <span class="comment">//再取？</span></span><br><span class="line">					<span class="keyword">if</span> (pendingPost == <span class="keyword">null</span>) &#123;</span><br><span class="line">					<span class="comment">//还是空，那么这个handler没事干了</span></span><br><span class="line">						handlerActive = <span class="keyword">false</span>;</span><br><span class="line">						<span class="keyword">return</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="comment">//又调用eventBus的invokeSubscriber函数，1E已经分析了。利用反射调用订阅方法。</span></span><br><span class="line">		eventBus.invokeSubscriber(pendingPost);----&gt;不是<span class="number">1</span>E！参数不同！<span class="number">1</span>K,不过最终还是可能调用<span class="number">1</span>E</span><br><span class="line">		<span class="keyword">long</span> timeInMethod = SystemClock.uptimeMillis() - started;</span><br><span class="line">		<span class="comment">//如果执行method的时间大于了handleMsg规定的时间</span></span><br><span class="line">		<span class="keyword">if</span> (timeInMethod &gt;= maxMillisInsideHandleMessage) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!sendMessage(obtainMessage())) &#123; <span class="comment">//又发送出去执行？？</span></span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">"Could not send handler message"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			rescheduled = <span class="keyword">true</span>;<span class="comment">// 重新调度了</span></span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">	handlerActive = rescheduled; <span class="comment">//如果发生了重新调度，handlerActive为真</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>⑨PendingPost.JAVA</strong></p>
<p>四个成员变量：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> List&lt;PendingPost&gt; pendingPostPool = <span class="keyword">new</span></span><br><span class="line">ArrayList&lt;PendingPost&gt;();</span><br><span class="line">Object event;</span><br><span class="line">Subscription subscription;</span><br><span class="line">PendingPost next;</span><br></pre></td></tr></table></figure></p>
<p>一个构造函数：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">PendingPost</span><span class="params">(Object event, Subscription subscription)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.event = event;</span><br><span class="line">	<span class="keyword">this</span>.subscription = subscription;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>1G.</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> PendingPost <span class="title">obtainPendingPost</span><span class="params">(Subscription subscription, Object event)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">synchronized</span> (pendingPostPool) &#123;</span><br><span class="line">		<span class="keyword">int</span> size = pendingPostPool.size();</span><br><span class="line">		<span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="comment">//取出postPool中最后一个pendingPost</span></span><br><span class="line">			PendingPost pendingPost = pendingPostPool.remove(size - <span class="number">1</span>);</span><br><span class="line">			pendingPost.event = event;</span><br><span class="line">			pendingPost.subscription = subscription;</span><br><span class="line">			pendingPost.next = <span class="keyword">null</span>;</span><br><span class="line">			<span class="keyword">return</span> pendingPost;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//如果pengdingPostPool为空，直接用事件和订阅信息new一个新的pendingPost</span></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> PendingPost(event, subscription);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>1L.</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">releasePendingPost</span><span class="params">(PendingPost pendingPost)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//将pendingPost的各变量置为null</span></span><br><span class="line">	pendingPost.event = <span class="keyword">null</span>;</span><br><span class="line">	pendingPost.subscription = <span class="keyword">null</span>;</span><br><span class="line">	pendingPost.next = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">synchronized</span> (pendingPostPool) &#123;</span><br><span class="line">		<span class="comment">/*锁住postPool，把这个pendingPost放进去= =话说，为什么不直接pendingPost=null...恩，如果里面的这三个变量不为null，那么应该无法回收，但是也可以先把变量置为null,再把pendingPost=null</span></span><br><span class="line"><span class="comment">		但是这里直接把变量置为null然后重用？ 所以这是传说中的对象池...恩</span></span><br><span class="line"><span class="comment">		// Don't let the pool grow indefinitely</span></span><br><span class="line"><span class="comment">		if (pendingPostPool.size() &lt; 10000) &#123;</span></span><br><span class="line"><span class="comment">			pendingPostPool.add(pendingPost);</span></span><br><span class="line"><span class="comment">		&#125;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br></pre></td></tr></table></figure>
<p><strong>⑩BackgroundPoster.java</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">BackgroundPoster</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;&#125;</span><br><span class="line"><span class="comment">//是一个线程,三个成员变量：</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> PendingPostQueue queue; <span class="comment">//等到这个线程处理的事件队列</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> EventBus eventBus;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> executorRunning;</span><br></pre></td></tr></table></figure>
<p>构造函数：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BackgroundPoster(EventBus eventBus) &#123;</span><br><span class="line">	<span class="keyword">this</span>.eventBus = eventBus;</span><br><span class="line">	queue = <span class="keyword">new</span> PendingPostQueue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>持有了eventBus的引用，也许有内存泄漏？</p>
<p><strong>1I.</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Subscription subscription, Object event)</span> </span>&#123;</span><br><span class="line">PendingPost pendingPost = PendingPost.obtainPendingPost(subscription, event);</span><br><span class="line"><span class="comment">//根据subscription和要发布的事件构造pendingPost</span></span><br><span class="line">	<span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">		queue.enqueue(pendingPost); <span class="comment">//入队</span></span><br><span class="line">		<span class="keyword">if</span> (!executorRunning) &#123; <span class="comment">//这个runnable此时没有在执行</span></span><br><span class="line">			executorRunning = <span class="keyword">true</span>;<span class="comment">//那么可以利用起来了</span></span><br><span class="line">			<span class="comment">//eventBus的线程池执行当前runnable</span></span><br><span class="line">			eventBus.getExecutorService().execute(**<span class="keyword">this</span>**);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>⑪AsyncPoster.JAVA</strong></p>
<p>三个成员变量：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> PendingPostQueue queue;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> EventBus eventBus;</span><br></pre></td></tr></table></figure></p>
<p>构造函数：持有了eventBus的引用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">AsyncPoster(EventBus eventBus) &#123;</span><br><span class="line">	<span class="keyword">this</span>.eventBus = eventBus;</span><br><span class="line">	queue = <span class="keyword">new</span> PendingPostQueue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>1J.</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造了pendingPost后直接进入队列，执行让eventBus的线程池执行它= =</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Subscription subscription, Object event)</span> </span>&#123;</span><br><span class="line">	PendingPost pendingPost = PendingPost.obtainPendingPost(subscription, event);</span><br><span class="line">	queue.enqueue(pendingPost);</span><br><span class="line">	eventBus.getExecutorService().execute(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//从队列里面取出pendingPost</span></span><br><span class="line">	PendingPost pendingPost = queue.poll();</span><br><span class="line">	<span class="keyword">if</span>(pendingPost == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"No pending post available"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*1E分析过，反射机制执行subscription里面的method（打脸，这不是1E</span></span><br><span class="line"><span class="comment">	eventBus.invokeSubscriber(pendingPost);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/07/SparseArray/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ke Yu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coco">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/07/SparseArray/" itemprop="url">SparseArray源码解析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-09-07T20:31:14+08:00">
                2017-09-07
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Creates a new SparseArray containing no mappings that will not</span><br><span class="line"> * require any additional memory allocation to store the specified</span><br><span class="line"> * number of mappings.  If you supply an initial capacity of 0, the</span><br><span class="line"> * sparse array will be initialized with a light-weight representation</span><br><span class="line"> * not requiring any additional array allocations.</span><br><span class="line"> */</span><br><span class="line">public SparseArray(int initialCapacity) &#123;</span><br><span class="line">    if (initialCapacity == 0) &#123;</span><br><span class="line">        mKeys = EmptyArray.INT;</span><br><span class="line">        mValues = EmptyArray.OBJECT;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        mValues = ArrayUtils.newUnpaddedObjectArray(initialCapacity);</span><br><span class="line">        mKeys = new int[mValues.length];</span><br><span class="line">    &#125;</span><br><span class="line">    mSize = 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>查找</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public E get(int key) &#123;</span><br><span class="line">    return get(key, null);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Gets the Object mapped from the specified key, or the specified Object</span><br><span class="line"> * if no such mapping has been made.</span><br><span class="line"> */</span><br><span class="line">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">public E get(int key, E valueIfKeyNotFound) &#123;</span><br><span class="line">    int i = ContainerHelpers.binarySearch(mKeys, mSize, key);</span><br><span class="line"></span><br><span class="line">    if (i &lt; 0 || mValues[i] == DELETED) &#123;</span><br><span class="line">        return valueIfKeyNotFound;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return (E) mValues[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>插入</li>
</ul>
<p>插入时，参数既要有key又要有value。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">/**  put插入</span><br><span class="line">     * Adds a mapping from the specified key to the specified value,</span><br><span class="line">     * replacing the previous mapping from the specified key if there</span><br><span class="line">     * was one.</span><br><span class="line">     */</span><br><span class="line">    public void put(int key, E value) &#123;</span><br><span class="line">        int i = ContainerHelpers.binarySearch(mKeys, mSize, key);</span><br><span class="line"></span><br><span class="line">        if (i &gt;= 0) &#123;</span><br><span class="line">            mValues[i] = value;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            i = ~i;</span><br><span class="line">            // 空间已经有了,但是被删除了，那么重新赋值</span><br><span class="line">            if (i &lt; mSize &amp;&amp; mValues[i] == DELETED) &#123;</span><br><span class="line">                mKeys[i] = key;</span><br><span class="line">                mValues[i] = value;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            // 空间超出，先gc一下</span><br><span class="line">            if (mGarbage &amp;&amp; mSize &gt;= mKeys.length) &#123;</span><br><span class="line">                gc();</span><br><span class="line"></span><br><span class="line">                // Search again because indices may have changed.</span><br><span class="line">                i = ~ContainerHelpers.binarySearch(mKeys, mSize, key);</span><br><span class="line">            &#125;</span><br><span class="line">            // 扩展数组</span><br><span class="line">            mKeys = GrowingArrayUtils.insert(mKeys, mSize, i, key);</span><br><span class="line">            mValues = GrowingArrayUtils.insert(mValues, mSize, i, value);</span><br><span class="line">            mSize++; // SparseArray大小增加</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**  append插入</span></span><br><span class="line"><span class="comment">     * Puts a key/value pair into the array, optimizing for the case where</span></span><br><span class="line"><span class="comment">     * the key is greater than all existing keys in the array.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">append</span><span class="params">(<span class="keyword">int</span> key, E value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mSize != <span class="number">0</span> &amp;&amp; key &lt;= mKeys[mSize - <span class="number">1</span>]) &#123;</span><br><span class="line">            put(key, value);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 优化了key大于数组中所有key的情况，mKeys[mSize-1]是这个数组中最大的一个key</span></span><br><span class="line">        <span class="keyword">if</span> (mGarbage &amp;&amp; mSize &gt;= mKeys.length) &#123;</span><br><span class="line">            gc();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mKeys = GrowingArrayUtils.append(mKeys, mSize, key);</span><br><span class="line">        mValues = GrowingArrayUtils.append(mValues, mSize, value);</span><br><span class="line">        mSize++;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>整理空间</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">gc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// Log.e("SparseArray", "gc start with " + mSize);</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">int</span> n = mSize;</span><br><span class="line">      <span class="keyword">int</span> o = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">int</span>[] keys = mKeys;</span><br><span class="line">      Object[] values = mValues;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">          Object val = values[i];</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (val != DELETED) &#123;</span><br><span class="line">              <span class="keyword">if</span> (i != o) &#123;</span><br><span class="line">                  keys[o] = keys[i];</span><br><span class="line">                  values[o] = val;</span><br><span class="line">                  values[i] = <span class="keyword">null</span>;</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">              o++;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      mGarbage = <span class="keyword">false</span>;</span><br><span class="line">      mSize = o;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Log.e("SparseArray", "gc end with " + mSize);</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Removes the mapping from the specified key, if there was any.</span><br><span class="line"> */</span><br><span class="line">public void delete(int key) &#123;</span><br><span class="line">    int i = ContainerHelpers.binarySearch(mKeys, mSize, key);</span><br><span class="line"></span><br><span class="line">    if (i &gt;= 0) &#123;</span><br><span class="line">        if (mValues[i] != DELETED) &#123;</span><br><span class="line">            mValues[i] = DELETED;</span><br><span class="line">            mGarbage = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>最关键的二分法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// This is Arrays.binarySearch(), but doesn&apos;t do any argument validation.</span><br><span class="line">static int binarySearch(int[] array, int size, int value) &#123;</span><br><span class="line">    int lo = 0;</span><br><span class="line">    int hi = size - 1;</span><br><span class="line"></span><br><span class="line">    while (lo &lt;= hi) &#123;</span><br><span class="line">        final int mid = (lo + hi) &gt;&gt;&gt; 1;</span><br><span class="line">        final int midVal = array[mid];</span><br><span class="line"></span><br><span class="line">        if (midVal &lt; value) &#123;</span><br><span class="line">            lo = mid + 1;</span><br><span class="line">        &#125; else if (midVal &gt; value) &#123;</span><br><span class="line">            hi = mid - 1;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return mid;  // value found</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return ~lo;  // value not present</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>可以看出SparseArray里面的元素是按照key从小到大排序的，所以插入、删除、查找的速度都很快</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/07/Android四大组件----Activity（2）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ke Yu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coco">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/07/Android四大组件----Activity（2）/" itemprop="url">Activity(2)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-09-07T17:19:20+08:00">
                2017-09-07
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Android四大组件—-Activity（2）"><a href="#Android四大组件—-Activity（2）" class="headerlink" title="Android四大组件—-Activity（2）"></a>Android四大组件—-Activity（2）</h1><ul>
<li><p><a href="#Android四大组件----Activity（2）-基础概念">基础概念</a></p>
<ul>
<li><p><a href="#Android四大组件----Activity（2）-通信">通信</a></p>
<ul>
<li><p><a href="#Android四大组件----Activity（2）-1.ActivityMa">1.ActivityManagerService</a></p>
</li>
<li><p><a href="#Android四大组件----Activity（2）-2.IApplicati">2.IApplicationThread</a></p>
</li>
<li><p><a href="#Android四大组件----Activity（2）-3.IActivityM">3.IActivityManager</a></p>
</li>
<li><p><a href="#Android四大组件----Activity（2）-4.基本联系">4.基本联系</a></p>
</li>
</ul>
</li>
<li><p><a href="#Android四大组件----Activity（2）-协助">协助</a></p>
<ul>
<li><p><a href="#Android四大组件----Activity（2）-1.ActivityRe">1.ActivityRecord</a></p>
</li>
<li><p><a href="#Android四大组件----Activity（2）-2.TaskRecord">2.TaskRecord</a></p>
</li>
<li><p><a href="#Android四大组件----Activity（2）-3.ActivitySt">3.ActivityStack</a></p>
</li>
<li><p><a href="#Android四大组件----Activity（2）-4.ActivityTh">4.ActivityThread</a></p>
</li>
</ul>
</li>
<li><p><a href="#Android四大组件----Activity（2）-5.Instrument">5.Instrumentation</a></p>
</li>
</ul>
</li>
<li><p><a href="#Android四大组件----Activity（2）-基本过程">基本过程</a></p>
</li>
<li><p><a href="#Android四大组件----Activity（2）-一些问题">一些问题</a></p>
<ul>
<li><p><a href="#Android四大组件----Activity（2）-问题1">问题1</a></p>
</li>
<li><p><a href="#Android四大组件----Activity（2）-问题2">问题2</a></p>
</li>
</ul>
</li>
</ul>
<h3 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h3><h4 id="通信"><a href="#通信" class="headerlink" title="通信"></a>通信</h4><h5 id="1-ActivityManagerService"><a href="#1-ActivityManagerService" class="headerlink" title="1.ActivityManagerService"></a>1.ActivityManagerService</h5><p>主要管理应用进程的生命周期以及进程的Activity,Service,Broadcast等等。</p>
<p>可以分为client端与Server端：</p>
<ul>
<li><p>Client端运行在app的各个进程，这些进程实现了具体的activity和service，通过调用系统接口来完成显示。</p>
</li>
<li><p>Service端运行在系统进程中，是系统级别的AMS的实现，响应client端的系统调用请求，并且管理client端的各个APP的生命周期。</p>
</li>
</ul>
<h5 id="2-IApplicationThread"><a href="#2-IApplicationThread" class="headerlink" title="2.IApplicationThread"></a>2.IApplicationThread</h5><p>该接口定义了AMS访问App的接口。AMS通过这个接口的实现控制App的进程完成App的响应。</p>
<p>实现：ApplicationThread。实质上是一个Binder对象，在进程启动，创建ActivityThread时实例化，AMS通过它的代理ApplicationThreadProxy和Activity进行进程间通信。</p>
<h5 id="3-IActivityManager"><a href="#3-IActivityManager" class="headerlink" title="3.IActivityManager"></a>3.IActivityManager</h5><p>该接口定义了App访问AMS的接口。App通过这个接口的实现对请求AMS完成某些操作。</p>
<p>实现：ActivityManagerNative。Activity通过代理ActivityManagerProxy将请求送到AMS进行进程间通信。</p>
<h5 id="4-基本联系"><a href="#4-基本联系" class="headerlink" title="4.基本联系"></a>4.基本联系</h5><ul>
<li><p>一个进程对应一个ActivityThread实例，这个进程里面所有的activity对应这一个ActivityThread实例</p>
</li>
<li><p>一个进程对应一个ApplicationThread对象，此对象是ActivityThread 与<br>ActivityManagerService连接的桥梁。</p>
</li>
</ul>
<h4 id="协助"><a href="#协助" class="headerlink" title="协助"></a>协助</h4><h5 id="1-ActivityRecord"><a href="#1-ActivityRecord" class="headerlink" title="1.ActivityRecord"></a>1.ActivityRecord</h5><ul>
<li>记录一个Activity的相关信息</li>
</ul>
<h5 id="2-TaskRecord"><a href="#2-TaskRecord" class="headerlink" title="2.TaskRecord"></a>2.TaskRecord</h5><ul>
<li><p>记录当前Task中所有Activity：ArrayList\&lt;ActivityRecord> mActivities</p>
</li>
<li><p>ActivityStack成员stack记录Task所在的栈，用于执行ActivityStack的方法</p>
</li>
</ul>
<h5 id="3-ActivityStack"><a href="#3-ActivityStack" class="headerlink" title="3.ActivityStack"></a>3.ActivityStack</h5><p>管理协调ActivityRecord和TaskRecord</p>
<ul>
<li><p>记录所有的栈</p>
</li>
<li><p>通知WindowManagerService的监听器</p>
</li>
</ul>
<h5 id="4-ActivityThread"><a href="#4-ActivityThread" class="headerlink" title="4.ActivityThread"></a>4.ActivityThread</h5><ul>
<li><p>应用程序的入口</p>
</li>
<li><p>管理【应用程序的主线程】—–它自己不是线程</p>
</li>
<li><p>根据AMS的要求，进行Activity的调度</p>
</li>
</ul>
<h4 id="5-Instrumentation"><a href="#5-Instrumentation" class="headerlink" title="5.Instrumentation"></a>5.Instrumentation</h4><ul>
<li><p>管理监测Android控件的运行</p>
</li>
<li><p>根据ActivityThread的要求，完成Activity的生命周期控制</p>
</li>
</ul>
<h3 id="基本过程"><a href="#基本过程" class="headerlink" title="基本过程"></a>基本过程</h3><p>step1：无论是launcher启动，还是activity内部调用startActivity接口来启动新的Activity，都是通过Binder的进程间通信进入到AMS进程中，然后调用ActivityManagerService.startActivity。</p>
<p>期间主要经历以下过程：</p>
<p> 1)在Launcher.startActivity中由于.MainActivity在注册文件中设置了intent，所以点击图标时，launcher会将这个activity启动。<br>问题1：intent的信息怎么被Launcher找到？</p>
<p> 2)在Activity.startActivityForResult中，通过mMainThread（应用的主线程）.getApplicationThread获得了<strong>ApplicationThread</strong>对象，用于AMS和ActivityThread的通信，然后执行了Instrumentation.execStartActivity。</p>
<p> 3)在Instrumentation.execStartActivity中，通过ActivityManagerNative.getDefault返回ActivityManagerService的远程接口，得到了<strong>ActivityManagerProxy</strong>接口。</p>
<p> 4)通过<strong>ActivityManagerProxy</strong>接口，向AMS发出请求，也就是执行ActivityManagerService.startActivity。</p>
<p>step2：AMS.startActivity将操作转发给成员变量mMainStack（ActivityStack类型）的startActivityMayWait函数，来准备要启动的Activity的相关信息。</p>
<p>之后会经历以下过程：</p>
<p> 1)在 ActivityStack.startActivityLocked中，可以从传进来的参数中得到调用者的信息，即Laucher应用程序的进程信息。</p>
<p> 2)在ActivityStack.startActivityUncheckedLocked中，根据当前Activity的启动模式、taskAfiinity属性，设置的intent<br>flags等选择Task。为当前新创建的ActivityRecord找到Task。</p>
<pre><code>比较复杂，其实是理解启动模式的关键。还是需要结合源码才能理解。
</code></pre><p> 3)根据启动模式的相关知识，寻找Task还涉及到Task顶端的Activty。这个过程由resumeTopActivityLocked完成，主要就是看我们要启动的Activity是否在栈顶，如果不是的话，需要将当前运行的Activity暂停。这个工作还是由ActivityStack.startPausingLocked()来完成。</p>
<p>step3：ActivityStack在startPausingLocked中会将需要暂停的Activity暂停，主要经历以下过程：</p>
<p> 1)通过ApplicationThread.schedulePauseActivity进行通信，告诉ActivityThread执行handlePauseActivity</p>
<p> 2)ActivityThread接收到通知，于是通过ActivityManager向ActivityManagerService发起activityPaused的请求</p>
<p> 3) ActivityManagerService接收到请求，把工作交给ActivityStack，它进行了Activity的停止工作</p>
<p> 4)停止了该停止了Activity，又通过ApplicationThread来告诉系统服务进程要进行真正的Activity启动调度了。这个系统进程就是在step1中发出startActivity请求的Activity对应的进程，比如对于点击程序图标启动，那么就是Launcher所在进程，而对于Activity内部调用startActivity的情景，这个就是这个Activity所在进程。</p>
<p>step4：ApplicationThread不执行真正的启动操作，它通过ActivityManagerService.activityPause接口进入到AMS进程中，看是否需要创建新的进程来启动Activity。<br>如果是点击应用图标启动的话， ActivityManagerService<br>在这步会调用startProcessLocked来创建一个新的进程，而对于通过在Activty内部调用startActivity来启动新的Activity来说，这步不需要，因为新的activity就在原来的activity所在的进程中启动。</p>
<p>step5：ActivityManagerService调用ApplicationThread.scheduleLaunchActivity，通知相应的进程执行Activity的操作。<br>ApplicationThread把这个启动Activity的操作转发给ActivityThread，ActivityThread发送msg，接收到消息后进行handleLaunchActivity操作，该操作主要是调用进行PerformLaunchActivity</p>
<p>主要是以下过程：</p>
<pre><code>1）ActivityThread
</code></pre><p>调用Instrumentation的newOnActivity方法，通过ClassLoader导入相应的Activity类</p>
<p>2）创建Application对象（一个应用只有一个Application），然后通过attach把activity的上下文信息（Context）设置到mainActivity去。</p>
<p>3）Instrumentation调用callActivityOnCreate()执行Activity的onCreate()方法。</p>
<h3 id="一些问题"><a href="#一些问题" class="headerlink" title="一些问题"></a>一些问题</h3><h4 id="问题1"><a href="#问题1" class="headerlink" title="问题1"></a>问题1</h4><p>Launcher怎么获得intent信息？</p>
<ul>
<li>涉及到PackageManagerService。它负责apk的安装、卸载等，在安装apk时会进行package的解析，把四大组件的相关信息存储下来。解析时，PMS中有相关的操作，对intentFiters查找、添加与匹配。对于一个新安装的应用，PMS找到intent-fileter中action为“android.intent.action.MAIN”并且category为“android.intent.category.LAUNCHER”的Activity，就会为这种应用程序创建桌面图标。</li>
</ul>
<h4 id="问题2"><a href="#问题2" class="headerlink" title="问题2"></a>问题2</h4><p>ActivityThread如何管理主线程？</p>
<ul>
<li><p>从上述对Activity启动过程的简单介绍中，可以看到ActivityThread会执行handlePauseActivity、PerformLaunchActivity等操作，也就是说ActivityThread控制了Activity的暂停、创建等操作，在ActivityThread的main()函数中可以看到它做了这样的事：</p>
</li>
<li><p>1)创建Looper</p>
</li>
<li><p>2)创建ActivityThread对象</p>
</li>
<li><p>3)创建binder对象ApplicationThread，将它和当前ActivityThread以及Application绑定</p>
</li>
<li><p>4)Looper循环，Handler接收消息，然后ActivityThread就可以执行handle方法，通过ActivityManager向ActivityManagerService发出请求</p>
</li>
</ul>
<p>参考资料：</p>
<p><a href="http://blog.csdn.net/luoshengyang/article/details/6689748" target="_blank" rel="noopener">http://blog.csdn.net/luoshengyang/article/details/6689748</a></p>
<p><a href="http://blog.csdn.net/luoshengyang/article/details/6685853" target="_blank" rel="noopener">http://blog.csdn.net/luoshengyang/article/details/6685853</a></p>
<p><a href="http://www.2cto.com/kf/201610/554316.html" target="_blank" rel="noopener">http://www.2cto.com/kf/201610/554316.html</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/07/volleySourceAny/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ke Yu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coco">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/07/volleySourceAny/" itemprop="url">volly源码解析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-09-07T14:09:30+08:00">
                2017-09-07
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="①Request-java"><a href="#①Request-java" class="headerlink" title="①Request.java"></a>①Request.java</h3><p><strong>实现了</strong> Comparable&lt;Request<t>&gt; 接口</t></p>
<p>抽象类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Request</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span></span></span><br><span class="line"><span class="class"><span class="title">Comparable</span>&lt;<span class="title">Request</span>&lt;<span class="title">T</span>&gt;&gt; </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>两个构造函数，有一个已经废弃了(所以后面的所有具体实现中，有一个构造函数也是被弃用了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Request</span><span class="params">(<span class="keyword">int</span> method, String url, Response.ErrorListener listener)</span></span>;</span><br></pre></td></tr></table></figure>
<p>具体分析一下几种request：</p>
<p>a.StringRequest:</p>
<p>1）方法、URL、监听器<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">StringRequest</span><span class="params">(<span class="keyword">int</span> method, String url, Listener&lt;String&gt; listener,ErrorListener errorListener)</span></span></span><br></pre></td></tr></table></figure></p>
<p>2）结束时，调用父类的方法（其实父类中也是置空监听器）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onFinish</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">super</span>.onFinish();</span><br><span class="line">	mListener = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3）回调接口函数<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">deliverResponse</span><span class="params">(String response)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(mListener != <span class="keyword">null</span>) &#123;</span><br><span class="line">		mListener.onResponse(response);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>4）把接收到的response信息解析，主要是cache分发器和network分发器会用到，response不是像我们一样简单的弄成String，而是专门根据类型存放一个在Response&lt;&gt;对象中<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Response\&lt;String\&gt; parseNetworkResponse(NetworkResponse response)</span><br><span class="line">&#123;</span><br><span class="line">	String parsed;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		parsed = <span class="keyword">new</span> String(response.data,</span><br><span class="line">		HttpHeaderParser.parseCharset(response.headers));</span><br><span class="line">	&#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">		parsed = <span class="keyword">new</span> String(response.data);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> Response.success(parsed,</span><br><span class="line">	HttpHeaderParser.parseCacheHeaders(response)); --&gt; 这个函数其实是response构造</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>b.JsonRequest</p>
<p>1)构造函数<br>参数：方法、url、requestBody、监听器<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">JsonRequest</span><span class="params">(<span class="keyword">int</span> method, String url, String requestBody,</span></span></span><br><span class="line"><span class="function"><span class="params">	Listener&lt;T&gt; listener,ErrorListener errorListener)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">super</span>(method, url, errorListener);</span><br><span class="line">	mListener = listener;</span><br><span class="line">	mRequestBody = requestBody;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>2）onFinish（）和diliverResponse（）与上面一样。</p>
<p>3）交给JsonArrayRequest和JsonObjectRequest去实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">abstract</span> <span class="keyword">protected</span> Response&lt;T&gt; <span class="title">parseNetworkResponse</span><span class="params">(NetworkResponse response)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>4）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getBodyContentType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> PROTOCOL_CONTENT_TYPE; <span class="comment">// utf-8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>5）把请求体的内容转为bytes[]类型（String的方法 getBytes）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">byte</span>[] getBody() &#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> mRequestBody == <span class="keyword">null</span> ? <span class="keyword">null</span> : mRequestBody.getBytes(PROTOCOL_CHARSET);</span><br><span class="line">	&#125; <span class="keyword">catch</span> (UnsupportedEncodingException uee) &#123;</span><br><span class="line">		VolleyLog.wtf(<span class="string">"Unsupported Encoding while trying to get the bytes of %s</span></span><br><span class="line"><span class="string">		using %s"</span>,mRequestBody, PROTOCOL_CHARSET);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>c.ImageRequest（这种方法过时了）</p>
<p>1)构造函数<br>在加载图片时如果图片超过期望的最大宽度和高度则会进行压缩。注意两个类型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//@param scaleType The ImageViews ScaleType used to calculate the needed image size.</span></span><br><span class="line"><span class="comment">//@param decodeConfig Format to decode the bitmap to</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ImageRequest</span><span class="params">(String url, Response.Listener&lt;Bitmap&gt; listener,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">int</span> maxWidth, <span class="keyword">int</span> maxHeight, ScaleType scaleType, Config decodeConfig, Response.ErrorListener errorListener)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">super</span>(Method.GET, url, errorListener);</span><br><span class="line">	setRetryPolicy(<span class="keyword">new</span> DefaultRetryPolicy(IMAGE_TIMEOUT_MS, IMAGE_MAX_RETRIES,IMAGE_BACKOFF_MULT));</span><br><span class="line">	mListener = listener;</span><br><span class="line">	mDecodeConfig = decodeConfig;</span><br><span class="line">	mMaxWidth = maxWidth;</span><br><span class="line">	mMaxHeight = maxHeight;</span><br><span class="line">	mScaleType = scaleType;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2)同样的，要对response进行解析：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Response&lt;Bitmap&gt; <span class="title">parseNetworkResponse</span><span class="params">(NetworkResponse response)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// Serialize all decode on a global lock to reduce concurrent heap usage.*</span></span><br><span class="line">	<span class="keyword">synchronized</span> (sDecodeLock) &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> doParse(response);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (OutOfMemoryError e) &#123;</span><br><span class="line">			VolleyLog.e(<span class="string">"Caught OOM for %d byte image, url=%s"</span>,</span><br><span class="line">			response.data.length, getUrl());</span><br><span class="line">			<span class="keyword">return</span> Response.error(<span class="keyword">new</span> ParseError(e));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3）解析函数</p>
<p>和最近写图片压缩方法一样，但是，desiredWidth 和desiredHeight ， 到底是什么鬼？ =<br>= 没看懂，仔细看传值，maxPrimary 和 secondPrimary 主维和二维..就是图片的宽高…</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Response&lt;Bitmap&gt; <span class="title">doParse</span><span class="params">(NetworkResponse response)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">byte</span>[] data = response.data;</span><br><span class="line">	BitmapFactory.Options decodeOptions = <span class="keyword">new</span> BitmapFactory.Options();</span><br><span class="line">	Bitmap bitmap = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">if</span> (mMaxWidth == <span class="number">0</span> &amp;&amp; mMaxHeight == <span class="number">0</span>) &#123;</span><br><span class="line">		decodeOptions.inPreferredConfig = mDecodeConfig;</span><br><span class="line">		bitmap = BitmapFactory.decodeByteArray(data, <span class="number">0</span>, data.length,</span><br><span class="line">		decodeOptions);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// If we have to resize this image, first get the natural bounds.</span></span><br><span class="line">		decodeOptions.inJustDecodeBounds = <span class="keyword">true</span>;</span><br><span class="line">		BitmapFactory.decodeByteArray(data, <span class="number">0</span>, data.length, decodeOptions);</span><br><span class="line">		<span class="keyword">int</span> actualWidth = decodeOptions.outWidth;</span><br><span class="line">		<span class="keyword">int</span> actualHeight = decodeOptions.outHeight;</span><br><span class="line">		<span class="comment">// Then compute the dimensions we would ideally like to decode to.</span></span><br><span class="line">		<span class="keyword">int</span> desiredWidth = getResizedDimension(mMaxWidth, mMaxHeight,</span><br><span class="line">		actualWidth, actualHeight, mScaleType);</span><br><span class="line">		<span class="keyword">int</span> desiredHeight = getResizedDimension(mMaxHeight, mMaxWidth,</span><br><span class="line">		actualHeight, actualWidth, mScaleType);</span><br><span class="line">		<span class="comment">// Decode to the nearest power of two scaling factor.</span></span><br><span class="line">		decodeOptions.inJustDecodeBounds = <span class="keyword">false</span>;</span><br><span class="line">		<span class="comment">// TODO(ficus): Do we need this or is it okay since API 8 doesn't support it?</span></span><br><span class="line">		<span class="comment">// decodeOptions.inPreferQualityOverSpeed = PREFER_QUALITY_OVER_SPEED;</span></span><br><span class="line">		decodeOptions.inSampleSize =</span><br><span class="line">		findBestSampleSize(actualWidth, actualHeight, desiredWidth, desiredHeight);</span><br><span class="line">		Bitmap tempBitmap =</span><br><span class="line">		BitmapFactory.decodeByteArray(data, <span class="number">0</span>, data.length, decodeOptions);</span><br><span class="line">		<span class="comment">// If necessary, scale down to the maximal acceptable size.</span></span><br><span class="line">		<span class="keyword">if</span> (tempBitmap != <span class="keyword">null</span> &amp;&amp; (tempBitmap.getWidth() &gt; desiredWidth ||</span><br><span class="line">		tempBitmap.getHeight() &gt; desiredHeight)) &#123;</span><br><span class="line">		<span class="comment">// 可以根据原来的位图创建一个新的位图。= =有点无语，那之前为什么要有inSamplesize?</span></span><br><span class="line">		<span class="comment">// 因为上面是图片内存的压缩= =</span></span><br><span class="line">		由于要考虑samplesize，所以可能达不到desired，这里就 重新来一遍？</span><br><span class="line">		bitmap = Bitmap.createScaledBitmap(tempBitmap,</span><br><span class="line">		desiredWidth, desiredHeight, <span class="keyword">true</span>);</span><br><span class="line">		tempBitmap.recycle();</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		bitmap = tempBitmap;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (bitmap == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> Response.error(<span class="keyword">new</span> ParseError(response));</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> Response.success(bitmap,</span><br><span class="line">		HttpHeaderParser.parseCacheHeaders*(response));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>5）<br>这个函数用来计算desiredWidth和desiredHeight，计算出来这两个值，再用他们来计算samplesize，这其实就是自己写 图片压缩 时候的reqWidth,和 reqHeight， 感觉这里处理得比较巧妙。<br>自己实现的时候，就在想reqWidth和reqHeight要赋值什么- - ，<br>这里让用户设置可以接收的maxWidth和maxHeight（也可以不设置），然后根据规则再计算req的宽高。<br>计算desiredHeight的时候，主维就是mMaxHeight。<br>没懂这个规则= =暂时跳过了…</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getResizedDimension</span><span class="params">(<span class="keyword">int</span> maxPrimary, <span class="keyword">int</span></span></span></span><br><span class="line"><span class="function"><span class="params">maxSecondary, <span class="keyword">int</span> actualPrimary,<span class="keyword">int</span> actualSecondary, ScaleType scaleType)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// If no dominant value at all, just return the actual.</span></span><br><span class="line">	<span class="keyword">if</span> ((maxPrimary == <span class="number">0</span>) &amp;&amp; (maxSecondary == <span class="number">0</span>)) &#123;</span><br><span class="line">		<span class="keyword">return</span> actualPrimary;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// If ScaleType.FIT_XY fill the whole rectangle, ignore ratio.*</span></span><br><span class="line">	<span class="comment">// 填充整个矩形</span></span><br><span class="line">	<span class="keyword">if</span> (scaleType == ScaleType.FIT_XY) &#123;</span><br><span class="line">		<span class="keyword">if</span> (maxPrimary == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> actualPrimary;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> maxPrimary;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// If primary is unspecified, scale primary to match secondary's scaling</span></span><br><span class="line">	ratio.</span><br><span class="line">	<span class="keyword">if</span> (maxPrimary == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">double</span> ratio = (<span class="keyword">double</span>) maxSecondary / (<span class="keyword">double</span>) actualSecondary;</span><br><span class="line">		<span class="keyword">return</span> (<span class="keyword">int</span>) (actualPrimary \ ratio);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (maxSecondary == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> maxPrimary;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">double</span> ratio = (<span class="keyword">double</span>) actualSecondary / (<span class="keyword">double</span>) actualPrimary;</span><br><span class="line">	<span class="keyword">int</span> resized = maxPrimary;</span><br><span class="line">	<span class="comment">// If ScaleType.CENTER_CROP fill the whole rectangle, preserve aspect ratio.</span></span><br><span class="line">	<span class="keyword">if</span> (scaleType == ScaleType.CENTER_CROP) &#123;</span><br><span class="line">		<span class="keyword">if</span> ((resized * ratio) &lt; maxSecondary) &#123;</span><br><span class="line">			resized = (<span class="keyword">int</span>) (maxSecondary / ratio);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> resized;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> ((resized * ratio) &gt; maxSecondary) &#123;</span><br><span class="line">		resized = (<span class="keyword">int</span>) (maxSecondary / ratio);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> resized;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>d.ImageLoader（太长了…在代码里写注释了 = = 不在这里写了…</p>
<p>1）构造函数<br>有七个成员变量，两个涉及构造函数：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ImageLoader</span><span class="params">(RequestQueue queue, ImageCache imageCache)</span> </span>&#123;</span><br><span class="line">	mRequestQueue = queue;</span><br><span class="line">	mCache = imageCache;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>2）内部类，请求的holder，记录该种请求，对应的key,对应的bitmap,以及监听器。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImageContainer</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>3）内部类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">BatchedImageRequest</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>②RequestQueue.java<br>涉及到的数据结构：</p>
<p>0）<br>用于请求队列的递增序号 ， 也即记录了请求的数量<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> AtomicInteger mSequenceGenerator = <span class="keyword">new</span> AtomicInteger();</span><br></pre></td></tr></table></figure></p>
<p><strong>1）用于查找是否有相同cachekey的重复请求（get(cachekey）为null说明没有</strong></p>
<p><strong>key是string,value是一个请求队列！等待中的请求集合，也就是没有被分给cache也没被分给network</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Queue&lt;Request&lt;?&gt;&gt;&gt; mWaitingRequests =</span><br><span class="line"><span class="keyword">new</span> HashMap&lt;String, Queue&lt;Request&lt;?&gt;&gt;&gt;();</span><br></pre></td></tr></table></figure>
<p>2）当前正在处理的请求</p>
<p>如果请求正在任意一个queue中wating，或者正在由任意一个分发函数处理，就会在这个set中<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Set&lt;Request&lt;?&gt;&gt; mCurrentRequests = <span class="keyword">new</span> HashSet&lt;Request&lt;?&gt;&gt;();</span><br></pre></td></tr></table></figure></p>
<p>3）cache类的请求</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> PriorityBlockingQueue&lt;Request&lt;?&gt;&gt; mCacheQueue = <span class="keyword">new</span> PriorityBlockingQueue&lt;Request&lt;?&gt;&gt;();</span><br></pre></td></tr></table></figure>
<p>4）network类的请求</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> PriorityBlockingQueue&lt;Request&lt;?&gt;&gt; mNetworkQueue =</span><br><span class="line"><span class="keyword">new</span> PriorityBlockingQueue&lt;Request&lt;?&gt;&gt;();</span><br></pre></td></tr></table></figure>
<p>5）网络请求最大线程数目：4<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_NETWORK_THREAD_POOL_SIZE = <span class="number">4</span>;</span><br></pre></td></tr></table></figure></p>
<p>6）完成请求后的回调接口：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">\\ Callback <span class="class"><span class="keyword">interface</span> <span class="title">for</span> <span class="title">completed</span> <span class="title">requests</span>. </span></span><br><span class="line"><span class="class">// 完成请求后的回调接口*</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">static</span> <span class="title">interface</span>** <span class="title">RequestFinishedListener</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">\\ Called when a request has finished processing. </span><br><span class="line"><span class="comment">// 请求事务结束后会回调</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onRequestFinished</span><span class="params">(Request&lt;T&gt; request)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>7）任务完成后的监听器队列<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> List&lt;RequestFinishedListener&gt; mFinishedListeners = <span class="keyword">new</span> ArrayList&lt;RequestFinishedListener&gt;();</span><br></pre></td></tr></table></figure></p>
<p>8）三个构造函数：cache,network参数是必须。其余两个分别是线程池默认大小4以及<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> ExecutorDelivery(<span class="keyword">new</span> Handler(Looper.getMainLooper())。</span><br></pre></td></tr></table></figure></p>
<p>最终归于这个：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">RequestQueue</span><span class="params">(Cache cache, Network network, <span class="keyword">int</span> threadPoolSize, ResponseDelivery delivery)</span> </span>&#123;</span><br><span class="line">	mCache = cache;</span><br><span class="line">	mNetwork = network;</span><br><span class="line">	mDispatchers = <span class="keyword">new</span> NetworkDispatcher[threadPoolSize];</span><br><span class="line">	mDelivery = delivery;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>delivery其实是是来自这里，= =<br>读完了response回到这里，发现这个局早在requestQueue里面就布好了…厉害…<br>一开始就把UI线程的handler传给了ExecutorDelivery，这样在cache分发线程的mDelivery.postResponse（）才能很好的调用= =。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">RequestQueue</span><span class="params">(Cache cache, Network network, <span class="keyword">int</span> threadPoolSize)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>(cache, network, threadPoolSize,</span><br><span class="line">	<span class="keyword">new</span> ExecutorDelivery(<span class="keyword">new</span> Handler(Looper.getMainLooper())));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>9）过滤器接口<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RequestFilter</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">apply</span><span class="params">(Request\&lt;?\&gt; request)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>10）两个cancelAll的方法，一个是通过过滤器，一个是通过Object tag</p>
<p>其实tag的方法中，也是靠定义一个 request.getTag()==tag的过滤器实现的。</p>
<p><strong>11） 把请求添加到分发队列中 , add</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Request&lt;T&gt; <span class="title">add</span><span class="params">(Request&lt;T&gt; request)</span> ；</span></span><br><span class="line"><span class="function">首先request.<span class="title">setRequestQueue</span><span class="params">(<span class="keyword">this</span>)</span></span>; 将这个请求标记为属于这个队列</span><br><span class="line">然后<span class="keyword">synchronized</span> (mCurrentRequests) &#123;</span><br><span class="line">	mCurrentRequests.add(request);</span><br><span class="line">&#125;在当前请求队列中加上这个请求</span><br><span class="line">再request.setSequence(getSequenceNumber()); 设置这个请求的序列号</span><br><span class="line">并加上标记。</span><br><span class="line">接着</span><br><span class="line"><span class="keyword">if</span> (!request.shouldCache()) &#123;</span><br><span class="line">	mNetworkQueue.add(request);</span><br><span class="line">	<span class="keyword">return</span> request;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果该请求不要求缓存， 将请求加到newtwork队列中，返回请求。</span></span><br><span class="line">request.shouldCache()</span><br><span class="line"><span class="comment">//是一个返回boolean的函数，可知有一个boolean为每个请求设置了是否需要缓存的标志。</span></span><br><span class="line"><span class="comment">//如果要求缓存，继续下一步：</span></span><br><span class="line"><span class="comment">//判断mWaitingRequests中是否存在相同key的请求队列，也就是是否有相同key的请求在等待，在该结构中，一个string对应了一个队列，其实是一个链表吧...linkedlist</span></span><br><span class="line">Queue&lt;Request&lt;?&gt;&gt; stagedRequests = mWaitingRequests.get(cacheKey);</span><br><span class="line"><span class="comment">//如果有的话，取出这个请求队列（Queue&lt;Request&lt;?&gt;&gt; ） 为空的话:</span></span><br><span class="line"><span class="keyword">if</span> (stagedRequests == <span class="keyword">null</span>) &#123;</span><br><span class="line">	stagedRequests = <span class="keyword">new</span> LinkedList&lt;Request&lt;?&gt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//然后把请求加到这个链表中。再把&lt;Key,链表&gt;存入到 mWaitingRequests 中。</span></span><br><span class="line"><span class="comment">//如果不存在的话，将&lt;key,null&gt;存入到这 mWaitingRequests</span></span><br><span class="line"><span class="comment">//中，然后给cacheQueue加上请求。也就是：</span></span><br><span class="line">mWaitingRequests.put(cacheKey, <span class="keyword">null</span>);</span><br><span class="line">mCacheQueue.add(request);</span><br></pre></td></tr></table></figure>
<p>思考：为什么含有key时，stagedRequests可能为空，并且如果为空也要新建一个实例后才把&lt;key,链表&gt;插入<br>而没有key时，直接&lt;key,null&gt; 插入？？<br>JAVA基础啊 = = hashmap.remove(key)之后，再用key去get，得到的是null。<br>因为，含有key时，说明有相同请求正在执行（有可能调用了remove(key），所以导致这个key对应的队列为null)（甚至可能还有在等待的相同请求，所以需要先把当前请求用一个<br>LinkedList封装起来，再放到等待队列中，当然了，如果相同key中除了正在执行的，还有在等待的，那么stageRequest不会为空，直接把request放进去就可以了。<br>而没有key的话，这个请求会mCacheQueue.add(request);<br>也就是丢给cache处理，所以它此时正在被处理，那么自然是把&lt;key,null&gt;存到mWaitingRequests中了。</p>
<p>最后finish:</p>
<p>这个finish可能在request的finish中被调用：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (mRequestQueue != <span class="keyword">null</span>) &#123; <span class="comment">// 这是这个reuquest对应的queue</span></span><br><span class="line">	<span class="comment">// 如果请求队列不为空，结束当前请求</span></span><br><span class="line">	<span class="comment">// 让当前请求处于onFinish（）</span></span><br><span class="line">	mRequestQueue.finish(<span class="keyword">this</span>);</span><br><span class="line">	onFinish();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意这个finish是requestQueue的finish，不是request的finish！两者是有区别的。</p>
<p>思考：为什么还有相同key的请求时，把这些所有请求都一下加入到cacheQueue中呢？<br>别人解释：<br>第二步就是判断这个请求有没有要求缓存，如果有（waitingRequests不为null）：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Queue&lt;Request&lt;?&gt;&gt; waitingRequests = mWaitingRequests.remove(cacheKey);</span><br></pre></td></tr></table></figure></p>
<p>注意这个remove(key)，虽然说把key对应的value从map中清理了，但是返回了这个key对应的value（删除前的value）。<br>于是要将mWaitingQueue中相同CacheKey的所有requests放入cacheQueue中，<br>因为前面我们不知道相同CacheKey的那个请求到底在缓存中有没有，如果没有，它需要去网络中获取，那就等到它从网络中获取之后，<strong>放到缓存中后，它结束了，并且已经缓存了（意思就是到这步时，这个key的response已经放到cache中了）</strong>，这个时候，我们就可以保证后面那堆相同CacheKey的请求可以在缓存中去取到数据了，而不需要再去网络中获取了。</p>
<h3 id="②DiskCacheBased-java"><a href="#②DiskCacheBased-java" class="headerlink" title="②DiskCacheBased.java"></a>②DiskCacheBased.java</h3><p>1)inputSteam的三种read:</p>
<p><strong>a.read() : 对流一个字节一个字节读，返回的int就是这个byte的int表示方式。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">InputStream in = Test.class.getResourceAsStream(<span class="string">"/tt.txt"</span>);</span><br><span class="line"><span class="keyword">byte</span>[]tt=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">15</span>];<span class="comment">//测试用的事前知道有15个字节码</span></span><br><span class="line"><span class="keyword">while</span>(in.available()!=<span class="number">0</span>)&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i\&lt;<span class="number">15</span>;i++)&#123; tt[i]=(<span class="keyword">byte</span>)in.read();&#125;</span><br><span class="line">&#125;</span><br><span class="line">String ttttt=<span class="keyword">new</span> String(tt,<span class="string">"utf-8"</span>);</span><br><span class="line">System.out.println(ttttt);</span><br><span class="line">in.close();</span><br></pre></td></tr></table></figure>
<p><strong>b.read(byte[] b):规定一个数组长度，把流中的字节缓冲到数组b中去，返回真实的字节个数</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">in = Test.class.getResourceAsStream(<span class="string">"/tt.txt"</span>);</span><br><span class="line"><span class="keyword">byte</span> [] tt=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">int</span> b;</span><br><span class="line"><span class="keyword">while</span>((b=in.read(tt))!=-<span class="number">1</span>)&#123; System.out.println(b); &#125;</span><br><span class="line">String tzt=<span class="keyword">new</span> String(tt,<span class="string">"utf-8"</span>);</span><br><span class="line">System.out.println(tzt);</span><br></pre></td></tr></table></figure></p>
<p>读取的字节先存到b[0] 再存到b[1]…..</p>
<p><strong>c.read(byte[] b, int off, int len) ：从输入流中读取len个字节到数组b中，off是在数组b中写入数据的偏移。</strong></p>
<p>2.)cache有，cacheHader没有的：<br>byte[] data ; isExpired() ; refreshNeeded()</p>
<p>cache没有，cacheHeader有的：<br>string key</p>
<p>3)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> ；</span></span><br></pre></td></tr></table></figure></p>
<p>把根目录的所有file取到数组中，不为空，则将数组里的file清空。</p>
<p>4）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Entry <span class="title">get</span><span class="params">(String key)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>先通过key取出CacheHeader entry,如果entry不为空，根据key取出根目录中对应的文件。把这个文件转为CountingIS,接着<br>CacheHeader.readHeader（cis);<br>静态类，直接用类名调用函数！！根据cis获取头部数据，并把流cis转为byte[]类型，把byte[]数据通过entry.toCacheEntry(data)存到entry中。</p>
<p>5）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">()</span> ；</span></span><br></pre></td></tr></table></figure></p>
<p>根据根目录下的文件，初始化cache。把文件全部用BIS保存为流，再通过<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CacheHeader entry = CacheHeader.*readHeader*(fis);</span><br></pre></td></tr></table></figure></p>
<p>转化为cacheheader的实例再通过putEntry(entry.key, entry);把他放入mEntries这个cache的MAP集合里面。</p>
<p>6）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">putEntry</span><span class="params">(String key, CacheHeader entry)</span></span></span><br></pre></td></tr></table></figure></p>
<p>把&lt;key,cacheHeader&gt;放到map集合里面</p>
<h3 id="③CacheDispatcher-java"><a href="#③CacheDispatcher-java" class="headerlink" title="③CacheDispatcher.java"></a>③CacheDispatcher.java</h3><p>1)主要成员变量，构造函数需要的四个：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue\&lt;Request\&lt;?\&gt;\&gt; **mCacheQueue**;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue\&lt;Request\&lt;?\&gt;\&gt; **mNetworkQueue**;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Cache **mCache**;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ResponseDelivery **mDelivery**;</span><br></pre></td></tr></table></figure></p>
<p>2）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	mQuit = <span class="keyword">true</span>;</span><br><span class="line">	interrupt();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//停止cache的分发处理，调用thread的interrupt()</span></span><br></pre></td></tr></table></figure></p>
<p>3)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>用request = mCacheQueue.take();取得队列中的请求。</p>
<p>然后有几种情况：<br>a.请求取消了，request.isCanceled()为真，调用r.finish<br>然后此次循环结束，去处理下一个请求。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache.Entry entry = **mCache**.get(request.getCacheKey());</span><br></pre></td></tr></table></figure></p>
<p>b.通过r.getKey取得的key判断mCache中是否有这个entry，没有，交给Network</p>
<p>c.有这个key，但过期了,设置这个request的cacheEntry为entry ，并且交给net，结束循环</p>
<p>d.有key，且cache没过期，把entry里的数据解析了赋值给response</p>
<p>e.如果entry不需要更新，把response用deliver发送回去</p>
<p>f.要更新(Soft-expired cache hit)，response.intermediate = true;<br>意味着这个未更新的响应发回后，还有第二个更新过的响应要发回去。<br>由于还需要更新后的响应，所以这个请求还是要交给net。</p>
<h3 id="④HttpStack"><a href="#④HttpStack" class="headerlink" title="④HttpStack"></a>④HttpStack</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HttpStack</span> </span>&#123; <span class="keyword">public</span> HttpResponse performRequest ....&#125;</span><br></pre></td></tr></table></figure>
<p>这个接口被HurlStack.java实现了。</p>
<p><strong>HurlStack.java</strong></p>
<p>1)三个构造函数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">**<span class="keyword">public</span>** HurlStack(UrlRewriter urlRewriter, SSLSocketFactory sslSocketFactory)</span><br></pre></td></tr></table></figure>
<p>参数列表可为空。</p>
<p><strong>2）重写接口中唯一的一个方法（重要，用Httpurlconnection进行请求，并处理响应的函数）</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> HttpResponse <span class="title">performRequest</span><span class="params">(Request&lt;?&gt; request, Map&lt;String,</span></span></span><br><span class="line"><span class="function"><span class="params">String&gt; additionalHeaders)</span></span></span><br><span class="line"><span class="function">先使用</span></span><br><span class="line"><span class="function">HashMap&lt;String, String&gt; map </span>= <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">map.putAll(request.getHeaders());</span><br><span class="line">map.putAll(additionalHeaders);</span><br><span class="line">把请求头部的&lt;headerName,对应内容&gt;存到一个map中。</span><br><span class="line">用</span><br><span class="line">String url = request.getUrl();取得url，然后mUrlRewriter.rewriteUrl(url);取得一个新的url（没找到这个函数的实现...</span><br><span class="line">然后创建一个新的httpurlconnection, 遍历map，把所有的header加入conn的porperty中。</span><br><span class="line"></span><br><span class="line">然后：</span><br><span class="line"><span class="comment">//给conn设置请求的方法</span></span><br><span class="line">setConnectionParametersForRequest(connection, request);</span><br><span class="line">接着从这步开始都是处理响应了：</span><br><span class="line"><span class="comment">// 调用了getResponseCode()就会自动connect，不用明文调用.connect</span></span><br><span class="line"><span class="keyword">int</span> responseCode = connection.getResponseCode();</span><br></pre></td></tr></table></figure></p>
<p>首先判断响应码是不是符合要求，如果符合要求：<br>a.用函数C将connection得到的响应转化为实体</p>
<p>b.通过connection.getHeaderFields()，得到所有的响应头列表，foreach遍历这个结合，把每一条通过key单独取出来，做成header，加入到response的headers集合中。</p>
<p>2）<br><strong>C</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> HttpEntity <span class="title">entityFromConnection</span><span class="params">(HttpURLConnection</span></span></span><br><span class="line"><span class="function"><span class="params">connection)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>根据connection返回的信息，建立实体。</p>
<p>实体主要包括四个信息：content,contentLength,contentEncoding,contentType</p>
<p>使用volley时，新建一个queue（请求队列）,再将多个request放入queue中，之后发送queue</p>
<p>这时候处理queue的线程是异步，queue中也有调度，保证若干个request异步处理</p>
<p><strong>④BasickNetwork.java（实现了netWork的接口</strong><br><strong>缓存与重试策略的重点！！</strong><br><strong>原来上次看到这儿就停止了= = 难怪没有看到重试策略</strong><br><strong>而这个重要的函数，就是接口函数中的重写！</strong><br><strong>先复习一下有关缓存的这些变量：</strong></p>
<p><strong>1.request:</strong></p>
<ul>
<li>Cache-Control: max-age=0 以秒为单位</li>
<li>If-Modified-Since: Mon, 19 Nov 2012 08:38:01 GMT 缓存文件的最后修改时间。</li>
<li>If-None-Match: “0693f67a67cc1:0” 缓存文件的Etag值</li>
<li>Cache-Control: no-cache 不使用缓存</li>
<li>Pragma: no-cache 不使用缓存</li>
</ul>
<p><strong>2.response:</strong></p>
<ul>
<li>Cache-Control: public 响应被缓存，并且在多用户间共享</li>
<li>Cache-Control: private 响应只能作为私有缓存，不能在用户之间共享</li>
<li>Cache-Control:no-cache 提醒浏览器要从服务器提取文档进行验证</li>
<li>Cache-Control:no-store 绝对禁止缓存（用于机密，敏感文件）</li>
<li>Cache-Control: max-age=60 60秒之后缓存过期（相对时间）</li>
<li>Date: Mon, 19 Nov 2012 08:39:00 GMT 当前response发送的时间</li>
<li>Expires: Mon, 19 Nov 2012 08:40:01 GMT 缓存过期的时间（绝对时间）</li>
<li>Last-Modified: Mon, 19 Nov 2012 08:38:01 GMT 服务器端文件的最后修改时间</li>
<li>ETag: “20b1add7ec1cd1:0”<br>服务器端文件的Etag值，客户端收到后再次请求时用if-none-match返回，如<br>果etag状态没变，则返回状态304然后不返回</li>
</ul>
<p>x-cache-lookup项指专门查看代理服务器中<strong>是否有</strong>某个网页缓存。有就返回HIT,没有返回MISS。而x-cache项指浏览器从何处、是在哪个代理缓存载入的网页文件。服务器名后的3128指服务器端口。<br>X-Cache :HIT from proxy.domain.tld, MISS from proxy.local<br>X-Cache: 表示你的 http request 是由 proxy server 回的 .</p>
<p>MISS 表 proxy无资料,代理动作, HIT 表 proxy 直接回应</p>
<p><strong>1）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> NetworkResponse <span class="title">performRequest</span><span class="params">(Request\&lt;?\&gt; request)</span> **<span class="keyword">throws</span>**</span></span><br><span class="line"><span class="function">VolleyError </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>方法是执行网络请求的方法，那么理所当然的要进行请求重试也是在这里进行。如何进行请求重试，注意在<strong>方法的内部是用while(true)括起来的</strong>，也就是说如果该方法正常执行完毕或者抛出异常时，必然就跳出循环了，但是如果<strong>请求失败没有return并且在catch内也没有超过重试策略限定条件时</strong>，必然会while(true)下重新请求一次，这样就达到了重试的目的。</p>
<p><strong>这个函数比较长，分为几部分来说：</strong></p>
<p><strong>a.</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Gather headers.</span></span><br><span class="line"></span><br><span class="line">Map&lt;String, String&gt; headers = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向headers这个集合中添加cache entry</span></span><br><span class="line">addCacheHeaders(headers, request.getCacheEntry());---&gt;B</span><br><span class="line"></span><br><span class="line"><span class="comment">// mHttpStack (httpStack接口，有hurlStack类实现）</span></span><br><span class="line"><span class="comment">// 真正进行httpurlconnection 连接和处理 响应的地方，发送了连接请求，并且进行了响应的处理（主要是响应头的处理）</span></span><br><span class="line"></span><br><span class="line">httpResponse = mHttpStack.performRequest(request, headers);</span><br><span class="line">StatusLine statusLine = httpResponse.getStatusLine();</span><br><span class="line"><span class="keyword">int</span> statusCode = statusLine.getStatusCode(); <span class="comment">// 得到响应码</span></span><br><span class="line">responseHeaders = convertHeaders(httpResponse.getAllHeaders());</span><br></pre></td></tr></table></figure></p>
<p>然后通过statusCode判断是否缓存：<br>a.如果是304，那么就是not_modified：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 尝试获得request的entry</span></span><br><span class="line">Entry entry = request.getCacheEntry();</span><br></pre></td></tr></table></figure></p>
<p>如果entry为空，就用networkResponse根据之前的响应头构建响应并返回。<br>否则，就把刚才得到的响应头存到entry的响应头中，然后用新响应头构建响应并返回。</p>
<p>b.如果是301（永久搬迁）或者302（暂时搬迁）<br>那么需要重定向,request根据返回的重定向地址进行设置重定向url<br>String newUrl = responseHeaders.get(“Location”);<br>request.setRedirectUrl(newUrl);</p>
<p>c.可能没有响应体：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">responseContents = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>];</span><br><span class="line"><span class="comment">//有的话转为bytes:</span></span><br><span class="line"><span class="comment">//这里面就用到了bytespool了，似乎加快了内存的利用？但是也导致了无法存储太多东西？？</span></span><br><span class="line">responseContents = entityToBytes(httpResponse.getEntity());---&gt;D</span><br></pre></td></tr></table></figure></p>
<p>d.还可以打印请求花费的时间：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// requestLifetime 代表这个请求已经消耗的时间，可以用Log打印出来。*</span></span><br><span class="line"><span class="keyword">long</span> requestLifetime = SystemClock.elapsedRealtime() - requestStart;</span><br><span class="line">logSlowRequests(requestLifetime, request, responseContents, statusLine);</span><br></pre></td></tr></table></figure></p>
<p>e.如果状态码小于200超过299，直接抛出异常。</p>
<p>最后就是到return了，如果没有continue,异常等的抛出，就可以返回通过network得到的响应了。</p>
<p>3)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">D.<span class="keyword">private</span> <span class="keyword">byte</span>[] entityToBytes(HttpEntity entity) <span class="keyword">throws</span> IOException,</span><br><span class="line">ServerError &#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>终于用到了bytespool。<br>首先构造实体长度的一个bytearrayoutputStream: <strong>mPool就是这个basicNetwork的全局变量，byte池。</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">PoolingByteArrayOutputStream bytes = <span class="keyword">new</span> PoolingByteArrayOutputStream(mPool, (<span class="keyword">int</span>) entity.getContentLength());</span><br><span class="line"><span class="keyword">byte</span>[] buffer = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	InputStream in = entity.getContent();</span><br><span class="line">	<span class="keyword">if</span> (in == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> ServerError();</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//以下，从pool里面遍历mBuffersBySize，</span></span><br><span class="line"><span class="comment">//找到还有多余1024容量的bytes[],从这个数组中取走1024长度的内存，在pool的这个bytes[]中记得把取走的容量减去</span></span><br><span class="line">buffer = mPool.getBuf(<span class="number">1024</span>); ----&gt; byteArrayPool的函数</span><br><span class="line"><span class="keyword">int</span> count;</span><br><span class="line"><span class="comment">// 把inputstream的内容读到buffer中，又把buffer的内容写到函数开始创建的 流bytes中</span></span><br><span class="line"><span class="keyword">while</span> ((count = in.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">	bytes.write(buffer, <span class="number">0</span>, count);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> bytes.toByteArray();</span><br></pre></td></tr></table></figure></p>
<p>2）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">B.</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addCacheHeaders</span><span class="params">(Map&lt;String, String&gt; headers, Cache.Entry entry)</span> </span>&#123;</span><br><span class="line"><span class="comment">// If there's no cache entry, we're done.</span></span><br><span class="line"><span class="keyword">if</span> (entry == <span class="keyword">null</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (entry.etag != <span class="keyword">null</span>) &#123;</span><br><span class="line">	headers.put(<span class="string">"If-None-Match"</span>, entry.etag);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (entry.lastModified &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">// 原来这个地方是entry.serverDate，现在已经改过来了...</span></span><br><span class="line">	Date refTime = <span class="keyword">new</span> Date(entry.lastModified);</span><br><span class="line">		headers.put(<span class="string">"If-Modified-Since"</span>, DateUtils.formatDate(refTime));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>大神解释：<br>Date代表了响应产生的时间，正常情况下Date时间在Last-Modified时间之后,即Date比较晚，也就是Date&gt;=Last-Modified。<br>通过以上原理，既然Date&gt;=Last-Modified。那么我利用Date构建，也是完全正确的。<br>可能的问题出在服务端的 Http 实现上，如果服务端完全遵守 Http语义，采用时间比较的方式来验证If-Modified-Since，判断服务器资源文件修改时间是不是在If-Modified-Since之后。那么使用Date完全正确。<br>我：比如服务端LastModified在8点，Date时间在8点5秒，而客户端传来的If-Modified-Since是在7点，很明显无论如何I-M-S肯定小于L-M和Date,使用服务端的Date来和我们自己的request Entry的L-M-S比较也没关系。<br>可是有的服务端实现不是比较时间，而是直接的判断服务器资源文件修改时间，是否和If-Modified-Since所传时间相等。这样使用Date就不能实现正确的再验证，因为Date的时间总不会和服务器资源文件修改时间相等。<br>我：可以比较相等是因为客户端接收到这次资源的I-M-S等于服务端的L-M。所以如果服务端资源不变，那么L-M不变，还是等于客户端那边的I-M-S</p>
<h3 id="⑤-ExecutorDelivery-java-实现了-ResponseDelivery-，用于把response传送出去"><a href="#⑤-ExecutorDelivery-java-实现了-ResponseDelivery-，用于把response传送出去" class="headerlink" title="⑤ ExecutorDelivery.java 实现了 ResponseDelivery ，用于把response传送出去"></a>⑤ ExecutorDelivery.java 实现了 ResponseDelivery ，用于把response传送出去</h3><p>有一个Excutor成员。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Executor mResponsePoster;</span><br></pre></td></tr></table></figure></p>
<p>1）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ExecutorDelivery</span><span class="params">(<span class="keyword">final</span> Handler handler)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// Make an Executor that just wraps the handler.</span></span><br><span class="line">	mResponsePoster = <span class="keyword">new</span> Executor() &#123;</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">			handler.post(command);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>2）对于接口的重要实现（重要方法，在cache和net调度线程里用来传送响应的<br>最终其实是用excutor执行runnble:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postResponse</span><span class="params">(Request&lt;?&gt; request, Response&lt;?&gt; response)</span> </span>&#123; </span><br><span class="line">	postResponse(request, response, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postResponse</span><span class="params">(Request&lt;?&gt; request, Response&lt;?&gt; response,Runnable runnable)</span> </span>&#123;</span><br><span class="line">	request.markDelivered();</span><br><span class="line">	request.addMarker(<span class="string">"post-response"</span>);</span><br><span class="line">	mResponsePoster.execute(<span class="keyword">new</span> ResponseDeliveryRunnable(request, response, runnable));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> ResponseDeliveryRunnable(request, response, runnable)</span><br></pre></td></tr></table></figure>
<p>很明显是一个runnble，Excutor接口的execute函数在这个类的构造函数<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ExecutorDelivery</span><span class="params">(<span class="keyword">final</span> Handler handler)</span> </span>&#123;&#125;中实现。</span><br></pre></td></tr></table></figure></p>
<h3 id="⑥PoolingByteArrayOutputStream"><a href="#⑥PoolingByteArrayOutputStream" class="headerlink" title="⑥PoolingByteArrayOutputStream"></a>⑥PoolingByteArrayOutputStream</h3><p>继承自ByteArrayOutputStream 。不表。</p>
<h3 id="⑦btyeArrayPool"><a href="#⑦btyeArrayPool" class="headerlink" title="⑦btyeArrayPool"></a>⑦btyeArrayPool</h3><p>byte[]的缓存池，主要就是为了提高用户频繁进行数据请求时的性能，如果用户频繁进行数据请求，对象在很快的时间内创建又被丢弃，明显降低了性能，这里提供了一个一直存在的缓存池，提高了获取堆内存的性能。</p>
<p>两个集合：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> List&lt;<span class="keyword">byte</span>[]&gt; mBuffersByLastUse = <span class="keyword">new</span> LinkedList &lt;<span class="keyword">byte</span>[]&gt;();</span><br><span class="line"><span class="keyword">private</span> List&lt;<span class="keyword">byte</span>[]&gt; mBuffersBySize = <span class="keyword">new</span> ArrayList&lt;<span class="keyword">byte</span>[]&gt;(<span class="number">64</span>);</span><br></pre></td></tr></table></figure></p>
<p>第一个是按照使用顺序存储的byte[]集合，第二个是按照大小存储的byte[]集合。<br>需要用到byte[]时，从这个pool里面取，用完了又归还，提高了性能。</p>
<p>关于优缺点：<br>问题一、为什么不适合下载大文件，只适合数据量小的频繁请求？<br>1）存储时，从btyeArrayPool中取出一块已经分配的内存，这样不用每次都进行内存分配，而是先查找缓冲池中有没有合适的内存区域，有的话可以直接使用，减少了内存分配的次数。<br>如果数据量过大，byteArrayPool这个存储空间就会溢出。</p>
<p>2）线程池大小默认为4，如果上传数据大或者下载数据大，浪费比较长的时间，占用了线程，其余请求就会阻塞。</p>
<p>问题二、缓存机制（BasicNetwork.java)<br>只使用了Date来进行缓存验证（原来是这样，现在改了）<br>在BasicNetwork.java中：</p>
<h3 id="⑧-HttpHeaderParser-java"><a href="#⑧-HttpHeaderParser-java" class="headerlink" title="⑧ HttpHeaderParser.java"></a>⑧ HttpHeaderParser.java</h3><p><strong>(你亲自读过的呀… 注意重点是复习…复习，理解！！ ）</strong><br><strong>通过解析服务器返回的响应头部，构建保存的缓存请求的头部（ Cache.Entry）</strong>，比如<br>解析http头部的方法，有三个。</p>
<p>1）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Cache.<span class="function">Entry <span class="title">parseCacheHeaders</span><span class="params">(NetworkResponse response)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>首先，“DATE”，</strong>用parseDateAsEpoch（）把时间解析成EPOCH格式，响应生成时间。于是得到serverDate。</p>
<p><strong>第二，”Cache-Control”：</strong>有这个值，意味着hasCacheControl = true;，那么判断完头部，还要去设置<br>softExpire和finalExpire这两个值。</p>
<p>a.如果是no-cache或者no-store，就不缓存结果。前者是要从服务器提取文档进行验证。后者是绝对禁止缓存，用于机密文件2333</p>
<p>b.max-age开头：得到max-age。相对时间，多少秒之后过期。<br>比如max-age = 60，那么60秒之后缓存过期。</p>
<p>c.stale-while-revalidate 开头：得到stale-while-revalidate.RFC文档解释：<br>When present in an HTTP response, the stale-while-revalidate Cache- Control<br>extension indicates that caches MAY serve the response in which it appears after<br>it becomes stale, up to the indicated number of seconds.<br>也就是说，到达给定的时间后，服务器可能会返回新的内容。（也就是这个时间过后这个响应就陈旧了，所以会发新的过来）</p>
<p>d.如果是must-revalidate, 作用与no-cache相同，但更严格，强制意味更明显。但这只是理论上的描述。或者是proxy-revalidate，都是强制刷新。<br>于是mustRevalidate = true;</p>
<p><strong>第三，“Expires”，</strong>用parseDateAsEpoch（）把的时间解析成EPOCH格式。于是得到serverExpires。<strong>缓存过期的绝对时间，</strong>所以要取缓存时用到的isExpired()函数是这样写的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果缓存过期，返回true</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isExpired</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.ttl &lt; System.currentTimeMillis();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>第四，“Last-Modified“，</strong>用parseDateAsEpoch（）把的时间解析成EPOCH格式。于是得到lastModified。（<strong>客户端用if-not-modified返回</strong>，如果服务端文件在这个时间之后都没修改，那么返回304）</p>
<p><strong>第五，”ETag”，</strong>得到serverEtag（如果客户端用if-none-match加上etag的内容发回，服务端etag没变的话，返回状态304，内容不更新）</p>
<p>然后要看有没有cachecontrol的控制：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Cache-Control takes precedence over an Expires header, even if both exist and Expires is more restrictive.过期时间， Cache-Control比Expires优先级高。*/</span></span><br><span class="line"><span class="keyword">if</span> (hasCacheControl) &#123;</span><br><span class="line">	softExpire = now + maxAge * <span class="number">1000</span>; <span class="comment">//新鲜度时间，maxAge是秒为单位，但是开发时是毫秒为单位</span></span><br><span class="line">	finalExpire = mustRevalidate ? softExpire : softExpire + staleWhileRevalidate * <span class="number">1000</span>; <span class="comment">// 过期时间</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (serverDate &gt; <span class="number">0</span> &amp;&amp; serverExpires &gt;= serverDate) &#123;</span><br><span class="line">	<span class="comment">//没有cacheControl</span></span><br><span class="line">	<span class="comment">//Default semantic for Expire header in HTTP specification is softExpire.</span></span><br><span class="line">	softExpire = now + (serverExpires - serverDate); </span><br><span class="line">	<span class="comment">//现在时间+过期的绝对时间-生成文件的时间，因为serverExpires - serverDate代表从发送时的时间到过期时间还有多少时间T，这段时间过后就是过期了。</span></span><br><span class="line">	<span class="comment">//这是软过期时间，意味着从接受到响应开始（now),一定还可以保存T那么长的时间。</span></span><br><span class="line">	finalExpire = softExpire;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 各个值终于算好了，全部赋值给cache.entry，这样就用entry保存了这个request对应的cache</span></span><br></pre></td></tr></table></figure>
<p>印象最深的地方：</p>
<p>1）接口的使用很厉害(读到最后才明白这个妙处）<br>比如新建一个requsertQueue的时候，cache和network在volley.java的newRequestQueue里面是一定要有的，通常来说 ResponseDelivery delivery这个参数是可以不自己定义的，那么它就是这个值：</p>
<p>A.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">RequestQueue</span><span class="params">(Cache cache, Network network, <span class="keyword">int</span> threadPoolSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(cache, network, threadPoolSize,</span><br><span class="line">            <span class="keyword">new</span> ExecutorDelivery(<span class="keyword">new</span> Handler(Looper.getMainLooper())));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>将ExcutorDelivery和UI线程的handler绑定起来，</p>
<p>所以在ExDel的构造函数中，实现了Excutror接口中的函数excute，这个函数就是调用主线程的handler去处理Runn.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ExecutorDelivery</span><span class="params">(<span class="keyword">final</span> Handler handler)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Make an Executor that just wraps the handler.</span></span><br><span class="line">    <span class="comment">// 新建实例的时候重写接口方法，但是也是要.excute才会运行的...不是说实例建了就开始运行...</span></span><br><span class="line">    mResponsePoster = <span class="keyword">new</span> Executor() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">            handler.post(command);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当然了，这只是构造函数中，那么这个excute何时被调用呢….？？我们读到response的时候就会解开谜底。去到B！</p>
<p>这个ExcutorDel本身也是 接口的实现！！重载了这个函数：</p>
<p>可以看到，runnble经过了一点改造，在</p>
<p>private class ResponseDeliveryRunnable implements Runnable {}<br>中，除了本身的runnalbe要被run外，还有增加了：</p>
<p>C.<br>对runnable进行了一点改造，用来<strong>在request的类的delResponse函数中调用我们的回调接口！</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (mResponse.isSuccess()) &#123;</span><br><span class="line">	mRequest.deliverResponse(mResponse.result);</span><br></pre></td></tr></table></figure></p>
<p>有了这一句，才会在<strong>各个xxxRequest类中，重载request类的deliverResponse函数</strong>，onResponse是什么呢。。。就是调用了我们自己设置的onResponse函数，这样就可以干我们想做的事了….所以其实最后的response的回调显示也是在各个request中完成的。</p>
<p>在每个xxxRequest中都重写了这个函数：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">deliverResponse</span><span class="params">(String response)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mListener != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mListener.onResponse(response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>B.在A中（Request的时候）构造好了，最终postResponse的时候才会用。比如在networdDispatch这个线程中，终于从网络取到了线程，<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mDelivery.postResponse(request, response);</span><br></pre></td></tr></table></figure></p>
<p>这个mDelivery就是每个request的response的传送者~<br>mDelivery 是一个ResponseDelivery，而我们刚才提到的ExcutorDelivery是这个抽象类的实现。<br>所以mDelivery.postResponse其实是调用了ExcutorDelivery里面的postResponse.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postResponse</span><span class="params">(Request&lt;?&gt; request, Response&lt;?&gt; response, Runnable runnable)</span> </span>&#123;</span><br><span class="line">    request.markDelivered();</span><br><span class="line">    request.addMarker(<span class="string">"post-response"</span>);</span><br><span class="line">    mResponsePoster.execute(<span class="keyword">new</span> ResponseDeliveryRunnable(request, response, runnable));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而这个postResponse做了什么呢？它终于，调用了ExcutorDelivery。构造函数里面的Excutor接口实现的excute函数，刚才我们分析得知，这个excute会把传入的runnable用handler去执行里面的run（），而这个runnable其实被暗自改造了~~我们刚才刚才分析过了。</p>
<p>在cacheDispatcher这个线程的run中，得到response后，结果就是通过postResponse返回去的！这个设计真的很精妙= =！！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mDelivery.postResponse(request, response, <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mNetworkQueue.put(finalRequest);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="comment">// Not much we can do about this.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>还有就是各个xxxRequest，除了传入url外，实现了response类中的两个回调接口<br>Listener<t> 和ErrorListener，request和response的结合，一开始就想好了最后 - -很巧妙啊。（其实刚才哪一篇叙述已经讲到了）</t></p>
<p>重试机制：<br>volley的重试策略是在request构造函数里面确定的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Request</span><span class="params">(<span class="keyword">int</span> method, String url, Response.ErrorListener listener)</span> </span>&#123;</span><br><span class="line">    mMethod = method;</span><br><span class="line">    mUrl = url;</span><br><span class="line">    mIdentifier = createIdentifier(method, url);</span><br><span class="line">    mErrorListener = listener;</span><br><span class="line">    setRetryPolicy(<span class="keyword">new</span> DefaultRetryPolicy());</span><br><span class="line">    mDefaultTrafficStatsTag = findDefaultTrafficStatsTag(url);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>首先new出来的东西是一个DefaultRetryPolicy：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultRetryPolicy</span> <span class="keyword">implements</span> <span class="title">RetryPolicy</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个类有什么呢，它其实不是执行重试操作，只是更新有关重试的两个变量。</p>
<p>成员变量：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The current timeout in milliseconds. 当前超时时间 </span></span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">int</span> mCurrentTimeoutMs;  </span><br><span class="line"></span><br><span class="line">      <span class="comment">// The current retry count. 当前重试次数  </span></span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">int</span> mCurrentRetryCount;  </span><br><span class="line"></span><br><span class="line">      <span class="comment">// The maximum number of attempts. 最大重试次数 </span></span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> mMaxNumRetries;  </span><br><span class="line"></span><br><span class="line">      <span class="comment">// The backoff multiplier for for the policy. 表示每次重试之前的 timeout 该乘以的因子，每重试一次，超时时间就变化一次</span></span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">float</span> mBackoffMultiplier;  </span><br><span class="line"></span><br><span class="line">      <span class="comment">// The default socket timeout in milliseconds 默认超时时间</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_TIMEOUT_MS = <span class="number">5000</span>;  </span><br><span class="line"></span><br><span class="line">      <span class="comment">// The default number of retries  默认最大重试次数</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_MAX_RETRIES = <span class="number">1</span>;</span><br></pre></td></tr></table></figure></p>
<p>除此之外只有两个函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">更新当前请求重试次数，并且更新当前超时时间</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">retry</span><span class="params">(VolleyError error)</span> <span class="keyword">throws</span> VolleyError </span>&#123;</span><br><span class="line">	mCurrentRetryCount++;</span><br><span class="line">	mCurrentTimeoutMs += (**mCurrentTimeoutMs * mBackoffMultiplier);</span><br><span class="line">	<span class="keyword">if</span> (!hasAttemptRemaining()) &#123;</span><br><span class="line">		<span class="keyword">throw</span> error;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而以下函数是判断当前重试次数是否超过最大请求数：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">hasAttemptRemaining</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> mCurrentRetryCount &lt;= mMaxNumRetries;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>set函数里，只是设置了重试策略：mRetryPolicy = 构造的这个retryPolicy对象。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/07/各种设置“/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ke Yu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coco">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/07/各种设置“/" itemprop="url">各种设置</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-09-07T13:22:49+08:00">
                2017-09-07
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Ke Yu</p>
              <p class="site-description motion-element" itemprop="description">Keep moving.Don't settle.</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">34</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">7</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">47</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Ke Yu</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
