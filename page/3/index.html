<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="en">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="Keep moving. Don&apos;t settle.">
<meta property="og:type" content="website">
<meta property="og:title" content="Coco">
<meta property="og:url" content="http://yoursite.com/page/3/index.html">
<meta property="og:site_name" content="Coco">
<meta property="og:description" content="Keep moving. Don&apos;t settle.">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Coco">
<meta name="twitter:description" content="Keep moving. Don&apos;t settle.">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/3/"/>





  <title>Coco</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Coco</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Hello world</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/06/Android四大组件----Activity（1）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ke Yu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coco">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/06/Android四大组件----Activity（1）/" itemprop="url">Activity(1)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-09-06T14:09:30+08:00">
                2017-09-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Android四大组件—-Activity（1）"><a href="#Android四大组件—-Activity（1）" class="headerlink" title="Android四大组件—-Activity（1）"></a>Android四大组件—-Activity（1）</h1><ul>
<li><p><a href="#Android四大组件----Activity（1）-简介">简介</a></p>
<ul>
<li><a href="#Android四大组件----Activity（1）-Activity的主要作">Activity的主要作用</a></li>
</ul>
</li>
<li><p><a href="#Android四大组件----Activity（1）-通信方式（待续）">通信方式（待续）</a></p>
</li>
<li><p><a href="#Android四大组件----Activity（1）-关联处理">关联处理</a></p>
<ul>
<li><p><a href="#Android四大组件----Activity（1）-关联起作用的两种情况">关联起作用的两种情况</a></p>
<ul>
<li><p><a href="#Android四大组件----Activity（1）-启动Activity的I">启动Activity的Intent包含FLAG_ACTIVITY_NEW_TASK</a></p>
</li>
<li><p><a href="#Android四大组件----Activity（1）-Activity的all">Activity的allowTaskReparenting属性被设置为”true”</a></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><a href="#Android四大组件----Activity（1）-加载方式">加载方式</a></p>
<ul>
<li><p><a href="#Android四大组件----Activity（1）-使用清单文件">使用清单文件</a></p>
<ul>
<li><p><a href="#Android四大组件----Activity（1）-singleTop">singleTop</a></p>
</li>
<li><p><a href="#Android四大组件----Activity（1）-singleTask">singleTask</a></p>
</li>
<li><p><a href="#Android四大组件----Activity（1）-singleInstan">singleInstance</a></p>
</li>
<li><p><a href="#Android四大组件----Activity（1）-singleTop和si">singleTop和singleTask的区别</a></p>
</li>
</ul>
</li>
<li><p><a href="#Android四大组件----Activity（1）-使用intentFlag">使用intent Flag</a></p>
<ul>
<li><p><a href="#Android四大组件----Activity（1）-FLAG_ACTIVIT">FLAG_ACTIVITY_NEW_TASK</a></p>
</li>
<li><p><a href="#Android四大组件----Activity（1）-FLAG_ACTIVIT">FLAG_ACTIVITY_SINGLE_TOP</a></p>
</li>
<li><p><a href="#Android四大组件----Activity（1）-FLAG_ACTIVIT">FLAG_ACTIVITY_CLEAR_TOP</a></p>
</li>
<li><p><a href="#Android四大组件----Activity（1）-SINGLE_TOP和C">SINGLE_TOP和CLEART_TOP的配合使用</a></p>
<ul>
<li><p><a href="#Android四大组件----Activity（1）-为什么？">为什么？</a></p>
</li>
<li><p><a href="#Android四大组件----Activity（1）-可能出现的Bug">可能出现的Bug</a></p>
</li>
</ul>
</li>
<li><p><a href="#Android四大组件----Activity（1）-NEW_TASK和CLE">NEW_TASK和CLEART_TOP的配合使用</a></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><a href="#Android四大组件----Activity（1）-Lifecycle">Lifecycle</a></p>
<ul>
<li><p><a href="#Android四大组件----Activity（1）-生命状态">生命状态</a></p>
</li>
<li><p><a href="#Android四大组件----Activity（1）-LifeTime">LifeTime</a></p>
</li>
<li><p><a href="#Android四大组件----Activity（1）-生命周期方法">生命周期方法</a></p>
</li>
</ul>
</li>
<li><p><a href="#Android四大组件----Activity（1）-状态保存与恢复">状态保存与恢复</a></p>
<ul>
<li><p><a href="#Android四大组件----Activity（1）-onSaveInstan">onSaveInstanceState()</a></p>
</li>
<li><p><a href="#Android四大组件----Activity（1）-onRestoreIns">onRestoreInstanceState()或onCreate()</a></p>
</li>
</ul>
</li>
<li><p><a href="#Android四大组件----Activity（1）-参考资料">参考资料</a></p>
</li>
</ul>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><h4 id="Activity的主要作用"><a href="#Activity的主要作用" class="headerlink" title="Activity的主要作用"></a>Activity的主要作用</h4><ul>
<li><p>显示UI</p>
</li>
<li><p>和用户进行交互，对用户的操作进行监听并响应</p>
</li>
</ul>
<h3 id="通信方式（待续）"><a href="#通信方式（待续）" class="headerlink" title="通信方式（待续）"></a>通信方式（待续）</h3><p>1.Activity之间的通信</p>
<p>2.Activity和Service之间的通信</p>
<p>3.Activity和Fragment之间的通信</p>
<h3 id="关联处理"><a href="#关联处理" class="headerlink" title="关联处理"></a>关联处理</h3><p>关联代表Activity属于哪个Task，默认情况下，同一个应用中的所有Activities属于一个Task，但是可以通过<activity>元素的taskAffinity属性修改任何给定Activity的关联任务。</activity></p>
<p>该属性值必须不同于<manifest>元素中默认的软件包名。</manifest></p>
<h4 id="关联起作用的两种情况"><a href="#关联起作用的两种情况" class="headerlink" title="关联起作用的两种情况"></a>关联起作用的两种情况</h4><h5 id="启动Activity的Intent包含FLAG-ACTIVITY-NEW-TASK"><a href="#启动Activity的Intent包含FLAG-ACTIVITY-NEW-TASK" class="headerlink" title="启动Activity的Intent包含FLAG_ACTIVITY_NEW_TASK"></a>启动Activity的Intent包含FLAG_ACTIVITY_NEW_TASK</h5><ul>
<li><p>默认情况下，存在此FLAG时，Activity通常会被放入新的Task中，但如果使用了taskAffinity将它与现有Task关联，Activity会在现有Task中启动，否则会开始新的Task（singleTask的实验证明了不会有新的Task，这里待定）。</p>
</li>
<li><p>如果使用此FLAG使得Activity开始新任务，当用户按“home”按钮离开时，必须为用户提供回到任务的方式。比如通知管理器所启动的Activity都是在别的Task中。</p>
</li>
</ul>
<h5 id="Activity的allowTaskReparenting属性被设置为”true”"><a href="#Activity的allowTaskReparenting属性被设置为”true”" class="headerlink" title="Activity的allowTaskReparenting属性被设置为”true”"></a>Activity的allowTaskReparenting属性被设置为”true”</h5><ul>
<li><p>Activity可以从它当前所在的Task移动到与其具有关联的任务。</p>
</li>
<li><p>比如一个天气预报Activity，它默认与旅行应用关联。如果不是这个应用的其他某个Activity启动了这个天气预报，之后旅行应用又启动了这个天气预报，那么天气预报Activity会被重新分配到旅行应用的Task。疑问：这样的意义何在？？</p>
</li>
</ul>
<h3 id="加载方式"><a href="#加载方式" class="headerlink" title="加载方式"></a>加载方式</h3><p>当Activity A用设置intent flag的方式定义了Activity<br>B应当如何和任务关联，而Activity B又在清单中设置了launchMode，那么Activity A的设置优先级高于B的设置。也就是Intent flag的优先级大于launchMode</p>
<h4 id="使用清单文件"><a href="#使用清单文件" class="headerlink" title="使用清单文件"></a>使用清单文件</h4><p>共有四种，主要是控制Activity的创建模式。</p>
<p><strong>standard</strong></p>
<ul>
<li><p>如果intent来自同一个应用，且Activity没指定taskAffinity，那么生成Activity的新实例放在发出启动请求的Activity所在的Task顶端。</p>
</li>
<li><p>如果intent来自其他应用，那么会生成这个Activity的新实例，并以这个Activity为根创建一个新的Task</p>
</li>
</ul>
<blockquote>
<p>  使用场景：</p>
</blockquote>
<ul>
<li><p>大多数撰写邮件或者发布社交网络状态的Activity。此时每个Activity实例服务于一个intent。比如从别的应用分享内容给微信朋友，跳到了那个选择联系人的list，这个页面很可能符合这种场景。</p>
<p>可能出现的Bug：</p>
</li>
<li><p>使用ApplicationContext去启动standard模式的Activity会出现报错<br>因为standard模式的Activity会默认进入启动它的Activity所属的任务栈中，但是非Activity类型的Context没有所谓的任务栈。（why，因为任务栈是对于Activity来说的呀，而不是Application)<br>solution：使用FLAG_ACTIVITY_NEW_TASK启动Activity，启动的时候Activity就会进入新的Task。</p>
</li>
</ul>
<h5 id="singleTop"><a href="#singleTop" class="headerlink" title="singleTop"></a>singleTop</h5><ul>
<li><p>如果intent来自同一个应用，视栈顶是否有它的实例而定。如果已经有实例在栈顶了(发起启动的和已经启动的Task中），就不产生新实例，会通过<br>onNewIntent()把intent发送给现有的实例；如果有实例但不位于栈顶，就再创建新的实例并放入栈顶(实例可能重复）</p>
</li>
<li><p>如果intent来自其他应用，那么会生成这个Activity的新实例，并以这个Activity为根创建一个新的Task。  </p>
<p>使用场景：</p>
</li>
<li><p>新闻类或者阅读类App的内容页面。在读新闻的时候，来了个该新闻APP的消息通知，点击这个通知就会打开新闻APP，由于此时这个App实例位于栈顶，那么此时就直接调用onNewintent()，无需产生新的实例</p>
</li>
<li><p>搜索功能的页面。在带有搜索功能的页面中，如果每次搜索都生成新的Activity，那么我们想回到最初搜索前的页面，就需要按很多次Back，但如果使用singleTop模式，每次搜索时，把intent发送给现有的Activity，更新搜索结果即可，只需要一次Back就可以回到搜索前的页面。</p>
</li>
</ul>
<h5 id="singleTask"><a href="#singleTask" class="headerlink" title="singleTask"></a>singleTask</h5><ul>
<li>如果intent来自同一个应用，如果栈中<strong>存在这个Activity的实例</strong>就会复用这个Activity，不管它是否位于栈顶，复用时，会将它上面的Activity全部出栈，并且将intent发送给该实例的onNewIntent()方法；如果当前栈没有这个实例，就新建一个，并且放在栈顶。（官方文档说是创建新Task并且以他为根，实验证明这种说法不完全正确）。</li>
</ul>
<blockquote>
<p>  疑问：当前栈没有实例以及别的栈也没有实例，究竟是否一样结果？是新建后放栈顶，还是以实例为根创建Task？待实验证明。</p>
</blockquote>
<blockquote>
<p>  实验：</p>
</blockquote>
<blockquote>
<p>  1）同一个应用下，两个Stack，我们的应用在Stack#1，其中已经有一个Task，<strong>没有设置taskAffinity</strong>，所有栈中都没有要找的Act。从.mainActivity跳转到另一个模式为singleTask的TestAct中，利用adb命令可以看到，Act新建后放到当前Task顶端。没有以实例为根创建新的Task。</p>
</blockquote>
<blockquote>
<p>  2）同一个应用下，两个Stack，我们的应用在Stack#1，其中已经有一个Task，<strong>设置了TestAct的taskAffinity</strong>，所有栈中都没有要找的Act。通过adb命令可以看到，在当前Stack中新建了一个Task，也就是以新建的Activity为根创建了Task。</p>
</blockquote>
<blockquote>
<p>  猜想：</p>
</blockquote>
<blockquote>
<p>  如果设置了taskAffinity，当前Task没有实例，就找它想要的Task，查找是否有与这个Activity相同taskAffinity的Task已经存在。如果不存在，创建实例时以这个Activity为根创建一个新的Task，这个新的实例就在这个Task中，以后每次调动都不会产生新的实例；如果存在Task，就再看是否有实例从而决定是复用还是新建。</p>
</blockquote>
<blockquote>
<p>  但如果没有设置taskAffinity这个属性，它默认和当前应用处于一个Task，所以直接查找发出intent的当前Task，如果找不到就直接在当前Task顶端新建实例。</p>
</blockquote>
<blockquote>
<p>  注意的是，<strong>虽然系统创建了一个新的Task，但是只要按下返回键还是会回到原来的Activity</strong>。</p>
</blockquote>
<ul>
<li><p>如果intent来自别的应用，无论哪个Task存在这个Activity的实例都会复用这个Activity，不管它是否位于栈顶，复用时，会将它上面的Activity全部出栈，并且将intent发送给该实例的onNewIntent()方法；如果系统中（当前栈和别的Task）都没有这个Activity的实例，那么就创建新实例并以它为根创建新的Task。</p>
<p>  使用场景：</p>
</li>
<li><p>浏览器的主界面。不管从多少个应用启动浏览器，只会启动主界面一次，其余情况都会走onNewIntent()，同时会清空主界面上面的其他页面。</p>
</li>
<li><p>邮件客户端的收件箱。不管从哪个应用进入收件箱，都会结束客户端中别的页面，进入到收件箱页面。</p>
</li>
</ul>
<h5 id="singleInstance"><a href="#singleInstance" class="headerlink" title="singleInstance"></a>singleInstance</h5><ul>
<li><p>和singleTask类似，不但要创建一个新的Task，而且该Task中只能有这个实例。其效果相当于多个应用共享一个应用，不管谁激活该Activity 都会进入同一个应用中。</p>
<p>  使用场景：</p>
</li>
<li><p>几乎不使用这种模式，除非是100%确定这个应用只有一个Activity。</p>
</li>
<li><p>闹铃提醒，将闹铃提醒与闹铃设置分离。此时要保证这个应用只有闹铃提醒这个Act。</p>
</li>
</ul>
<h5 id="singleTop和singleTask的区别"><a href="#singleTop和singleTask的区别" class="headerlink" title="singleTop和singleTask的区别"></a>singleTop和singleTask的区别</h5><p>当已经存在要启动的Activity时</p>
<ul>
<li><p>如果它在栈顶，那么都会把intent发送给onNewIntent()。</p>
</li>
<li><p>如果它不在栈顶，singleTop会在栈顶新建实例，而singleTask会把这个Activity上面的实例弹出，再发送intent给栈顶的这个Activity。<br><strong><em>也就是说，singleTop会造成重复的实例</em></strong>。</p>
</li>
</ul>
<h4 id="使用intent-Flag"><a href="#使用intent-Flag" class="headerlink" title="使用intent Flag"></a>使用intent Flag</h4><h5 id="FLAG-ACTIVITY-NEW-TASK"><a href="#FLAG-ACTIVITY-NEW-TASK" class="headerlink" title="FLAG_ACTIVITY_NEW_TASK"></a>FLAG_ACTIVITY_NEW_TASK</h5><p>与singleTask有相同行为。</p>
<h5 id="FLAG-ACTIVITY-SINGLE-TOP"><a href="#FLAG-ACTIVITY-SINGLE-TOP" class="headerlink" title="FLAG_ACTIVITY_SINGLE_TOP"></a>FLAG_ACTIVITY_SINGLE_TOP</h5><p>与singleTop有相同行为。</p>
<h5 id="FLAG-ACTIVITY-CLEAR-TOP"><a href="#FLAG-ACTIVITY-CLEAR-TOP" class="headerlink" title="FLAG_ACTIVITY_CLEAR_TOP"></a>FLAG_ACTIVITY_CLEAR_TOP</h5><p>如果已经有了Activity实例，那么就会销毁Task中当前Activity之上的所有Activity，然后把intent发送给已经位于Task顶端的Act实例的onNewIntent()。</p>
<h5 id="SINGLE-TOP和CLEART-TOP的配合使用"><a href="#SINGLE-TOP和CLEART-TOP的配合使用" class="headerlink" title="SINGLE_TOP和CLEART_TOP的配合使用"></a>SINGLE_TOP和CLEART_TOP的配合使用</h5><h6 id="为什么？"><a href="#为什么？" class="headerlink" title="为什么？"></a>为什么？</h6><pre><code>如果要启动的Activity为”standard&quot;：
</code></pre><ul>
<li><p>只使用CLEAR_TOP，想要启动的Activity已存在时，该实例<strong>以及</strong>它上面的Activity会被销毁，然后创建新实例(onCreate())</p>
</li>
<li><p>配合SINGLE_UP使用<strong>或者</strong>要启动的Activity为<strong>“standard”之外</strong>的模式，想要启动的Activity已存在时，该实例不会被销毁，只有它上面的实例会被销毁，然后调用onNewIntent()</p>
</li>
<li><p>详情：</p>
</li>
</ul>
<p><a href="https://stackoverflow.com/questions/31926315/why-do-people-like-to-pair-clear-top-and-single-top-in-android" target="_blank" rel="noopener">https://stackoverflow.com/questions/31926315/why-do-people-like-to-pair-clear-top-and-single-top-in-android</a><br><a href="https://developer.android.com/reference/android/content/Intent.html#FLAG_ACTIVITY_CLEAR_TOP" target="_blank" rel="noopener">https://developer.android.com/reference/android/content/Intent.html#FLAG_ACTIVITY_CLEAR_TOP</a></p>
<h6 id="可能出现的Bug"><a href="#可能出现的Bug" class="headerlink" title="可能出现的Bug"></a>可能出现的Bug</h6><p>问题：<a href="https://stackoverflow.com/questions/5489592/single-top-clear-top-seem-to-work-95-of-the-time-why-the-5" target="_blank" rel="noopener">https://stackoverflow.com/questions/5489592/single-top-clear-top-seem-to-work-95-of-the-time-why-the-5</a></p>
<p>有人回答道这涉及到并发问题，如果CLEAR_UP和SINGLE_TOP被同时读取，CLEAR_UP会调用onCreate()，SINGLE_UPC此时也没有找到Act，也调用onCreate()，造成一个Activity同时创建两次。</p>
<p>存疑：逻辑或 | ，运算优先级为从左到右，会发生同时读取两个条件的情况吗？</p>
<p>猜想：此时intent进行setFlags，不是简单的立刻进行false/true的判断，而是需要使用这两个参数，所以可能在启动过程中，对参数进行读取，然后根据参数进行相应的操作。结合对启动过程的了解，答案应该还是在ActivityStack.startActivityUncheckedLocked中。</p>
<h5 id="NEW-TASK和CLEART-TOP的配合使用"><a href="#NEW-TASK和CLEART-TOP的配合使用" class="headerlink" title="NEW_TASK和CLEART_TOP的配合使用"></a>NEW_TASK和CLEART_TOP的配合使用</h5><ul>
<li>如果在一个Task的根Act中使用这个FLAGS,可以找到当前Task中运行的Activity实例并使它在前台运行，并且清除这个根Act和需要的Activity之外的其余实例。</li>
</ul>
<h3 id="Lifecycle"><a href="#Lifecycle" class="headerlink" title="Lifecycle"></a>Lifecycle</h3><h4 id="生命状态"><a href="#生命状态" class="headerlink" title="生命状态"></a>生命状态</h4><ul>
<li><p>活动（running）状态：当Activity处于可见，位于屏幕前台，获得焦点，正在和用户进行交互时为活动状态，此时它位于任务栈的最顶端。</p>
</li>
<li><p>暂停状态：Activity半可见或者透明时（比如出现了toast、alertdialog等时），它没有焦点，无法和用户进行交互，此时活动仍是存活的，它保留着所有的状态和成员信息。系统内存资源不够时可能被杀死。</p>
</li>
<li><p>停止状态：完全不可见时为停止状态，但仍保持所有的状态和成员信息。随时可能会被系统杀死。</p>
</li>
<li><p>非活动状态：Activity处于暂停或停止状态，Activity被手动终止，或者被系统回收资源时,可以称为非活动状态。</p>
</li>
</ul>
<h4 id="LifeTime"><a href="#LifeTime" class="headerlink" title="LifeTime"></a>LifeTime</h4><ul>
<li>entiere lifetime：调用onCreate()到相应的调用onDestroy()</li>
</ul>
<ul>
<li>visible lifetime: 调用onStart()到相应的调用onStop()</li>
</ul>
<ul>
<li>foreground lifetime：调用onResume()到相应的调用onPause()</li>
</ul>
<h4 id="生命周期方法"><a href="#生命周期方法" class="headerlink" title="生命周期方法"></a><strong>生命周期方法</strong></h4><p><strong>      以下六个方法从外向内两两对应：</strong></p>
<ul>
<li><p>onCreate（）：活动第一次启动时会首先调用该方法</p>
</li>
<li><p>onStart（）：有一个参数，可能为null， 或者是onSaveInstanceState()<br>保存的状态信息。<br>启动后或者当活动从停止状态转到活动状态时会调用该方法。onStart（）是activity界面被显示出来的时候执行的，用户可见，包括有一个activity在他上面，但没有将它完全覆盖，用户可以看到部分activity但不能与它交互。</p>
</li>
<li><p>onResume（）：活动和用户进行交互时会调用该方法，当从pause状态转为活动状态时回调该方法，是当该activity与用户能进行交互时被执行，用户可以获得activity的焦点，能够与用户交互。</p>
</li>
<li><p>onPause（）：一个活动在前台运行时，别的活动需要前台运行，这时该活动会保存当前状态信息，活动变为暂停状态</p>
</li>
<li><p>onStop（）：活动不需要展示给用户时触发该方法，活动变为停止状态</p>
</li>
<li><p>onDestroy（）：活动停止时调用该方法</p>
</li>
</ul>
<ul>
<li>onRestart（）：活动从停止状态转为活动状态时调用该方法</li>
</ul>
<p>onStart()和onResume()区别：</p>
<ul>
<li><p>onStart()通常就是onStop()（也就是用户按下了home键，activity变为后台后），之后用户再切换回这个Activity就会调用onRestart()而后调用onStart()</p>
</li>
<li><p>onResume()是onPause()（通常是当前的Activity被暂停了，比如被另一个透明或者Dialog样式的Activity覆盖了），之后dialog取消，activity回到可交互状态，调用onResume()。</p>
</li>
</ul>
<h3 id="状态保存与恢复"><a href="#状态保存与恢复" class="headerlink" title="状态保存与恢复"></a>状态保存与恢复</h3><p>Activity遇到意外被关闭时，需要对一些状态如文本输入、ListView位置进行记录</p>
<h4 id="onSaveInstanceState"><a href="#onSaveInstanceState" class="headerlink" title="onSaveInstanceState()"></a>onSaveInstanceState()</h4><pre><code>1）在回调onStop()之前调用

2）与onPause()的调用顺序不一定
</code></pre><p>  3）只有当Activity可能会重建时，比如系统资源不足或者配置改变导致Activity关闭时，才会调用该函数</p>
<h4 id="onRestoreInstanceState-或onCreate"><a href="#onRestoreInstanceState-或onCreate" class="headerlink" title="onRestoreInstanceState()或onCreate()"></a>onRestoreInstanceState()或onCreate()</h4><pre><code>1）onRestoreInstanceState()在回调onStart()之后调用，此时Bundle一定不为null

2）回调onCreate()时Bundle可能为null，所以需要进行判断
</code></pre><p> 3）根据两者差异，如果需要根据Activity是第一次创建还是重建进行不同的初始化操作，可以使用onCreate()</p>
<p> 4）官方文档建议使用onRestoreInstanceState()，有利于继承这个Activity的子类决定是否使用父类的状态恢复实现</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://inthecheesefactory.com/blog/understand-android-activity-launchmode/en" target="_blank" rel="noopener">https://inthecheesefactory.com/blog/understand-android-activity-launchmode/en</a></p>
<p><a href="https://developer.android.com/reference/android/app/Activity.html" target="_blank" rel="noopener">https://developer.android.com/reference/android/app/Activity.html</a></p>
<p><a href="https://developer.android.com/guide/components/tasks-and-back-stack.html?hl=zh-cn" target="_blank" rel="noopener">https://developer.android.com/guide/components/tasks-and-back-stack.html?hl=zh-cn</a></p>
<p><a href="https://stackoverflow.com/questions/4342761/how-do-you-use-intent-flag-activity-clear-top-to-clear-the-activity-stack" target="_blank" rel="noopener">https://stackoverflow.com/questions/4342761/how-do-you-use-intent-flag-activity-clear-top-to-clear-the-activity-stack</a></p>
<p><a href="https://stackoverflow.com/questions/12683779/are-oncreate-and-onrestoreinstancestate-mutually-exclusive" target="_blank" rel="noopener">https://stackoverflow.com/questions/12683779/are-oncreate-and-onrestoreinstancestate-mutually-exclusive</a></p>
<p><a href="https://developer.android.com/reference/android/app/Activity.html#onSaveInstanceState(android.os.Bundle)" target="_blank" rel="noopener">https://developer.android.com/reference/android/app/Activity.html#onSaveInstanceState(android.os.Bundle)</a></p>
<p><a href="https://developer.android.com/reference/android/app/Activity.html#onRestoreInstanceState(android.os.Bundle)" target="_blank" rel="noopener">https://developer.android.com/reference/android/app/Activity.html#onRestoreInstanceState(android.os.Bundle)</a></p>
<p><a href="https://www.reddit.com/r/androiddev/comments/2afx13/onrestoreinstancestate_vs_oncreate/" target="_blank" rel="noopener">https://www.reddit.com/r/androiddev/comments/2afx13/onrestoreinstancestate_vs_oncreate/</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/04/List的删除/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ke Yu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coco">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/04/List的删除/" itemprop="url">List遍历要注意的坑</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-09-04T11:23:11+08:00">
                2017-09-04
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>List的删除测试：</p>
<p>主要函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">	List&lt;String&gt; myList = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">	myList.add(<span class="string">"a"</span>);</span><br><span class="line">	myList.add(<span class="string">"b"</span>);</span><br><span class="line">	myList.add(<span class="string">"c"</span>);</span><br><span class="line">	myList.add(<span class="string">"d"</span>);</span><br><span class="line">	myList.add(<span class="string">"e"</span>);</span><br><span class="line">	test1(myList,<span class="string">"d"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(List&lt;String&gt; list)</span></span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(String e : list)&#123;</span><br><span class="line">			System.out.println(e);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h3 id="首先是根据下标遍历："><a href="#首先是根据下标遍历：" class="headerlink" title="首先是根据下标遍历："></a><strong>首先是根据下标遍历：</strong></h3><h4 id="Test1："><a href="#Test1：" class="headerlink" title="Test1："></a>Test1：</h4><p>很明显，事先的size在remove发生后会改变，所以出现了溢出。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// size遍历，删除指定下标。TEST1</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">(List&lt;String&gt; list, String key)</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> size = list.size();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i)&#123;</span><br><span class="line">			String tmp = list.get(i);</span><br><span class="line">			<span class="keyword">if</span>(tmp.equals(key))&#123;</span><br><span class="line">				list.remove(key);<span class="comment">// 用list.remove(i)也是一样结果</span></span><br><span class="line">				System.out.println(<span class="string">"After removing, length is "</span> + list.size());</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		show(list);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p><img src="http://ovwunej09.bkt.clouddn.com/listR01.png" alt="result test1"></p>
<h4 id="TEST2："><a href="#TEST2：" class="headerlink" title="TEST2："></a>TEST2：</h4><p>当每个元素都不同时，可以正确删除，一开始看还以为是对的…但是当出现重复元素时，只能删除其中一个元素。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">	List&lt;String&gt; myList = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">	myList.add(<span class="string">"a"</span>);</span><br><span class="line">	myList.add(<span class="string">"b"</span>);</span><br><span class="line">	myList.add(<span class="string">"c"</span>);</span><br><span class="line">	myList.add(<span class="string">"c"</span>);</span><br><span class="line">	myList.add(<span class="string">"d"</span>);</span><br><span class="line">	myList.add(<span class="string">"e"</span>);</span><br><span class="line">	test2(myList,<span class="string">"c"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// size不固定，和i比较时再取.TEST2</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">(List&lt;String&gt; list, String key)</span></span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); ++i)&#123;</span><br><span class="line">			String tmp = list.get(i);</span><br><span class="line">			<span class="keyword">if</span>(tmp.equals(key))&#123;</span><br><span class="line">				list.remove(key);<span class="comment">// 用list.remove(i)也是一样结果</span></span><br><span class="line">				System.out.println(<span class="string">"After removing, length is "</span> + list.size());</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		show(list);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p><img src="http://ovwunej09.bkt.clouddn.com/listR03.png" alt="clipboard.png"></p>
<p>因为执行remove时，将被删除的元素之后的元素全部往前移动一位，那么原来的size-1位置就为null了，最后把size–就可以了。比如i==2出现了删除，i==3的元素和2一样，但是它去了2位置，这时就扫描不到它了。</p>
<h4 id="TEST3："><a href="#TEST3：" class="headerlink" title="TEST3："></a>TEST3：</h4><p>那么可能会想到，既然是被删除之后的元素往前面移动，那么我们可以试试从后遍历~！这样后面的元素往前移动也没有关系，因为他们已经被扫描过了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// size不固定，和i比较时再取.从后往前遍历.TEST3</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">(List&lt;String&gt; list, String key)</span></span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = list.size()-<span class="number">1</span>; i &gt;=<span class="number">0</span> ; --i)&#123;</span><br><span class="line">			String tmp = list.get(i);</span><br><span class="line">			<span class="keyword">if</span>(tmp.equals(key))&#123;</span><br><span class="line">				list.remove(key);<span class="comment">// 用list.remove(i)也是一样结果</span></span><br><span class="line">				System.out.println(<span class="string">"After removing, length is "</span> + list.size());</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		show(list);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p><img src="http://ovwunej09.bkt.clouddn.com/listR04.png" alt="result test3"></p>
<p>成功了~！！！<br>先固定size的方法，一旦发生remove肯定会导致size改变，肯定行不通，不再测试。</p>
<h3 id="for-each遍历"><a href="#for-each遍历" class="headerlink" title="for each遍历"></a><strong>for each遍历</strong></h3><h4 id="TEST4："><a href="#TEST4：" class="headerlink" title="TEST4："></a>TEST4：</h4><p>for each遍历，有相同就直接删除：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// for each.遍历CowList，删除list。TEST4</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">(List&lt;String&gt; list, String key)</span></span>&#123;</span><br><span class="line">			<span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span>(String tmp:list)&#123;</span><br><span class="line">				<span class="keyword">if</span>(tmp.equals(key))&#123;</span><br><span class="line">					System.out.println(count + <span class="string">" is current index"</span>);</span><br><span class="line">					list.remove(key);<span class="comment">// 用list.remove(i)也是一样结果</span></span><br><span class="line">					System.out.println(<span class="string">"After removing, length is "</span> + list.size());</span><br><span class="line">				&#125;</span><br><span class="line">				count++;</span><br><span class="line">			&#125;</span><br><span class="line">			show(list);</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
<p><img src="http://ovwunej09.bkt.clouddn.com/listR05.png" alt="clipboard.png"></p>
<p>这个错误，研究过modCount就能明白，迭代器发生了错误。</p>
<p>在remove的时候modCount–，但是迭代器的expectedModcount是最开始遍历前的modcount，modCount值不是期望值，就抛出了异常。</p>
<p>这个fail-fast迭代是为了保证线程安全的，put这些操作也会用到。</p>
<h4 id="TEST5："><a href="#TEST5：" class="headerlink" title="TEST5："></a>TEST5：</h4><p>那么foreach怎么修改才能成功删除呢…最开始想的时候没想出来，有的人说remove后就break也是厉害了….不管重复元素了吗?</p>
<p>看到一种方法是把List复制为COWArrayList，写时复制，也就是remove完才把结果存入COWlist…但这样实际上操作的是COWAraayList而不是原本的List，感觉也不太可取。</p>
<p><strong>但是，假设遍历COWArrayList，但是操作原本的List呢？？</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// for each.遍历CowList，删除list。TEST5</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">(List&lt;String&gt; list, String key)</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">		CopyOnWriteArrayList&lt;String&gt; cowList = <span class="keyword">new</span> CopyOnWriteArrayList&lt;String&gt;(list);</span><br><span class="line">		<span class="keyword">for</span>(String tmp:cowList)&#123;</span><br><span class="line">			<span class="keyword">if</span>(tmp.equals(key))&#123;</span><br><span class="line">				System.out.println(count + <span class="string">" is current index"</span>);</span><br><span class="line">				list.remove(key);<span class="comment">// 用list.remove(i)也是一样结果</span></span><br><span class="line">				System.out.println(<span class="string">"After removing, length is "</span> + list.size());</span><br><span class="line">			&#125;</span><br><span class="line">			count++;</span><br><span class="line">		&#125;</span><br><span class="line">		show(list);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p><strong>我有点惊呆…居然成功了- -</strong></p>
<p><img src="http://ovwunej09.bkt.clouddn.com/listR06.png" alt="clipboard.png"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/03/二分查找/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ke Yu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coco">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/03/二分查找/" itemprop="url">二分查找和一些扩展</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-09-03T15:23:18+08:00">
                2017-09-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><h4 id="1）顺序查找"><a href="#1）顺序查找" class="headerlink" title="1）顺序查找"></a>1）顺序查找</h4><p><strong>在n个元素的表上直接用key进行比较。</strong><br><strong>只适用于较短的表。</strong></p>
<ul>
<li>最好情况：1次比较</li>
<li>最坏情况：n次比较</li>
<li>平均情况：(1+2+3+…+n)/n = （n+1)/2</li>
</ul>
<h4 id="2）二分查找"><a href="#2）二分查找" class="headerlink" title="2）二分查找"></a>2）二分查找</h4><p><strong>将target与表中央的key进行比较。然后向左或向右二分此表。</strong><br><strong>适用于有序表。</strong></p>
<p>List的insert和replace操作对有序表不适用，如果想要通过List派生出有序表，要对这两个方法进行重载。<br>bottom=0,top=size-1<br>mid = (bottom+top)/2=(size-1)/2;<br>由于终止条件的不同，可以有几种二分：<br><img src="http://ovwunej09.bkt.clouddn.com/search02.jpg" alt="48151C421AD4433B84D5ADCDC78B1AC5.jpg"></p>
<h5 id="查找算法："><a href="#查找算法：" class="headerlink" title="查找算法："></a>查找算法：</h5><p><strong>①无论有没有找到target，都一直对表进行二分，直到剩下的表长为1；</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(bottom &lt; top) then 继续递归 <span class="comment">// 表中元素大于1</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(top &lt; bottom) then 不存在target </span><br><span class="line"><span class="keyword">else</span> then    <span class="comment">//top==bottom   相等判断在这个位置</span></span><br><span class="line">如果data等于target  then 找到target</span><br></pre></td></tr></table></figure>
<h5 id="递归条件："><a href="#递归条件：" class="headerlink" title="递归条件："></a>递归条件：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(data&lt;target) <span class="function">then <span class="title">return</span> <span class="params">(mid+<span class="number">1</span>,top)</span></span></span><br><span class="line"><span class="function"><span class="keyword">else</span> then <span class="title">return</span> <span class="params">(bottom,mid)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>此时表的分割如下：</li>
</ul>
<p><img src="http://ovwunej09.bkt.clouddn.com/search03.jpg" alt="D74F53DC1BCF45CB8B8C9CE2CEDD1CD7.jpg"></p>
<p>如果表中的目标出现超过一次，当中间的表长为1并且命中目标时，<strong>可以保证它是第一个出现的目标。</strong><br>每次查找终止于一个树叶，可能成功可能不成功。<br>外部路径长度：从根到树中每个树叶各遍历一次所经过的分支数的综合。</p>
<ul>
<li>查找n个元素的表：</li>
</ul>
<p><img src="http://ovwunej09.bkt.clouddn.com/search04.jpg" alt="45DBF761E7064BC2960FF114DC06699C.jpg"></p>
<p><strong>(成功查找和不成功查找的次数一样的）</strong></p>
<ul>
<li>最坏情况：lgn+1</li>
<li>平均情况：lgn</li>
</ul>
<p><strong>②进行相等识别。</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(bottom &lt;= top) then 继续递归 <span class="comment">// 表中元素大于1</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(top &lt; bottom) then 不存在target </span><br><span class="line"><span class="keyword">else</span> then    <span class="comment">//top==bottom</span></span><br><span class="line"> <span class="comment">//如果data等于target  then 找到target</span></span><br></pre></td></tr></table></figure>
<h5 id="递归条件：-1"><a href="#递归条件：-1" class="headerlink" title="递归条件："></a>递归条件：</h5><p>可加上相等判断<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(data==target) position=mid; <span class="comment">//相等判断在这里</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(data &lt; target) then <span class="keyword">return</span> (mid+<span class="number">1</span>,top)</span><br><span class="line"><span class="keyword">else</span> then <span class="keyword">return</span> (bottom,mid<span class="number">-1</span>)</span><br></pre></td></tr></table></figure></p>
<ul>
<li>此时表的分割如下：</li>
</ul>
<p><img src="http://ovwunej09.bkt.clouddn.com/search02.jpg" alt="clipboard.png"></p>
<p>如果表中的目标出现超过一次，会返回目标中的任一实例。<br>树叶都是不成功查找，所以外部路径长度就是不成功的比较次数。</p>
<p>成功查找：<br>内部路径长度：根到所有非树叶上的分支数上的和。<br>所有树叶都是不成功查找，n+1个树叶即n+1个不成功结果n+1约等于2\^h (h是树高）,<br>h约等于lg(n+1)，在此方法中，</p>
<p>每个内部定点执行2次比较，<strong>所以不成功查找的比较次数为2lg(n+1)</strong></p>
<p><strong>成功查找： (       ( (n+1)lg(n+1)-2n ) / 2 + 1     ) *2 - 1 = 2(n+1)/n *<br>lg(n+1) -3 </strong></p>
<ul>
<li>两种比较</li>
</ul>
<p><img src="http://ovwunej09.bkt.clouddn.com/search04.jpg" alt="clipboard.png"></p>
<h4 id="二分查找的应用-lower-bound"><a href="#二分查找的应用-lower-bound" class="headerlink" title="二分查找的应用(lower_bound"></a>二分查找的应用(lower_bound</h4><p>第一个大于等于target和upper_bound第一个大于target):<br>1)方法①得到的就是lower_bound那个数。<br><strong>但注意pos的位置：右序列中记录第一个数位置（bottom)</strong><br><strong>左序列中记录最后一个数位置（top)</strong></p>
<h4 id="递归条件：-2"><a href="#递归条件：-2" class="headerlink" title="递归条件："></a>递归条件：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(data &lt; target) <span class="function">then <span class="title">return</span> <span class="params">(mid+<span class="number">1</span>,top)</span></span></span><br><span class="line"><span class="function"><span class="keyword">else</span> then <span class="title">return</span> <span class="params">(bottom,mid)</span></span></span><br></pre></td></tr></table></figure>
<p><strong>2)方法①中递归条件做一点修改：</strong></p>
<h4 id="递归条件：-3"><a href="#递归条件：-3" class="headerlink" title="递归条件："></a>递归条件：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(data &gt; target) <span class="function">then <span class="title">return</span> <span class="params">(bottom, mid)</span></span></span><br><span class="line"><span class="function"><span class="keyword">else</span> then <span class="title">return</span> <span class="params">(mid+<span class="number">1</span>, top)</span></span></span><br><span class="line"><span class="function"><span class="comment">// pos的位置和1）中一样</span></span></span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/18/okhttp3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ke Yu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coco">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/18/okhttp3/" itemprop="url">okhttp3源码解析(1)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-08-18T23:13:25+08:00">
                2017-08-18
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>okhttp是<strong>高性能的http库</strong>，支持同步、异步，而且<strong>实现了spdy、http2、websocket协议</strong>，api很简洁易用，和volley一样实现了http协议的缓存。picasso就是利用okhttp的缓存机制实现其文件缓存，实现的很优雅，很<strong>正确，</strong>反例就是UIL（universal image loader），自己做的文件缓存，而且不遵守http缓存机制。</p>
<h4 id="协议介绍"><a href="#协议介绍" class="headerlink" title="协议介绍"></a>协议介绍</h4><h5 id="SPDY"><a href="#SPDY" class="headerlink" title="SPDY"></a>SPDY</h5><p>用以最小化网络延迟，提升网络速度，优化用户的网络使用体验。是对HTTP协议的增强。<br>a.复用连接，可在一个TCP连接上传送多个资源。应对了TCP慢启动的特性。降低了延迟的同时提高了宽带利用率。<br>b.请求分优先级，为了避免关键请求被阻塞，可以设置优先级，重要的资源优先传送。<br>c.HTTP头部数据也被压缩，省流量。<br>d.服务器端可主动连接客户端来推送资源（Server Push）。<br>e.基于HTTPS的加密协议传输</p>
<p><strong>HTTP2.0 支持明文HTTP传输，SPDY强制使用HTTPS协议。</strong><br><strong>HTTP2.0消息头的压缩算法采用HPACK，而非SPDY采用的DEFLATE</strong></p>
<h5 id="HTTP2-0"><a href="#HTTP2-0" class="headerlink" title="HTTP2.0"></a>HTTP2.0</h5><p>a.新的二进制格式，只使用0和1，增加了代码的健壮性。文本协议的表现形式有很多，所以要考虑很多使用场景。<br>b.复用连接<br>c.header压缩<br>d.服务端推送</p>
<h5 id="Websocket"><a href="#Websocket" class="headerlink" title="Websocket"></a>Websocket</h5><p>Websocket借用了HTTP的协议来完成一部分握手，<br>a.通讯过程建立在一次连接上，只需要一次HTTP握手，避免了HTTP的非状态性。连接建立后，双方都可以发送/响应消息，不需要像HTTP那样等待响应。<br>b.服务器有消息时就主动发送信息给客户端</p>
<h4 id="源码解读"><a href="#源码解读" class="headerlink" title="源码解读"></a>源码解读</h4><p>第一步<br>client.newCall(request).execute() ，链式调用，第一个调用返回了一个realCall对象，然后realCall实例调用属于它的方法execute()—-&gt;BEGIN</p>
<p>A.而 dispatcher的executed(RealCall call)其实是：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">executed</span><span class="params">(RealCall call)</span> </span>&#123;</span><br><span class="line">	runningSyncCalls.add(call);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>runningSyncCalls是一个deque,它把这个call加入了队列。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Running synchronous calls. Includes canceled calls that haven't finished yet. */</span></span><br><span class="line"><span class="comment">// 执行同步调用的队列，包括取消的但还没有执行的call</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Deque&lt;RealCall&gt; runningSyncCalls = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br></pre></td></tr></table></figure></p>
<h5 id="①RealCall-java"><a href="#①RealCall-java" class="headerlink" title="①RealCall.java"></a><strong>①RealCall.java</strong></h5><p>实现了Call的接口。<br>1）call是一次准备执行的请求，realCall是一次请求和一次响应的paris，不能执行两次。<br>2）Response#body可以获得响应体，为了避免内存泄漏需要close这个reseponse<br>3）传输层成功（收到响应码，响应头，响应体），不代表应用层成功。依然可能有404,或者500这些坑爹的响应码。<br>4）cancellation, a connectivity problem or timeout会造成IOE的抛出，<br>5）请求已经执行时，抛出IllegalStateException</p>
<p>BEGIN.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Response <span class="title">execute</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	<span class="comment">//做的最重要的事情是：</span></span></span><br><span class="line"><span class="function">	<span class="keyword">try</span> </span>&#123;</span><br><span class="line">		client.dispatcher().executed(<span class="keyword">this</span>); --&gt;A</span><br><span class="line">		Response result = getResponseWithInterceptorChain(); --&gt;B</span><br><span class="line">		<span class="keyword">if</span> (result == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Canceled"</span>);</span><br><span class="line">			<span class="keyword">return</span> result;</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			client.dispatcher().finished(**<span class="keyword">this</span>**);</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure></p>
<p>B.getResponseWithInterceptorChain();在Recall的这个函数中，主要是添加了一系列拦截器到一个链表interceptors中，添加过后，初始化RealInterceptorChain，执行RealInterceptorChain的proceed方法：</p>
<p>这个构造函数，传入的streamAllocation,httpCode,conn都是null<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Interceptor.Chain chain = <span class="keyword">new</span> RealInterceptorChain(</span><br><span class="line">	interceptors, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="number">0</span>, originalRequest);</span><br><span class="line">		<span class="keyword">return</span> chain.proceed(originalRequest); ---&gt;C</span><br></pre></td></tr></table></figure></p>
<h5 id="②Interceptor接口中还有Chain接口"><a href="#②Interceptor接口中还有Chain接口" class="headerlink" title="②Interceptor接口中还有Chain接口"></a>②Interceptor接口中还有Chain接口</h5><p>Chain接口由http/<strong>RealInterceptorChain.java</strong>来实现（找半天…）</p>
<p><strong>C.两个proceed函数，可以只传request。最终归于以下这个函数</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Response <span class="title">proceed</span><span class="params">(Request request, StreamAllocation streamAllocation,HttpCodec httpCodec,RealConnection connection)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">/*</span></span></span><br><span class="line"><span class="function"><span class="comment">在这里面，各种判断流是否只调用了一次proceed，等等（其实没看懂..)</span></span></span><br><span class="line"><span class="function"><span class="comment">多次判断了this.httpCodec != null，只有ConnectInterceptor执行完后就不为null了,所以这是对connectInterceptor之后的拦截器进行了判断。在ConnectInterceptor之后的拦截器必须满足：request的url要一致，interceptor必须执行一次proceed()。这样子做是为了保证递推的正常运作。该函数里面的calls++,由于proceed（）是interceptor的intercept里面调用的，所以对于每个interceptor其实calls不能大于1。*/</span></span></span><br><span class="line"><span class="function"><span class="comment">// 最重要的是：</span></span></span><br><span class="line"><span class="function"><span class="comment">// Call the next interceptor in the chain.</span></span></span><br><span class="line"><span class="function"><span class="comment">// 创建一个新的拦截链</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">RealInterceptorChain next </span>= <span class="keyword">new</span> RealInterceptorChain(</span><br><span class="line">interceptors, streamAllocation, httpCodec, connection, index + <span class="number">1</span>, request);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从list中取出第index个拦截器</span></span><br><span class="line"><span class="comment">// 执行这个连接器的intercept方法。</span></span><br><span class="line">Interceptor interceptor = interceptors.get(index);</span><br><span class="line">Response response = interceptor.intercept(next); ---&gt;D</span><br></pre></td></tr></table></figure></p>
<p>由于拦截器有多种，所以根据不同的拦截器，会调用不同的intercept方法。</p>
<h5 id="③RealConnection-JAVA"><a href="#③RealConnection-JAVA" class="headerlink" title="③RealConnection.JAVA"></a><strong>③RealConnection.JAVA</strong></h5><p>继承了Http2Connection.Listener，实现了Connection接口.<br>客户端和服务端之间的连接抽象为了realConnection，为了管理这些连接的复用设计了connectionPool,共享address的请求可以复用连接。<br>这个类管理一次连接，在里面用socket进行连接处理，以及handshake处理握手。<br>其实是真正的建立socket连接的地方。</p>
<p><strong>M.</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEligible</span><span class="params">(Address address, Route route)</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure></p>
<p>该函数主要是判断这个链接是否能匹配这个address以及这个route。要经过三次判断：</p>
<ul>
<li>一是这个链接是否接受新的流或者它接受的流的size是不是满了；</li>
<li>二是调用Internal.instance.equalsNonHost比较路线的address和传入的address除了host部分是否相同；</li>
<li>三是只调用address.url().host().equals(this.route().address().url().host()看主机名是否匹配…</li>
</ul>
<p><strong>有点奇怪= =为什么二和三不一起比较呢？？迷…</strong></p>
<p><strong>N</strong>.<br>public void connect(…）{}<strong>中主要是根据路由是否需要隧道而判断调用connectTunnel(）还是connectSocket()；</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (route.requiresTunnel()) &#123;</span><br><span class="line">	connectTunnel(connectTimeout, readTimeout, writeTimeout);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">*<span class="comment">//否则直接使用socket连接*</span></span><br><span class="line">	connectSocket(connectTimeout, readTimeout);</span><br><span class="line">&#125;</span><br><span class="line">establishProtocol(connectionSpecSelector);</span><br></pre></td></tr></table></figure>
<p>//通过代理服务器，来做https请求的连接(http1.1的https以及http2)需要建立隧道连接，而其它的连接则不需要建立隧道连接。假设不需要隧道链接，直接使用socket链接：<br>对于private void connectSocket(int connectTimeout, int readTimeout) throws IOException {}</p>
<ul>
<li>首先根据路由取得代理和的address，然后根据代理类型使用工厂创建无参数的socket或者直接用new创建有代理的socket,再用这个socket进行connect：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Platform.get().connectSocket(rawSocket, route.socketAddress(),</span><br><span class="line">connectTimeout);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>其中Platform.get()是用于判断平台是在Android 还是 OpenJDK 9+.还是 OpenJDK 7 or OpenJDK 8 等等。这里我们去Android的平台调用 —&gt;O</p>
<p>服务端的信息存储在路由的socketAdress中。然后用okio封装rawsocket的输入和输出流。<br>socket连接结束后，调用establishProtocol(connectionSpecSelector); —&gt;P</p>
<p>P.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">establishProtocol</span><span class="params">(ConnectionSpecSelector</span></span></span><br><span class="line"><span class="function"><span class="params">connectionSpecSelector)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个函数主要是判断使用哪种协议，主要有三种：</p>
<ul>
<li>一是如果route.address().sslSocketFactory() == null<br>那么就是不需要HTTPS，使用的是HTTP协议，直接用HTTP1.1，socket直接用rassocket，返回。</li>
<li>一里面不返回，自然是要使用HTTPS协议，那么调用connectTls(connectionSpecSelector);—&gt;Q</li>
<li>三是判断if (protocol == Protocol.HTTP_2) ，因为二的调用导致了protocol的赋值.</li>
</ul>
<p>总之如果if满足的话，就创建了一个http2Connection，并且执行了http2Connection.start()，去到http2Connection这个类里面，涉及了一些handler,runnable的操作，开启了connection。</p>
<p>Q.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">connectTls</span><span class="params">(ConnectionSpecSelector connectionSpecSelector)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个函数比较长就不详细看了…大概就是用SSLSocketFactory创建了sslSocket然后选择了密码版本，TLS版本，配置了address的主机和协议，然后进行了握手，认证，最后用okio封装了sslSocket的输入和输出流。</p>
<p>在封装前还做了这样一件事：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Success! Save the handshake and the ALPN protocol.</span></span><br><span class="line"></span><br><span class="line">String maybeProtocol = connectionSpec.supportsTlsExtensions()</span><br><span class="line">? Platform.get().getSelectedProtocol(sslSocket) : <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">// 封装了后,</span></span><br><span class="line">protocol = maybeProtocol != <span class="keyword">null</span> ? Protocol.get(maybeProtocol)</span><br><span class="line">: Protocol.HTTP_1_1;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 总之就是maybeProtocol似乎影响了protocol的选择= =唉不管了,比较涉及socket方面的内容.</span></span><br></pre></td></tr></table></figure>
<h5 id="④StreamAllocation-JAVA"><a href="#④StreamAllocation-JAVA" class="headerlink" title="④StreamAllocation.JAVA"></a><strong>④StreamAllocation.JAVA</strong></h5><p><strong>HTTP连接前需要进行socket握手，根据域名或代理确定socket的ip和端口。主要由这个类完成。</strong><br>使用了类似于<strong>引用计数的方式跟踪Socket流的调用</strong>，这里的计数对象是StreamAllocation，它被反复执行aquire与release操作，这两个函数其实是在改变RealConnection中的List&gt;<br>的大小。</p>
<p><strong>E.</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> HttpCodec <span class="title">newStream</span><span class="params">(OkHttpClient client, **<span class="keyword">boolean</span>**</span></span></span><br><span class="line"><span class="function"><span class="params">doExtensiveHealthChecks)</span></span></span><br><span class="line"><span class="function">该函数根据client设置的连接超时、读写超时、失败是否重试，通过调用findHealthyConnection函数真正的建立一个RealConnection连接，又通过这个连接创建一个HttpCodec：</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">RealConnection resultConnection </span>= findHealthyConnection(connectTimeout,readTimeout,writeTimeout, connectionRetryEnabled, doExtensiveHealthChecks);---&gt;F</span><br><span class="line">，F主要是查找可用连接，一系列的步骤都有分析(F~Q都是），找到可用的连接后执行下一句，用这个链接创建HttpCodeC</span><br><span class="line"></span><br><span class="line">HttpCodec resultCodec = resultConnection.newCodec(client, <span class="keyword">this</span>); ---&gt;R</span><br><span class="line"></span><br><span class="line">得到httpCodec之后，终于可以把结果返回给conn拦截器的入口了，即它的intercept函数里面了...</span><br></pre></td></tr></table></figure></p>
<p>R.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> HttpCodec <span class="title">newCodec</span><span class="params">(）&#123;&#125;</span></span></span><br></pre></td></tr></table></figure></p>
<p>这个函数比较简单，就是http2Con != NULL,就建立http2codec，否则就设置好各种超时限制建立http1codec,就是调用构造函数。不再详解。</p>
<p>F.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">该函数中查找健康连接，如果是全新连接可以直接返回，否则还要对候选的连接进行健康检查。如果检查结果不健康就调用noNewStream和continue结束这次循环操作，进入下个循环。</span></span><br><span class="line"><span class="comment">   * Finds a connection and returns it if it is healthy. If it is unhealthy the process is repeated</span></span><br><span class="line"><span class="comment">   * until a healthy connection is found.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> RealConnection <span class="title">findHealthyConnection</span><span class="params">(<span class="keyword">int</span> connectTimeout, <span class="keyword">int</span> readTimeout,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">int</span> writeTimeout, <span class="keyword">boolean</span> connectionRetryEnabled, <span class="keyword">boolean</span> doExtensiveHealthChecks)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">	  <span class="comment">//找到候选连接</span></span><br><span class="line">      RealConnection candidate = findConnection(connectTimeout, readTimeout, writeTimeout,</span><br><span class="line">          connectionRetryEnabled);---&gt;G</span><br><span class="line"></span><br><span class="line">      <span class="comment">// If this is a brand new connection, we can skip the extensive health checks.</span></span><br><span class="line">      <span class="keyword">synchronized</span> (connectionPool) &#123;</span><br><span class="line">        <span class="keyword">if</span> (candidate.successCount == <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> candidate;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Do a (potentially slow) check to confirm that the pooled connection is still good. If it</span></span><br><span class="line">      <span class="comment">// isn't, take it out of the pool and start again.</span></span><br><span class="line">	  <span class="comment">// 不是全新连接，继续检查：</span></span><br><span class="line">      <span class="keyword">if</span> (!candidate.isHealthy(doExtensiveHealthChecks)) &#123;</span><br><span class="line">        noNewStreams();</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> candidate;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>G.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> RealConnection <span class="title">findConnection</span><span class="params">(<span class="keyword">int</span> connectTimeout, <span class="keyword">int</span> readTimeout, <span class="keyword">int</span> writeTimeout,<span class="keyword">boolean</span> connectionRetryEnabled)</span></span></span><br></pre></td></tr></table></figure></p>
<p>返回一个用于流执行底层IO的连接，优先复用已经创建的连接，没有可复用的就创建一个。</p>
<p>首先是锁住连接池，防止别的线程加入和移出连接，然后尝试上次分配的连接是否可用，行的话就返回给调用者。不行的话又通过Internal.instance.get()从连接池中取得连接，行的话就返回。如果还是不行的话，选择一个路由。连接池块结束。</p>
<p>如果路由为空，那么selectedRoute = routeSelector.next(); —&gt;H<br>创建新的路由(HI的内容）.<br>I结束后出创建了新的路由，回到这里。再次锁住连接池，并且再次：<br>Internal.instance.get(connectionPool, address, this, selectedRoute);—&gt; J<br>这个函数其实调用了pool的get，然后pool根据address选择链接，如果找到合适的连接，就使用acquire获取这个conn对象。</p>
<p>然后结束这个同步块，进行TCP+TLS的握手，真正开始建立连接:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">result.connect(connectTimeout, readTimeout,</span><br><span class="line">writeTimeout,connectionRetryEnabled);---&gt;N</span><br><span class="line">routeDatabase().connected(result.route());</span><br></pre></td></tr></table></figure></p>
<p>L.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(RealConnection connection)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>在这个函数中，<br>connection.allocations.add(new StreamAllocationReference(this,<br>callStackTrace));</p>
<p><strong>把当前SA对象的引用保存到了RealConn的allocation里面，主要是为了追踪RealConn;</strong></p>
<p>这样看来，同一个连接RealConnection似乎可以同时为多个HTTP请求服务，但实际上，多个HTTP/1.1请求是不能在一个连接上交叉处理的。</p>
<p>这就是要看connection.allocationLimit的更新设置，当使用HTTP1.1的请求时，这个值就一直为1，当然了，如果是2.0协议，自然可以将这个值设置大于1，实现HTTP2.0的多路复用。</p>
<h5 id="⑤各种拦截器"><a href="#⑤各种拦截器" class="headerlink" title="⑤各种拦截器"></a><strong>⑤各种拦截器</strong></h5><p><strong>T.CacheInterceptor</strong></p>
<p>在构造okHTTPclient时，可以设置cache对象，设置缓存的目录和大小。<br>如果不想用它的缓存策略，可以实现internalCache接口实现自定义缓存。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br></pre></td></tr></table></figure>
<p>1）首先判断用户是否设置了cache，如果有的话，就调用cache.get(chain.request())尝试获取这个request对应的response。</p>
<p><strong>下面这段话是哪儿来的？？</strong><br><strong>就从cache里面获取cacheDandiate:</strong><br><strong>cacheCandiate就是上次与服务器交互缓存的Response，可能为null，它目前是一个可以读取缓存header的response：</strong></p>
<p>Response cacheCandidate = cache != null<br>? cache.get(chain.request()) —-&gt;1A (1B,1C都是1A中引发的）: null;</p>
<p>2）然后缓存策略对当前信息进行一点加工：<br>CacheStrategy strategy = new CacheStrategy.Factory(now, chain.request(), cacheCandidate).get(); —-&gt; U// 参数为当前时间、当前请求、当前缓存响应。</p>
<p>3）如果cache不为空，那么调用cache.trackResponse(strategy);</p>
<p>4）如果有cache的候选，但是stragey返回的响应cacheResponse为空，说明这个cache候选用不了，关闭它，closeQuietly(cacheCandidate.body());</p>
<p>5）策略加工后输出的newtworkRequest（进行网络请求）和cacheResponse（可以用的缓存）有以下几种情况：</p>
<p>5.1）如果不能使用newtworkRequest并且stragey返回的响应cacheResponse为空，那么返<strong>回504的response。表明不进行网络请求，且缓存不存在或者过期。</strong></p>
<p>5.2）如果只是不需要使用networkRequest，那么把strategy返回的响应cacheResponse给return就行了。<strong>缓存可以用，而且不用进行网络请求。</strong></p>
<p>再下来当然就是可以用network了，</p>
<p>networkResponse = chain.proceed(networkRequest); 处理当前请求。</p>
<p>5.3）如果cacheResponse不为空，那么看network返回的响应，如果响应码是HTTP_NOT_MODIFIED（没有更新），那么直接返回cache的响应。<strong>这是因为requst的头部中含有ETag/Last-Modified标签，需要在条件请求下使用，虽然有了缓存，但还是需要访问网络。</strong></p>
<p>4）没有返回cache的响应，自然要返回network的响应了。<strong>这是因为缓存不存在或者过期了。</strong></p>
<p>然后或许要把这个请求的network的响应保存到cache中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (HttpHeaders.hasBody(response)) &#123;</span><br><span class="line">	CacheRequest cacheRequest = maybeCache(response, networkResponse.request(),</span><br><span class="line">	cache);----&gt;V</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//一圈下来终于得到了cacheRequest，终于可以把这个response写到这个cacherequest中了。</span></span><br><span class="line">	response = cacheWritingResponse(cacheRequest, response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后返回response，这个拦截器的intercept就执行结束了。</p>
<p>人家关于缓存策略的总结（记得找参考的地址贴上来…)：<br><strong>Okhttp的缓存是自动完成的，完全由服务器Header决定的，自己没有必要进行控制。</strong>网上热传的文章在Interceptor中手工添加缓存代码控制（比如服务器不支持的时候，重写cacheInterceptor，把它加到networkInterceptor中），它固然有用，但是属于Hack式的利用，违反了RFC文档标准，不建议使用，OkHttp的官方缓存控制在注释中。如果读者的需求是对象持久化，建议用文件储存或者数据库即可（比如realm）。</p>
<p><strong>1A:</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Response <span class="title">get</span><span class="params">(Request request)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>cache中的函数，首先根据url得到key，然后看是否能从diskcache中取到snapshot，如果取到：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">entry = <span class="keyword">new</span> Entry(snapshot.getSource(ENTRY_METADATA));</span><br><span class="line">---&gt;括号中<span class="number">1</span>B,得到[<span class="number">0</span>]处的非缓冲流，并且构造一个Entry。Entry是cache中的静态常量类！！<span class="keyword">new</span> Entry--&gt;<span class="number">1</span>C</span><br></pre></td></tr></table></figure></p>
<p>cache类中一个内部类Entry。构造出了entry，也就是确定了响应信息的各种变量，再调用如下函数,也就是得到entry后：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Response response = entry.response(snapshot);</span><br><span class="line">---&gt;1D</span><br><span class="line">//这个函数也是cache的内部类Entry的.所以是上一句，把各种信息构造成了Entry（entry的各变量被赋值），而这一步就吧entry的信息取出来构造成了response。。看起来很多余啊。。。。。。但感觉是为了把snapshot作为变量也传进去..</span><br></pre></td></tr></table></figure></p>
<p><strong>V.</strong><br>发现这个函数现在版本没有了，待更新。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> CacheRequest <span class="title">maybeCache</span><span class="params">(Response userResponse, Request</span></span></span><br><span class="line"><span class="function"><span class="params">networkRequest,InternalCache responseCache)</span></span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//该函数中，如果这个响应不能保存在这个request的cache中（isCacheable返回假）:</span></span><br><span class="line"><span class="keyword">if</span> (!CacheStrategy.isCacheable(userResponse, networkRequest)) &#123;</span><br><span class="line">那么判断这个request是否禁止cache（put中有详细禁止的判断，有五种方法禁止），是的话，就从cache中把这个请求remove掉：</span><br><span class="line">	<span class="keyword">if</span> (HttpMethod.invalidatesCache(networkRequest.method())) &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			responseCache.remove(networkRequest);</span><br><span class="line">只进入第一个<span class="keyword">if</span>就返回<span class="keyword">null</span>。</span><br><span class="line">否则就<span class="keyword">return</span> responseCache.put(userResponse);---&gt; W</span><br></pre></td></tr></table></figure>
<p><strong>D.connection拦截器：</strong></p>
<p>httpCodec 和 realconnection的建立都是在这个拦截器中。通过sA的newStream中的findHealthyConn找到了符合目标服务器的realConn，然后利用这个realConn创建了httpcodec。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">	RealInterceptorChain realChain = (RealInterceptorChain) chain;</span><br><span class="line">	<span class="comment">// 获得这个链的request和stream</span></span><br><span class="line">	Request request = realChain.request();</span><br><span class="line">	StreamAllocation streamAllocation = realChain.streamAllocation();</span><br><span class="line">	<span class="comment">// We need the network to satisfy this request. Possibly for validating a conditional GET.</span></span><br><span class="line">	<span class="keyword">boolean</span> doExtensiveHealthChecks = !request.method().equals(<span class="string">"GET"</span>);</span><br><span class="line">	<span class="comment">// 用stream建立一个httpcode,完成建立工作</span></span><br><span class="line">	HttpCodec httpCodec = streamAllocation.newStream(client,</span><br><span class="line">	doExtensiveHealthChecks); ---&gt;E 。 R执行完了之后终于回来了。</span><br><span class="line">	RealConnection connection = streamAllocation.connection();<span class="comment">//由于E-R的过程中，streamAllocation保存了connection，所以这个函数其实是return了这个sA对象保存的realConn。</span></span><br><span class="line">	<span class="keyword">return</span> realChain.proceed(request, streamAllocation, httpCodec, connection);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//然后继续调用proceed，proceed中当然是应该执行callandserver这个拦截器了。---&gt;S</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>目前ABCD的执行过程：在realcall的</strong>getResponseWithInterceptorChain()中，创建一个只含有拦截器链表和origirequest的chain,该chain执行proceed（requsest），在其中创建第index+1个拦截链next（其实就是去执行第index+1个拦截器），interact(next）执行当前index的拦截器的该方法，要把next这个链作为proceed的参数传下去，因为intercept中要继续调用proceed。</p>
<p>E到R整个过程都是这句话带来的：<br>HttpCodec httpCodec = streamAllocation.newStream(client,<br>doExtensiveHealthChecks);</p>
<p>主要就是创建了一个连接，并且记录了httpcodec。<br><strong>HttpCodec 则是利用 Okio 实现具体的数据 IO 操作。</strong></p>
<p>按照顺序，connect拦截器做完工作之后就是CallServerInterceptor。</p>
<p><strong>S.CallServerInterceptor</strong></p>
<p><strong>照样只有一个函数，居然那么长：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">	HttpCodec httpCodec = ((RealInterceptorChain) chain).httpStream();</span><br><span class="line">	StreamAllocation streamAllocation = ((RealInterceptorChain)</span><br><span class="line">	chain).streamAllocation();</span><br><span class="line">	Request request = chain.request();</span><br><span class="line">	<span class="keyword">long</span> sentRequestMillis = System.currentTimeMillis();</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//发送http头部信息</span></span><br><span class="line">	httpCodec.writeRequestHeaders(request);</span><br><span class="line">	Response.Builder responseBuilder = <span class="keyword">null</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//如果http方法允许有请求body并且请求body不为null</span></span><br><span class="line">	<span class="keyword">if</span> (HttpMethod.permitsRequestBody(request.method()) &amp;&amp; request.body() !=</span><br><span class="line">	<span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="comment">// If there's a "Expect: 100-continue" header on the request, wait for a</span></span><br><span class="line">		<span class="string">"HTTP/1.1 100</span></span><br><span class="line"><span class="string">		// Continue"</span> response before transmitting the request body. If we don<span class="string">'t get</span></span><br><span class="line"><span class="string">		that, return what</span></span><br><span class="line"><span class="string">		// we did get (such as a 4xx response) without ever transmitting the request</span></span><br><span class="line"><span class="string">		body.</span></span><br><span class="line"><span class="string">		//等待截断body前得到的服务器同意100 continue的response，如果没有得到这个回应，返回我们实际得到的响应</span></span><br><span class="line"><span class="string">		if ("100-continue".equalsIgnoreCase(request.header("Expect"))) &#123;</span></span><br><span class="line"><span class="string">			httpCodec.flushRequest();</span></span><br><span class="line"><span class="string">			// 由于传入了true，如果statusLine.code == HTTP_CONTINUE，那么就会返回null</span></span><br><span class="line"><span class="string">			responseBuilder = httpCodec.readResponseHeaders(true);</span></span><br><span class="line"><span class="string">		&#125;</span></span><br><span class="line"><span class="string">		// Write the request body, unless an "Expect: 100-continue" expectation</span></span><br><span class="line"><span class="string">failed.</span></span><br><span class="line"><span class="string">		//是否运行当前方法带body，通过okio把请求body写入到</span></span><br><span class="line"><span class="string">		if (responseBuilder == null) &#123;</span></span><br><span class="line"><span class="string">			Sink requestBodyOut = httpCodec.createRequestBody(request, request.body().contentLength());</span></span><br><span class="line"><span class="string">			BufferedSink bufferedRequestBody = Okio.buffer(requestBodyOut);</span></span><br><span class="line"><span class="string">			request.body().writeTo(bufferedRequestBody); //这个函数，在rb这个类的writeTo函数中，把body的内容写到了这个缓冲池中</span></span><br><span class="line"><span class="string">			bufferedRequestBody.close();</span></span><br><span class="line"><span class="string">		&#125;</span></span><br><span class="line"><span class="string">	&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	//刷新。</span></span><br><span class="line"><span class="string">	httpCodec.finishRequest();</span></span><br><span class="line"><span class="string">	//再读取一遍响应头</span></span><br><span class="line"><span class="string">	if (responseBuilder == null) &#123;</span></span><br><span class="line"><span class="string">		responseBuilder = httpCodec.readResponseHeaders(**false**);</span></span><br><span class="line"><span class="string">	&#125;</span></span><br><span class="line"><span class="string">	</span></span><br><span class="line"><span class="string">	// 读取响应头设置response</span></span><br><span class="line"><span class="string">	Response response = responseBuilder</span></span><br><span class="line"><span class="string">	.request(request)</span></span><br><span class="line"><span class="string">	.handshake(streamAllocation.connection().handshake())</span></span><br><span class="line"><span class="string">	.sentRequestAtMillis(sentRequestMillis)</span></span><br><span class="line"><span class="string">	.receivedResponseAtMillis(System.currentTimeMillis())</span></span><br><span class="line"><span class="string">	.build();</span></span><br><span class="line"><span class="string">	int code = response.code();</span></span><br><span class="line"><span class="string">	if (forWebSocket &amp;&amp; code == 101) &#123;</span></span><br><span class="line"><span class="string">	// Connection is upgrading, but we need to ensure interceptors see a non-null response body.</span></span><br><span class="line"><span class="string">		response = response.newBuilder()</span></span><br><span class="line"><span class="string">			.body(Util.EMPTY_RESPONSE)</span></span><br><span class="line"><span class="string">			.build();</span></span><br><span class="line"><span class="string">	&#125; else &#123;</span></span><br><span class="line"><span class="string">	//在有响应头的情况下读取响应body</span></span><br><span class="line"><span class="string">	response = response.newBuilder()</span></span><br><span class="line"><span class="string">			.body(httpCodec.openResponseBody(response))// 提供具体 HTTP 协议版本的响应 body</span></span><br><span class="line"><span class="string">			.build();</span></span><br><span class="line"><span class="string">	&#125;</span></span><br><span class="line"><span class="string">	if("close".equalsIgnoreCase(response.request().header("Connection")) || "close".equalsIgnoreCase(response.header("Connection"))) &#123;</span></span><br><span class="line"><span class="string">		streamAllocation.noNewStreams();</span></span><br><span class="line"><span class="string">	&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	if ((code == 204 || code == 205) &amp;&amp; response.body().contentLength() &gt; 0) &#123;</span></span><br><span class="line"><span class="string">		throw new ProtocolException(</span></span><br><span class="line"><span class="string">			"HTTP " + code + " had non-zero Content-Length: " +</span></span><br><span class="line"><span class="string">			response.body().contentLength());</span></span><br><span class="line"><span class="string">	&#125;</span></span><br><span class="line"><span class="string">	return response;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>关于except:100-continue:<br>在使用curl做POST的时候, 当要POST的数据大于1024字节的时候,<br>curl并不会直接就发起POST请求, 而是会分为俩步,；<br>　　流程如下：<br>　　1. 发送一个请求, 包含一个Expect:100-continue, 询问Server使用愿意接受数据<br>　　2. 接收到Server返回的100-continue应答以后, 才把数据POST给Server</p>
<p>使用100（不中断，继续）状态码的目的是为了在客户端发出请求体之前，让服务器根据客户端发出的请求信息（根据请求的头信息）来决定是否愿意接受来自客户端的包含了请求内容的请求；</p>
<h5 id="⑥SelectorRoute-JAVA"><a href="#⑥SelectorRoute-JAVA" class="headerlink" title="⑥SelectorRoute.JAVA"></a><strong>⑥SelectorRoute.JAVA</strong></h5><p><strong>H</strong><br>这个函数好像也改过了…待更新<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Route <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">该函数中，首先三个<span class="keyword">if</span>嵌套。顺序为：</span><br><span class="line">判断是否有socket地址--》 判断是否有代理---》判断是否有route--》 抛出异常</span><br><span class="line">一直是not状态。如果是yes状态跳到如下：</span><br><span class="line">确定下一个socket地址 </span><br><span class="line">lastProxy = nextProxy(); </span><br><span class="line"><span class="keyword">return</span> nextPostponed();</span><br><span class="line"></span><br><span class="line"><span class="comment">// IP地址，代理，socket地址都找到后，建立新的路由</span></span><br><span class="line">Route route = <span class="keyword">new</span> Route(address, lastProxy, lastInetSocketAddress);--&gt;I</span><br></pre></td></tr></table></figure></p>
<h5 id="⑦Route-JAVA"><a href="#⑦Route-JAVA" class="headerlink" title="⑦Route.JAVA"></a><strong>⑦Route.JAVA</strong></h5><p>I.构造函数主要就是把参数address,proxy,socketaddress赋值给这个类的成员变量。</p>
<p><strong>⑧okHttpClient.JAVA</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">**J.**</span><br><span class="line">Internal.instance = <span class="keyword">new</span> Internal() &#123;....&#125; </span><br><span class="line">是这个类中的一个<span class="keyword">static</span>代码块。它的get函数其实是调用了连接池的get：</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> RealConnection <span class="title">get</span><span class="params">(ConnectionPool pool, Address address,StreamAllocation streamAllocation, Route route)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> pool.get(address, streamAllocation, route); --&gt; K</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="⑨ConnectionPool-JAVA"><a href="#⑨ConnectionPool-JAVA" class="headerlink" title="⑨ConnectionPool.JAVA"></a><strong>⑨ConnectionPool.JAVA</strong></h5><p><strong>主要用来管理realConnection。</strong></p>
<p><strong>K.</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">RealConnection <span class="title">get</span><span class="params">(Address address, StreamAllocation streamAllocation,</span></span></span><br><span class="line"><span class="function"><span class="params">Route route)</span>；</span></span><br><span class="line"><span class="function">	<span class="comment">//这个函数遍历了所有连接，查找是否有address可复用的连接：</span></span></span><br><span class="line"><span class="function">	<span class="title">for</span> <span class="params">(RealConnection connection : connections)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//如果找到了，就把这个链接交给sA复用</span></span><br><span class="line">	<span class="keyword">if</span> (connection.isEligible(address, route)) &#123; ----&gt;M</span><br><span class="line">		streamAllocation.acquire(connection); ---&gt; L</span><br><span class="line">		<span class="keyword">return</span> connection;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="⑩AndroidPlatform-JAVA"><a href="#⑩AndroidPlatform-JAVA" class="headerlink" title="⑩AndroidPlatform.JAVA"></a><strong>⑩AndroidPlatform.JAVA</strong></h5><p><strong>O</strong>.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connectSocket</span><span class="params">(Socket socket, InetSocketAddress address, <span class="keyword">int</span> connectTimeout)</span></span></span><br></pre></td></tr></table></figure></p>
<p>该函数中调用了socket.connect(address,connectTimeout);成功与服务器建立连接，并且设置了链接的超时时间。address就是InetSocketAddress，包含了服务器的主机地址和端口号。</p>
<h5 id="⑪CacheStrategy-java"><a href="#⑪CacheStrategy-java" class="headerlink" title="⑪CacheStrategy.java"></a><strong>⑪CacheStrategy.java</strong></h5><p>1)private Date expires;<br>缓存的响应的到期时间，如果到期了，就需要网络连接.如果maxAge也设置了，以maxAge优先。</p>
<p>2)private String etag;<br>对资源文件的一种摘要，客户端不需要了解实现的细节，第一次请求时，服务器返回：</p>
<p>ETag: “5694c7ef-24dc”<br>客户端再次请求时，发送 If-None-Match:”5694c7ef-24dc”<br>交给服务器判断是否使用缓存。</p>
<p><strong>U</strong>.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Factory</span><span class="params">(<span class="keyword">long</span> nowMillis, Request request, Response</span></span></span><br><span class="line"><span class="function"><span class="params">cacheResponse)</span></span></span><br><span class="line"><span class="function"><span class="comment">//设置这个策略的各个成员变量。</span></span></span><br><span class="line"><span class="function"><span class="comment">//然后构造之后是一个链式调用，调用了get():</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CacheStrategy <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	CacheStrategy candidate = getCandidate();</span><br><span class="line">	<span class="keyword">if</span> (candidate.networkRequest != <span class="keyword">null</span> &amp;&amp; request.cacheControl().onlyIfCached()) &#123;</span><br><span class="line">		<span class="comment">// We're forbidden from using the network and the cache is insufficient.</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> CacheStrategy(<span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> candidate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>getCandidate();也是这个类里面的，太长了。大概就是根据构造函数里面的成员变量，选定了conditionalRequest和cacheResponse，然后new了新的cacheStragy给返回了。<br>选的这个过程大概就是策略了= =</p>
<p>#####<strong>⑫Cache.JAVA</strong></p>
<p>(实现了internalCache接口， okhttp里面自带的cache）</p>
<p><strong>W.</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">CacheRequest <span class="title">put</span><span class="params">(Response response)</span> </span>&#123;&#125;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	一是httpmethod的invalidatesCache判断该请求是否不能缓存（五个），不能的话当然从cache中把这个request删掉，然后返回null。五个不支持缓存的：</span></span><br><span class="line"><span class="comment">	post;put;patch;delete;move</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	二是判断是不是GET方法，不是的话也返回NULL。</span></span><br><span class="line"><span class="comment">	虽然结果一样，但写清楚情况是非常必要的！！</span></span><br><span class="line"><span class="comment">	官方给的解释是缓存get方法得到的Response效率高，其它方法的Response缓存效率低。通常通过get方法获取到的数据都是固定不变的的，因此缓存效率自然就高了。其它方法会根据请求报文参数的不同得到不同的Response，因此缓存效率自然而然就低了。</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	三是if(HttpHeaders.hasVaryAll(response))判断是否有通配符“*”，有的话也直接返回null。</span></span><br><span class="line"><span class="comment">	接着用response构造一个entry。</span></span><br><span class="line"><span class="comment">	然后构造一个diskLruCache的editor对象：</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line"></span><br><span class="line">	Entry entry = <span class="keyword">new</span> Entry(response);</span><br><span class="line">	DiskLruCache.Editor editor = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		editor = cache.edit(key(response.request().url()));</span><br><span class="line">		<span class="keyword">if</span> (editor == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	entry.writeTo(editor);</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> CacheRequestImpl(editor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>edit方法得到了一个sink对象<br>接着用entry.writeTo(editor);把entry中的数据写到这个缓冲池editor里面。<br>最后：<br>return new CacheRequestImpl(editor); —&gt; X</p>
<p>CacheRequestImpl.JAVA<br>CacheRequestImpl是这个类中的一个实现了CacheRequest接口的常量类，主要是四个成员变量：<br>private final DiskLruCache.Editor editor;<br>private Sink cacheOut;<br>private Sink body;<br>boolean done;</p>
<p>X.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在这个构造函数中，this.cacheOut = editor.newSink(ENTRY_BODY); 这一句 ，</span></span><br><span class="line">把editor中保存的sink对象取出赋值给了crI的成员变量。构造函数最后一定要调用editor.commit();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CacheRequestImpl</span><span class="params">(<span class="keyword">final</span> DiskLruCache.Editor editor)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.editor = editor;</span><br><span class="line">	<span class="keyword">this</span>.cacheOut = editor.newSink(ENTRY_BODY);---&gt;Y <span class="comment">//ENTRY_BODY的值是1</span></span><br><span class="line">	<span class="keyword">this</span>.body = <span class="keyword">new</span> ForwardingSink(cacheOut) &#123;</span><br><span class="line">	<span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		<span class="keyword">synchronized</span> (Cache.<span class="keyword">this</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (done) &#123;</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			done = <span class="keyword">true</span>;</span><br><span class="line">			writeSuccessCount++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">super</span>.close();</span><br><span class="line">		editor.commit();</span><br><span class="line">	&#125;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>Class Entry:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>两种构造方式：<br>一是从Source in这个流得到信息进行处理，一是从response得到数据，直接赋值变量。</p>
<p><strong>1C.</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*Reads an entry from an input stream.*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Entry</span><span class="params">(Source in)</span> <span class="keyword">throws</span> IOException </span>&#123;&#125;</span><br><span class="line">其实就是处理响应头，一般entry有两种形式：HTTP或者HTTPS</span><br><span class="line">首先根据in得到BufferedSource source:</span><br><span class="line">BufferedSource source = Okio.buffer(in);</span><br><span class="line">然后根据source,得到响应头需要的信息：</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Entry</span><span class="params">(Source in)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		BufferedSource source = Okio.buffer(in);</span><br><span class="line">		url = source.readUtf8LineStrict();</span><br><span class="line">		requestMethod = source.readUtf8LineStrict();</span><br><span class="line">		Headers.Builder varyHeadersBuilder = <span class="keyword">new</span> Headers.Builder();</span><br><span class="line">		<span class="keyword">int</span> varyRequestHeaderLineCount = readInt(source);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; varyRequestHeaderLineCount; i++) &#123;</span><br><span class="line">			varyHeadersBuilder.addLenient(source.readUtf8LineStrict());</span><br><span class="line">		&#125;</span><br><span class="line">		varyHeaders = varyHeadersBuilder.build();</span><br><span class="line">		StatusLine statusLine = StatusLine.parse(source.readUtf8LineStrict());</span><br><span class="line">		protocol = statusLine.protocol;</span><br><span class="line">		code = statusLine.code;</span><br><span class="line">		message = statusLine.message;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// Builder模式哦~~</span></span><br><span class="line">		Headers.Builder responseHeadersBuilder = <span class="keyword">new</span> Headers.Builder();</span><br><span class="line">		<span class="keyword">int</span> responseHeaderLineCount = readInt(source);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; responseHeaderLineCount; i++) &#123;</span><br><span class="line">			responseHeadersBuilder.addLenient(source.readUtf8LineStrict());</span><br><span class="line">		&#125;</span><br><span class="line">		String sendRequestMillisString = responseHeadersBuilder.get(SENT_MILLIS);</span><br><span class="line">		String receivedResponseMillisString = responseHeadersBuilder.get(RECEIVED_MILLIS);</span><br><span class="line">		responseHeadersBuilder.removeAll(SENT_MILLIS);</span><br><span class="line">		responseHeadersBuilder.removeAll(RECEIVED_MILLIS);</span><br><span class="line">		sentRequestMillis = sendRequestMillisString != <span class="keyword">null</span> ? Long.parseLong(sendRequestMillisString) : <span class="number">0L</span>;</span><br><span class="line">		receivedResponseMillis = receivedResponseMillisString != <span class="keyword">null</span> ?Long.parseLong(receivedResponseMillisString) : <span class="number">0L</span>;</span><br><span class="line">		responseHeaders = responseHeadersBuilder.build();</span><br><span class="line">		<span class="keyword">if</span> (isHttps()) &#123;</span><br><span class="line">			String blank = source.readUtf8LineStrict();</span><br><span class="line">			<span class="keyword">if</span> (blank.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"expected \"\" but was \""</span> + blank +<span class="string">"\""</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			String cipherSuiteString = source.readUtf8LineStrict();</span><br><span class="line">			CipherSuite cipherSuite = CipherSuite.forJavaNam(cipherSuiteString);</span><br><span class="line">			List&lt;Certificate&gt; peerCertificates = readCertificateList(source);</span><br><span class="line">			List&lt;Certificate&gt; localCertificates = readCertificateList(source);</span><br><span class="line">			TlsVersion tlsVersion = !source.exhausted() ? TlsVersion.forJavaName(source.readUtf8LineStrict()) : <span class="keyword">null</span>;</span><br><span class="line">			handshake = Handshake.get(tlsVersion, cipherSuite, peerCertificates,localCertificates);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			handshake = <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;<span class="keyword">finally</span> &#123; <span class="comment">// 对应开始的try</span></span><br><span class="line">		in.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>二是这种构造方法，response这种很好理解：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Entry</span><span class="params">(Response response)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.url = response.request().url().toString();</span><br><span class="line">	<span class="keyword">this</span>.varyHeaders = HttpHeaders.varyHeaders(response);</span><br><span class="line">	<span class="keyword">this</span>.requestMethod = response.request().method();</span><br><span class="line">	<span class="keyword">this</span>.protocol = response.protocol();</span><br><span class="line">	<span class="keyword">this</span>.code = response.code();</span><br><span class="line">	<span class="keyword">this</span>.message = response.message();</span><br><span class="line">	<span class="keyword">this</span>.responseHeaders = response.headers();</span><br><span class="line">	<span class="keyword">this</span>.handshake = response.handshake();</span><br><span class="line">	<span class="keyword">this</span>.sentRequestMillis = response.sentRequestAtMillis();</span><br><span class="line">	<span class="keyword">this</span>.receivedResponseMillis = response.receivedResponseAtMillis();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>服气了= =先调用entry的构造方法构造了entry，又用entry反过来调用这个builder方法来构造response。response除了包括响应信息(Response的内容）外，还有对应的request。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Response <span class="title">response</span><span class="params">(DiskLruCache.Snapshot snapshot)</span> </span>&#123;</span><br><span class="line">	String contentType = responseHeaders.get(<span class="string">"Content-Type"</span>);</span><br><span class="line">	String contentLength = responseHeaders.get(<span class="string">"Content-Length"</span>);</span><br><span class="line"></span><br><span class="line">	Request cacheRequest = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">	.url(url)</span><br><span class="line">	.method(requestMethod, <span class="keyword">null</span>)</span><br><span class="line">	.headers(varyHeaders)</span><br><span class="line">	.build();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> Response.Builder()</span><br><span class="line">	.request(cacheRequest)</span><br><span class="line">	.protocol(protocol)</span><br><span class="line">	.code(code)	</span><br><span class="line">	.message(message)</span><br><span class="line">	.headers(responseHeaders)</span><br><span class="line">	.body(<span class="keyword">new</span> CacheResponseBody(snapshot, contentType, contentLength))</span><br><span class="line">	.handshake(handshake)	</span><br><span class="line">	.sentRequestAtMillis(sentRequestMillis)</span><br><span class="line">	.receivedResponseAtMillis(receivedResponseMillis)</span><br><span class="line">	.build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="⑬DiskLRUcache"><a href="#⑬DiskLRUcache" class="headerlink" title="⑬DiskLRUcache"></a><strong>⑬DiskLRUcache</strong></h5><p><strong>Y</strong>.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Sink <span class="title">newSink</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>把File dirtyFile = entry.dirtyFiles[index];这个文件，写入到 a new unbuffered<br>output stream</p>
<p><strong>1B.</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Returns the unbuffered stream with the value for &#123;\@code index&#125;. */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Source <span class="title">getSource</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> sources[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/13/计算机网络总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ke Yu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coco">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/13/计算机网络总结/" itemprop="url">计算机网络知识整理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-08-13T17:29:31+08:00">
                2017-08-13
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/计算机网络/" itemprop="url" rel="index">
                    <span itemprop="name">计算机网络</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>大三上计网课内容整理。教材：《计算机网络：自顶向下方法》<br>                                    2016.12</p>
<p><strong>第三章 运输层</strong></p>
<p>功能：进程通信 协议：UDP和TCP 特点：end-to-end</p>
<p>3.1 概述和运输层服务</p>
<p>1.运输层协议为运行在不同主机上的应用进程之间提供了<strong>逻辑通信</strong>。不是物理的通信。<br>2.运输层分组：报文段segment<br>3.书中将TCP和UDP的分组统称为报文段</p>
<p>3.1.2因特网运输层概述<br>表格。一会儿直接截图吧。</p>
<p>1.UDP和TCP的任务是将两个端系统间IP的交付服务扩展为运行在两个端系统上的进程之间的交付服务。<br>2.将主机间交付扩展到进程间交付，称为运输层的多路复用（transport-layer multiplexing）与多路分解（demultiplexing）。<br>3.多路分解：将运输层报文段中的数据交付到正确的套接字的工作称为多路分解。<br>4.多路复用：从源主机的不同套接字中收集数据块，并为每个数据块封装上首部信息从而生成报文段，然后将报文段传递到网络层的工作称为多路复用。<br>5.他们与在某层（在运输层或其它层）的单一协议在何时由位于Nex higher<br>layer的多个协议使用有关。<br>6.TCP和UDP套接字的区别：<br>一个UDP的套接字由<strong>目的IP地址和目的端口号</strong>的二元组标识。<br>即使源IP和源端口号不同，具有相同的目的IP和目的端口，两个报文段会通过<strong>相同的目的套接字</strong>定向到相同的目的进程。<br>一个TCP的套接字由（源IP，源端口，目的IP，目的端口）的四元组标识。<br>只要源IP或源端口不同，TCP报文段都会定向到<strong>两个不同的套接字</strong>。<br>7.主机接收到一个IP数据报（datagram）：<br>每个datagram都有源IP和目的IP，携带一个传输层segment。每个segment又有源端口号和目的端口号，于是主机通过目的IP和目的端口将segment传给相应的socket。<br>8.源端口号提供返回地址。<br>9.web服务器为不同的客户端提供不同的socket。<br>一点WEB服务器的知识：<br>1）WEB服务器通常都只<strong>使用一个进程</strong>，但是为每个新的客户机连接创建一个具有新连接套接字的新线程。<br>2）使用持久HTTP，则在整个连接持续期间，客户机和服务器之间经由同一个服务器套接字交换HTTP报文；使用非持久HTTP，则对每一对请求/响应，都有一个新的TCP连接被创建，请求/响应完成后随即被关闭。</p>
<p>3.3.2UDP校验和</p>
<p>1.发送方：把UDP的segment中所有内容做16bits的加法，再将得到的和做反转（取反）放进报文的checksum域中。<br>2.接收方：把首部的4个16bits字（包括checksum）相加，如果结果为16个1，则分组无差错。注意：如果4个字相加后取反，则结果全为0时分组无差错。</p>
<p>3.4 reliable data transfer 可靠数据传输</p>
<p>GOALS:<br>知道几个可靠版本分别的假设是什么；几个版本的关系和不同，每个版本解决什么问题。</p>
<p><strong>1.完全可靠信道上的可靠数据传输：rdt1.0</strong></p>
<p>最简单的情况。<strong>但完全不现实！</strong></p>
<p>假设:底层信道是完全可靠的,即没有比特误差，不会丢包。</p>
<p>此时，1）所有的分组都是从发送方流向接收方。2）接收方不需要提供任何反馈信息给发送方，因为不会发生任何差错。3）接收方没有必要请求发送方放慢发送速度。</p>
<p><strong>2.具有比特差错信道上的可靠数据传输：rdt2.0</strong></p>
<p>假设：<strong>底层信道模型是分组中的比特可能受损。</strong>在分组的传输传播或缓存的过程中，比特差错通常会出现在网络的物理部件中。<strong>所有传输的分组按其发送的顺序被接收。</strong></p>
<p>接收方正确接收后，进行肯定确认 ACK</p>
<p>接收有误，进行否定确认<br>NAK，并要求重传。这种重传机制的可靠数据传输协议称为自动重传请求（ARQ）请求。</p>
<p>ARQ协议中有另外三种协议（相对于rdt1.0的改进）：</p>
<p>1）差错检测</p>
<p>2）接收方反馈，接收方提供明确反馈信息（ACK,NAK）给发送方，只用一个bit长度。</p>
<p>3）重传，接收方收到有误的分组时，发送方将重传该分组。</p>
<p><strong>rdt2.0协议的缺陷：没有考虑ACK或NAK分组受损的可能性，即如果ACK或NAK分组出错怎么办。</strong>更难的是，这样纠正ACK或者NAK的差错？</p>
<p><strong>如果一个ACK或NAK分组受损，发送方无法知道接收方是否正确接收了上一块发送的数据。</strong></p>
<p><strong>ACK或NAK受损时有三种可能性：</strong></p>
<p>1）发送方接收到迷惑性的ACK或者NAK，又问“你说什么？”，而接收方不明白这句话是一个新的数据还是请求重复发送（太搞笑了这个….）</p>
<p>2）增加足够的校验和比特。这样发送方不但可以检测比特差错，还可以恢复比特差错。</p>
<p>3）发送发只要接到含糊不清的ACK\NAK，就重复发送当前分组。信道中出现冗余分组，并且接收方不知道这个分组是重传的还是新的。</p>
<p><strong>所以引入了数据分组的序号(sequence<br>number),这样接收方就知道收到的分组是否重传的。此时还需要停等协议，发送方等到接收方反馈后再继续。这就是RDT2.1。</strong></p>
<p><strong>3.rdt2.1(rdt2.0的改进版)</strong></p>
<p>此时，发送方为每个分组增加了序列号，但只有0和1。</p>
<p>如果接收方期望收到序号0的分组，却收到1分组，就会反馈ACK<br>1给发送方，此时发送方正在等待ACK 0，<br>于是发送方知道分组0可能丢失，于是重发分组0。</p>
<p>发送方必须知道ACK或者NAK是否出错，接收方不知道ACK/NAK是否被发送方正确接收。序列号只用两个，0和1.</p>
<p>于是有了rdt2.2</p>
<p><strong>4.rdt2.2</strong></p>
<p><strong>具有比特差错信道上的一个无NAK的可靠数据传输协议。</strong></p>
<p><strong>只使用ACK，</strong>接收方通过ACK告知发送方最后一个被正确接收的分组。在ACK消息中显式的加入被确认分组的序列号seq。</p>
<p>发送方接收到<strong>重复的ACK</strong>，相当于收到了NAK，就会重传当前分组。</p>
<p><strong>但是信道不丢包的假设不合理，如果丢包则协议无法工作。</strong></p>
<p>5.rdt3.0</p>
<p>具有比特差错的丢包信道上的可靠数据传输</p>
<p>怎么样检验丢包以及丢包后做什么。后者可通过校验和、序号、ACK分组和重传等解决。</p>
<p>如果发送方发送的分组丢失，或者接收方的ACK分组丢失，发送方都无法收到响应。此时，<strong>需要选择一个时间值来限定发送方等待的时间（定时器）</strong>，过了这个时间还没收到ACK，发送方就重传分组，这可能会造成冗余分组（没有丢包，只是延迟太久）。但是rdt2.2中的seq已经可以处理冗余分组了。</p>
<p>所以定时器的作用就是用来恢复丢失的数据或确认分组。</p>
<p>但是使用的停等协议，发送方只有等待对方回应才能继续发送，使得发送方的利用率太小！！于是到下一部分内容….</p>
<p><strong>流水线协议</strong></p>
<p>1.允许发送方发送多个分组而无需等待确认。</p>
<p>2.流水线技术给可靠数据传输协议带来如下影响：</p>
<p>1）增加序号范围。每个传输的分组必须有一个唯一的序号。</p>
<p>2）协议的发送方和接收方需要<strong>缓存</strong>多个分组。发送方最少要能缓冲那些已经发送但还没有确认的分组。接收方<strong>可能</strong>需要缓存已正确接收的分组。</p>
<p>所需序号范围和对缓冲的要求取决于数据传输协议处理丢失、损坏及过度延时分组的方式。</p>
<p>3.解决流水线的差错恢复有两种基本方法：GO-BACK-N回退N步和selective<br>repeat选择重传。</p>
<p>GBN(滑动窗口协议 sliding-window protcol):</p>
<p>1.发送未确认的分组允许的范围为N，N被称为窗口长度。</p>
<p>过程：</p>
<p>发送方：</p>
<p>1.如果窗口未满，发送方就继续发送分组。窗口已满，就缓存或者让上层等一会儿再试。</p>
<p>2.超时时间：定时器为最早的已发送但还未确认的分组使用的定时器。若果收到一个ACK，但还有已发送但还未确认的分组，定时器重新启动。如果没有了，定时器终止。定时器n超时，则分组n重发。</p>
<p>接收方：</p>
<p>1）对序号为n的分组的确认采用累积确认。如果序号n分组被正确接收，并且按序接收，那么接收方为分组n发送ACK，并将分组交付给上层。如果分组k已接收并交付，则所有比k小的分组也一定已经交付。</p>
<p>2）接收方丢失所有失序分组。如果分组n丢失，接收到了分组n+1，那么n和n+1根据重传规则都会被重传，所以分组n+1不必交付给上层，可以直接丢弃。这样接收方<strong>不用缓存</strong>任何失序分组。</p>
<p>综上，发送方只用维护窗口的上下边界和nextsequnum在窗口中的位置，接收方需要维护下一个按序接收的分组序号。</p>
<p>缺点：窗口长度和带宽时延很大，在流水线中有很多分组时，一个单个分组的差错就可能引起GBN重传大量分组。</p>
<p><strong>选择重传（SR）</strong></p>
<p>让发送方仅重传那些它怀疑在接收方出错的分组（丢失或受损的分组）而避免了重传。</p>
<p>发送方：</p>
<p>1）接收到数据后，发送方检查下一个可用于该分组的序号，如果这个序号在发送窗口内，就打包数据并发送；否则要么缓存数据，要么返回给上层</p>
<p>2）超时，每个分组都拥有自己的定时器</p>
<p>3）收到ACK后，如果该序号在窗口内，则发送方将这个被确认的分组标记为已接收，如果恰好是send_base，则窗口基序号移动到最小序号的<strong>已发送未确认分组</strong>处，如果移动后有序号落到窗口的未发送分组，则发送这些分组。</p>
<p>接收方：</p>
<p>确认正确接收的分组不管是否按序。失序的分组会被缓存直到所有丢失分组都被收到。</p>
<p>这样可以将一批分组按序交给上层。</p>
<p>1）分组n处于[rcvbase,<br>rcvbase+N-1]，发送分组n的ACK，非按序的分组先缓存；如果是按序的，连同之间在缓存中的按序分组一起交付给上层。窗口移动到下一个未收到的分组处。</p>
<p>2）分组n处于[rcvbase-N,rcvbase-1]，直接回复ACK（n）</p>
<p>3)其他情况，忽略。</p>
<p>注意：对于2），一定要对这些分组重新确认，否则发送窗口的一些分组永远收不到ACK，该分组一直重传且发送窗口无法前进。</p>
<p>4）有一个例子表示窗口长度比序号空间大小小1时协议无法工作。</p>
<p>窗口长度必须小于或等于序号空间大小的一半。</p>
<p>3.5 面向连接的传输</p>
<p>3.5.1 TCP连接</p>
<p>特点：</p>
<p>1）全双工服务，建立连接后，数据可以在进程A和进程B之间互相流动。</p>
<p>2）点对点，单个发送方与单个接收方。</p>
<p>3）可靠的，按序投递</p>
<p>4）流水线，流量控制和拥塞控制需要设置窗口长度</p>
<p>5）面向对象的，发送数据时要先经过三次握手</p>
<p>6）流量控制，发送方的速率不能快于接收方</p>
<p>1.发送缓存，是在三次握手初期设置的缓存之一，接下来TCP会不时地从发送缓存里取出一块数据。</p>
<p>2.TCP可从缓存中取出并放入报文段中的数据量受限于最大报文段长（MSS），MSS根据最初确定的最大链路层帧长度，即本地发送主机发送长度，最大传输单元MTU来确定。</p>
<p>3.MSS是指报文段里<strong>应用层数据的最大长度</strong>，而不是指包括TCP首部报文段的最大长度。</p>
<p>4.TCP报文段：</p>
<p><img src="media/cb9ef26da050c1340eb19142f02bfbca.png" alt=""></p>
<p>接收窗口：用于流量控制，用于指示接收方愿意接受的字节数量。</p>
<p>首部长度：由于TCP选项字段的原因,TCP首部的长度是可变的，不过由于选项段一般为空，通常是20字节。</p>
<p>选项字段：发送方和接收方协商最大报文段长度MSS</p>
<p>PSH：指示接收方应立即将数据交给上层。</p>
<p>URG：指示报文段里存在着被发送方的上层实体置为“紧急”的数据。</p>
<p>紧急数据的最后一个字节由16比特的紧急数据指针字段指出。</p>
<p><strong>序号seq：建立在传送的字节流，而不是建立在传送的报文段的序列上。</strong></p>
<p><strong>一个报文段的序号，是该报文段首字节的字节流编号。</strong></p>
<p>假设数据流由一个500000字节的文件组成，MSS为1000字节，则500个报文段的首字节序号依次为0,1000,2000<br>……</p>
<p><strong>确认序号ACK：主机A期望从主机B收到的下一字节的序号。比如A已经收到来自B的编号为0-535的所有字节，那么此时A发送给B的报文段的确认号字段就是536。</strong></p>
<p><strong>累积确认：TCP只确认数据流中至第一个丢失字节为止的字节。</strong></p>
<p>主机在TCP连接中收到失序报文段怎么办？</p>
<p><img src="media/140abcbbb7e9f1167bf7138fef969c73.png" alt=""></p>
<p>3.5.3 往返时延的估计与超时</p>
<p>1.估计往返时延</p>
<p>样本RTT：从某报文段被发出（交给IP）到对该报文段的确认被收到之间的时间量（忽略重传）</p>
<p>1）RTT计算：</p>
<p>显然样本RTT会出现波动，所以使用 <strong>最近几个值的算术平均</strong>，<br>而不是当前的样本RTT峰值。</p>
<p>EstimatedRTT = (1- α)*EstimatedRTT + α*SampleRTT</p>
<p>在统计学中被称为指数加权移动平均。</p>
<p>通常α=0.125</p>
<p>2）RTT偏差DevRTT,用于估算SampleRTT一般会偏离EstimatedRTT的程度：</p>
<p>DevRTT = (1-β)*DevRTT +β*|SampleRTT-EstimatedRTT|</p>
<p>通常β=0.25</p>
<p>如果样本RTT波动较小，DevRTT的值就会很小。</p>
<p>2.设置和管理重传超时间隔</p>
<p>TimeoutInterval = EstimatedRTT + 4*DevRTT</p>
<p>3.5.4 可靠的数据传输</p>
<p>1）在不可靠的IP协议的尽力而为服务上建立了可靠的数据传输协议</p>
<p>2）流水线技术发送报文段</p>
<p>3）确认累积</p>
<p><strong>4）使用单重发计时器</strong></p>
<p>1.重发由超时间隔控制，每次TCP重传都会将下一次的超时间隔设为先前值的两倍，提供了一种拥塞控制。</p>
<p>2.</p>
<p><img src="media/a8cedd91720a451a7780e66afacaf1f6.png" alt=""></p>
<p>3.快速重传</p>
<p>1）为什么会发送冗余ACK？接收方收到一个具有大于期望序号的失序报文时，<strong>检测到数据流中的一个间隔</strong>，就是有报文段丢失，TCP不使用否定确认，只需对<strong>按序收到的</strong>最后一个字节数据进行重复确认，产生一个冗余ACK。</p>
<p>2）如果TCP发送方接收到对相同数据的<strong>3个冗余ACK</strong>，它就认为跟在这个已被确认过3次的报文段<strong>之后的报文段已经丢失。</strong></p>
<p>3）快速重传，即在该报文段的定时器过期之前重传丢失的报文段。</p>
<p>3.5.5 流量控制</p>
<p>TCP连接的两端的发送方都各自维护一个接收窗口。</p>
<p>1.当TCP连接收到正确、按序的字节后，它就将数据放入接收缓存，相关联的应用进程会从该缓存中读取数据。</p>
<p><img src="media/ab439aa277d7f8c1a0d78494a8b07a98.png" alt="rcvwin"></p>
<p>2.流量控制以<strong>消除发送方使接收方缓存溢出的可能性。可以说是一个速度匹配服务，即发送方的发送速率与接收方应用程序的读速率相匹配。</strong></p>
<p>3.接收窗口用于<strong>告诉发送方</strong>，该接收方还有多少<strong>可用的缓存空间</strong>。接收方会把这个值发送给发送方的报文段的接收窗口字段中。</p>
<p>4.</p>
<p><img src="media/d8a403edf7e74c616f15258f7a003ad2.png" alt=""></p>
<p>主机A跟踪的两个变量LastByteSent-LastByteAcked,<br>就是主机A发送到连接中但未被确认的数据量unAcked<br>Data。主机A需要将这个量控制在RcvWindow以内。可用保证主机A不会使主机B的接收缓存溢出。</p>
<p>3.5 连接控制</p>
<p><img src="media/5176e5cdde81af8496fbb6912f6771c9.png" alt=""></p>
<p><img src="media/d833c818e6c95efe6bece37849fdfb95.png" alt=""></p>
<p>处理同时发送的FIN？？？</p>
<p>3.6 拥塞控制原理</p>
<p>1.<strong>网络</strong>拥塞：太多的源主机想以过高的速率发送数据，网络难以处理过来。</p>
<p>2.表征：</p>
<p>1）丢包。路由器缓存溢出。</p>
<p>2）时延过长。路由器缓存队列过长。</p>
<p>拥塞情况</p>
<p>1.共享单跳具有<strong>无限大缓存</strong>的两个连接</p>
<p>数据被封装发送，不执行差错恢复（如重传）、流量控制或拥塞控制。</p>
<p><img src="media/e50b79f22d6b083bb5030001f7d5d71c.png" alt=""></p>
<p><img src="media/51f9d03b6ecf1022ca50fb9a851fa735.png" alt=""></p>
<p>发送速率在0~R/2间时，接收方 发送速率接近R/2时</p>
<p>吞吐量=发送方的发送速率 平均时延越来越大，超过R/2</p>
<p>吞吐上限R/2：两个连接之间对 源与目的地的平均时间无穷大</p>
<p>链路容量的共享</p>
<p>2.两个发送方和一个具有有限缓存的路由器</p>
<p>每个连接都可靠，分组可以被重传。</p>
<p><img src="media/b7329271f292aec87b0425c90b489923.png" alt=""></p>
<p>λ`in也表示供给载荷。</p>
<p><img src="media/ae52a87c9bd4a45a5cbe40aefb09434d.png" alt=""></p>
<p><img src="media/49bb38673b7fb137769ef59bc804970a.png" alt=""></p>
<p><img src="media/92bd88ddb0e8eddb59bcbcbbf2d59b3c.png" alt=""></p>
<p>仅当缓存空闲时发送分组 发送方仅当在确定了一个分组 发送方重传在队列中</p>
<p>不产生丢包，λin=λ`in 已经丢失时才重传 已推迟但未丢失的分组</p>
<p>吞吐量就等于λin 这条线假定每个分组被路</p>
<p>由器转发平均两次的情况</p>
<p>这里有两个拥塞带来的开销：</p>
<p>b. 发送方执行重传以补偿因为缓存溢出而丢失的分组</p>
<p>c.发送遇到大时延时进行的不必要重传引起路由器利用链路带宽来转发不必要<br>的分组拷贝。</p>
<ol start="3">
<li>暂时不管了…..</li>
</ol>
<p>3.6.2 拥塞控制方法</p>
<p>两种拥塞控制方法。</p>
<p>1.端到端拥塞控制。</p>
<p><img src="media/ed99f390b0b1931760c9ad255cd32f6e.png" alt=""></p>
<p>2.网络辅助的拥塞控制</p>
<p><img src="media/ba364fc58b4463d2383f169a3488ba56.png" alt=""></p>
<p><img src="media/2b0359d6fe8a7c5b25048b32e949753d.png" alt=""></p>
<p>3.7 TCP拥塞控制</p>
<p>基本思想：出现丢包时间时，让发送方降低发送速率（通过减少拥塞窗口CongWin）的大小。</p>
<p>TCP拥塞控制算法：三个部分。</p>
<p><strong>1.加性增、乘性减 AIMD</strong></p>
<p>加性增：每次它收到一个确认后就把CongWin增大一点，目标是<strong>在每个往返时延内CongWin增加一个MSS</strong></p>
<p>乘性减：每发生一次丢包事件，就将当前的CongWin值减半</p>
<p>TCP拥塞控制协议的<strong>线性增长阶段被称为避免拥塞。</strong>CongWin值重复地经历一种升降循环，即重复<strong>地线性增长</strong>，然后又突然降至当前值的一半（当发生丢包事件时），使得TCP连接的CongWin变化<strong>呈锯齿形状：</strong></p>
<p>2.TCP拥塞控制的细节</p>
<p>1）发送方能发送的字节限制：</p>
<p>LastByteSent-LastByteAcked ≤ CongWin</p>
<p>2）发送方的发送速率：</p>
<p><img src="media/34558633b770426a55d311cf6915a958.png" alt=""></p>
<p>CongWin是动态的。</p>
<p><strong>发送方怎么知道发生了拥塞？？</strong></p>
<p><strong>丢包事件。 超时或者收到三个重复的ACK</strong></p>
<p>发现丢包后，发送方会降低速率（减少CongWin）.</p>
<p><strong>3.慢启动</strong></p>
<p>TCP连接开始时，CongWin的最初值为1个MSS，则初始发送速率为MSS/RTT，可能带宽可能比这个值大得多，但仅仅线性地增加发送速率，将会非常慢。</p>
<p>所以TCP发送方，以指数的速度增加发送速率，<strong>每过一个RTT将CongWin值翻倍</strong>。直到一个丢包事件出现，CongWin变为一半，然后会开始线性增长。这被称为慢启动。慢启动阶段，每过一个RTT，CongWin的值都有效地增加一倍。</p>
<p>TCP发送方以慢速率发送，但是以指数的速度快速增加其发送速率。</p>
<p>4.怎样推断丢包事件</p>
<p>1）3个重复ACK，CongWin会降低为一半，然后线性增长（拥塞避免）。</p>
<p>2）超时时间，CongWin重新<strong>设置为1MSS</strong>,然后指数增长（慢启动），到达阙值后线性增长（拥塞避免）。</p>
<p>为什么两种丢包事件的处理不同？？</p>
<p>1）.如果是收到3个冗余ACK，网络表明它至少能交付一些报文段，即使一些报文段因为拥塞而丢失。这是<strong>快速恢复。</strong></p>
<p>2）超时事件表明拥塞情况更加严重。</p>
<p>5.阙值，用来确定慢启动将结束并且拥塞避免将开始的窗口长度。初始值很大，<strong>每发生一个丢包事件（不管因为什么原因），就被设置为当前CongWin值的一半。注意：这个阙值将会在丢包事件之后的指数和线性拐点才能看到！</strong></p>
<p><img src="media/8ec7d15c24fdcd05b40422ada3630394.png" alt=""></p>
<p>何时发生指数转线性？？</p>
<p>当遇到阙值时。也就是，congwin大小为之前超时发生丢包时大小的一半时。</p>
<p>5.TCP吞吐量</p>
<p>1）设丢包时的窗口大小为w，忽略慢启动阶段。</p>
<p>2）此时吞吐量为w/RTT</p>
<p>3）发生了丢包，w减少到w/2，此时吞吐量w/2rtt</p>
<p>4）平均吞吐量：0.75w/RTT</p>
<p>TCP未来（有点有趣）：</p>
<p><img src="media/4a71010f9e467cf444b19f1dc76baaa3.png" alt=""></p>
<p><strong>第四章 网络层</strong></p>
<p>网络层：将分组从一台发送主机移动到一台接收主机</p>
<p>路由器检查经过它的所有IP的datagram的报头。</p>
<p>1.转发：将分组从一个输入链路接口转移到适当的输出链路接口的路由器本地动作。</p>
<p>2.选录：分组从源到目的地时，决定端到端路径的网络范围的进程。</p>
<p>3.虚电路：仅在网络层提供<strong>连接服务</strong>的计算机网络。比如ATM, 帧中继。</p>
<p>1）建立、拆卸在数据可以传输之前</p>
<p>2）每个分组携带一个VC号</p>
<p>3）源到目的路径上的每个路由器都保持连接状态</p>
<p>4）网络层可以预留资源，比如带宽，缓存等。</p>
<p>组成：</p>
<p><img src="media/8e3bb0378cefd36ab0e2e18e6cb50705.png" alt=""></p>
<p>4.数据报网络：仅在网络层提供<strong>无连接服务</strong>的计算机网络</p>
<p>5.网络层提供的特定服务包括：</p>
<p>1）确保交付；2）具有时延上界的确保交付；</p>
<p>下列服务为给定的源和目的之间提供分组的流：</p>
<p>1）有序分组交付； 2）确保最小带宽；3）确保最大时延抖动。</p>
<p>4.2.2 数据报网络</p>
<p>1.最长前缀匹配</p>
<p>根据匹配表，确定想哪个链路接口转发该分组。</p>
<p>2.数据报网络和VC的区别：</p>
<table>
<thead>
<tr>
<th>数据报</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>在电脑之间交换数据，没有时间要求</td>
<td>电话通讯</td>
</tr>
<tr>
<td>终端更smart，可以进行控制，差错恢复 网络中更简单</td>
<td>人类通讯，严格的时间控制，可靠性需求高，提供的服务保证多</td>
</tr>
<tr>
<td>很多种链接类型</td>
<td>终端比较蠢，网络中复杂度高</td>
</tr>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>4.3 什么是路由器</p>
<p>4.3.3 输出端口</p>
<p>4.3.4何时出现排队</p>
<p>1.输出端口队列</p>
<p>输出阻塞</p>
<p>当交换结构将分组交付给输出端口的速率超过输出链路速率时<br>，需要<strong>排队与缓存功能</strong>。</p>
<p>排队（延时）和丢包由输出端口缓存溢出造成。</p>
<p>1）.输出端口上的一个分组调度程序从这些排队的分组中选出一个来传送，这种选择根据简单的调度原则来定。</p>
<p>2.输入端口队列</p>
<p>1）.输入排队交换机中的线路前部（HOL）阻塞：队列的首个packet由于它的目的端口正忙而被延迟转发，导致后面的packets被blocked。</p>
<p>也就是只要这个队列的头部被阻塞，它后面的数据报即使不是去同一个输出端口，也会被阻塞。</p>
<p>2.RFC 3439提出，平均缓存量=RTT*C(平均往返时延x链路容量)</p>
<p>3.最新建议：当大量的TCP流（N）经过一条链路时：B=RTT*C/根号N。</p>
<p>4.4 IP （Internet Protocol）</p>
<p>网络层主要有三个组件：</p>
<p><img src="media/4e6383fde994e9cc19bfd7fec57b0958.png" alt=""></p>
<p>1）IP协议</p>
<p>2）选录组件，决定数据报从源到目的地所流经的路径</p>
<p>3）报告数据中的差错和对某些网络层信息请求进行响应</p>
<p>也就是ICMP协议（比如ping的时候用的是这个）</p>
<p>1.数据报格式</p>
<p><img src="media/bb24128244bd5a69e80919359732b37c.png" alt=""></p>
<p>首部长度：因为IPV4数据报可以包含一些可选项，所以用这4比特确定IP数据报中的数据报部分实际从哪里开始。</p>
<p>服务类型（TOS）：区分数据类型。</p>
<p>数据报长度。IP数据报的总长度（首部加数据）</p>
<p>生存时间（TTL）：数据报最多经过的跳数（每经过一台路由器就减1）</p>
<p><strong>协议（upper layer）：表明数据报的数据应该给哪个运输层协议（TCP或UDP）<br>。类似运输层的端口号。是两个层之间的粘合剂。</strong></p>
<p>首部校验和：帮助路由器检测数据报中的比特错误。</p>
<ol start="2">
<li>how much overhead with TCP?</li>
</ol>
<p>20 bytes of TCP</p>
<p>20 bytes of IP</p>
<p>= 40 bytes + app layer overhead</p>
<p>4.4.2 IPv4编址</p>
<p>1.接口，主机与物理链路之间的边界；路由器与它的任意一条链路之间的边界。</p>
<p>2.每个IP地址长度为32比特（4字节），共有2\^32个可能的IP地址。</p>
<p>3.每台主机和路由器上的每个接口都必须有一个全球唯一的IP地址。</p>
<p>4.子网：分开主机和路由器的每个接口，从而产生了几个分离的网络岛，接口端接了这些独立的网络的断点，这些独立的网络中的每个都叫做一个子网。</p>
<p>IP地址的子网部分相同的接口；彼此可以不通过路由器物理连接；</p>
<p>5.因特网的地址分配策略：无类别域间选路（Classless Interdomain Routing,CIDR）.</p>
<p>表示格式为a.b.c.d/x x构成了IP地址的网络部分，被称为该地址的前缀。</p>
<p>6.DHCP动态主机配置协议：可以让主机每次与该网络连接时能得到一个相同的IP地址，或者被分配一个临时的IP地址。</p>
<p>plug and play protocol ： 即播即用协议</p>
<p>1）可以重复利用IP地址（每个主机只有在于该网络连接时才有这个网络的IP地址）</p>
<p>2）便于移动用户连接进网络</p>
<p>7.DHCP协议的四个步骤：（不太会考，但是不难理解…记一下）</p>
<p>1）客户机发现DHCP服务器。host broadcasts “DHCP discover” msg</p>
<p>2）DHCP服务器提供报文，对客户机做出响应。DHCP server responds with “DHCP offer”<br>msg</p>
<p>3）客户机从DHCP提供的IP地址中选一个（可能有很多个DHCP服务器），发出请求响应。host<br>requests IP address: “DHCP request” msg</p>
<p>4）服务器发送ACK响应客户机请求。DHCP server sends address: “DHCP ack” msg</p>
<p>客户机收到ACK后 交互完成。</p>
<p>8.Q: How does network get subnet part of IP addr?</p>
<p>A: gets allocated portion of its provider ISP’s address space</p>
<p>获取IP地址的维护商ISP的地址空间？？</p>
<p>9.</p>
<p>Q: How does an ISP get block of addresses?</p>
<p>A: ICANN: Internet Corporation for Assigned Names and Numbers<br>互联网名称与数字地址分配机构</p>
<p>allocates addresses IP地址的空间分配</p>
<p>manages DNS 管理DNS</p>
<p>assigns domain names, resolves disputes 域名系统的管理，解决争端</p>
<p>10.网络地址转换（NAT Network Adress Translation）</p>
<p>11.具有专用地址的地域：指其地址仅对该网络中的设备有意义的网络。</p>
<p>12.由于专用地址仅在给定的网络中有意义，所以如果数以千计的家庭网络都使用10.0.0.0/24这个网络的话，怎么办呢？使用NAT.</p>
<p>13.家庭网络计算机从哪里得到其地址？路由器从哪里得到其单个IP地址？</p>
<p>路由器从ISP的DHCP服务器得到其地址，它再运行一个DHCP服务器，在NAT-DHCP路由器控制的家庭网络的地址空间中为计算机提供地址。</p>
<p>14.本地网只需要一个IP地址；本地网的各设备间的IP地址可以互相交换，外界不会知道；本地网可以在不改IP的情况下改变ISP；本地网里设备的地址不被外界所知（被NAT使能路由器隐藏了本地网的细节）</p>
<p>15.NAT路由器转换过程注意</p>
<p>家庭网向外界请求：</p>
<p>路由器将发送请求的源IP地址改为广域网一侧接口的IP地址</p>
<p>路由器生成新端口号时，可以选任意一个当前未在NAT转换表中使用的源端口号</p>
<p>把这个IP和端口号发送给目的主机。</p>
<p>目的主机响应时，什么都不知道，按照IP和端口号反馈回去，</p>
<p><strong>路由器在NAT转换表中，找到他们对应在家庭网络的IP和端口号，</strong>把数据报发送给家庭网。</p>
<p>NAT把运输层的端口号和网络层的IP地址结合了。</p>
<p>16.NAT端口长16位，支持60000多个并行使用广域网一侧IP地址的连接。</p>
<p>NAT很有争议。</p>
<p>17.有趣的问题，如果外界请求的服务器在家庭网中怎么办？</p>
<p>方法一，固定转发IP地址和接口，NAT将连接请求固定为服务器家庭IP和端口</p>
<p>方法二，UpnP，IGD</p>
<p>UpnP（即插即用）可以让一台主机（家庭网内）上运行的应用程序为某些请求的公共端口号请求一个NAT地址。如果NAT接收该请求，外部的节点就可以发起到（公共IP地址，公共端口号）的请求。比如家庭网的（10.0.0.1,<br>3345）请求映射到（138.76.29,7， 5001），这个主机就可以和外部世界联系了。</p>
<p>方法三，relaying(used in skype)</p>
<p>4.4.3 ICMP: Internet Control Message Protocol</p>
<p>1.ICMP报文：体系上是在IP之上，是作为IP有效载荷承载的。</p>
<p>2.差错报告：主机/网络/端口/协议不可达</p>
<p>echo回复/请求</p>
<p>3.ICMP报文：一个类型字段和一个编码字段，包含引起该ICMP报文首次生成IP数据报的首部和前8字节的内容。</p>
<p>4.Traceroute程序和ICMP。</p>
<p>4.4.4 IPv6</p>
<p>相比IPV4：</p>
<p>1）扩大地址容量，128比特</p>
<p>2）定长的40字节首部，简单高效</p>
<p>3）流标签与优先级，优先级给出一个流中某些数据报的优先级。</p>
<p>流标签标识一个数据报的流，20比特。</p>
<p>不在的：</p>
<p>4）切分和重组。</p>
<p>5）首部校验和</p>
<p>6）选项字段不在头部中，可能出现在 下一个头 字段中。</p>
<p><img src="media/11a034910e857ba98021bac13ea8bbab.png" alt=""></p>
<p>流量类型8比特：类似于v4中的TOS，区分数据类型。</p>
<p>有效载荷长度：16比特值，给出了v6数据报中跟在定长的40字节数据报首部后面的字节数量。</p>
<p>下一个首部：交付给哪个协议。和v4中的协议字段相同。</p>
<p>2.ICMPv6</p>
<p>1）增加了数据类型，“大数据包”</p>
<p>2）多广播组管理功能</p>
<p>3.隧道：两台IPv6路由器之间中间IPv4路由器的集合</p>
<p>4.5 选路算法</p>
<p>1.选路算法：寻找最低费用路径的算法</p>
<p>2.分类</p>
<p>1）全局选路算法，以所有节点之间的连通性及所有链路的费用为输入。</p>
<p>2）分布式选路算法，迭代的、分布式的方式计算最低费用路径。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/07/24/HandlerThread/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ke Yu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coco">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/07/24/HandlerThread/" itemprop="url">Effective Java 读书笔记（2.5）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-07-24T00:38:31+08:00">
                2017-07-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="HandlerThread"><a href="#HandlerThread" class="headerlink" title="HandlerThread"></a>HandlerThread</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Handler的目标是解决子线程与主线程通信的问题，HandlerThread则是解决子线程和子线程之间的通信问题，官方给的子线程实现handler的机制。<br>UI线程中的MessageQueue以及Looper是默认创建好的，只要创建Handler对象实例并调用handleMessage方法即可进行消息处理，而子线程要自己去自定义Looper才能实现相同的功能。<br>HandlerThread 继承自Thread类，主要就是增加了一个looper变量（looper.loop()可以取消息进行处理）</p>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> mPriority;</span><br><span class="line"><span class="keyword">int</span> mTid = -<span class="number">1</span>;</span><br><span class="line">Looper mLooper;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HandlerThread</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(name);</span><br><span class="line">    mPriority = Process.THREAD_PRIORITY_DEFAULT; <span class="comment">// 优先级默认是0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Call back method that can be explicitly overridden if needed to execute some</span></span><br><span class="line"><span class="comment"> * setup before Looper loops.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLooperPrepared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mTid = Process.myTid();</span><br><span class="line">    Looper.prepare();</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        mLooper = Looper.myLooper(); <span class="comment">// 创建Looper</span></span><br><span class="line">        notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">    Process.setThreadPriority(mPriority);---&gt;D <span class="comment">// 设置线程优先级</span></span><br><span class="line">    onLooperPrepared(); <span class="comment">// Looper创建后调用，可重写</span></span><br><span class="line">    Looper.loop(); <span class="comment">// 开始循环了</span></span><br><span class="line">    mTid = -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>getLooper时，如果这个thread 已经start了 （执行run）， Looper有可能还没有实例化结束，可能阻塞（有synchronized关键字），这也是为什么 创建Looper后，有notifyAll()的原因！<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This method returns the Looper associated with this thread. If this thread not been started</span></span><br><span class="line"><span class="comment"> * or for any reason is isAlive() returns false, this method will return null. If this thread </span></span><br><span class="line"><span class="comment"> * has been started, this method will block until the looper has been initialized.  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> The looper.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Looper <span class="title">getLooper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isAlive()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// If the thread has been started, wait until the looper has been created.</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (isAlive() &amp;&amp; mLooper == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mLooper;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>D.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">setThreadPriority</span><span class="params">(<span class="keyword">int</span> priority)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IllegalArgumentException, SecurityException</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Set the priority of the calling thread, based on Linux priorities.  See</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> #setThreadPriority(int, int)&#125; for more information.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> priority A Linux priority level, from -20 for highest scheduling</span></span><br><span class="line"><span class="comment"> * priority to 19 for lowest scheduling priority.</span></span><br></pre></td></tr></table></figure></p>
<p>用处：串行处理任务，主要是分担UI线程的一些耗时操作，不会干扰或阻塞UI线程。对于网络IO操作，HandlerThread并不适合，因为它只有一个线程，还得排队一个一个等着。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/07/07/EF3_8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ke Yu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coco">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/07/07/EF3_8/" itemprop="url">Effective Java 读书笔记（3.8）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-07-07T22:43:32+08:00">
                2017-07-07
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>第三章 对于所有对象都通用的方法</p>
<p>Object类的所有非final方法（equals，hashcode，toString，clone和finalize）都有明确的通用约定，因为这些方法是被设计成要被覆盖的，所以覆盖时需要遵循这些通用的约定。否则依赖这些约定的类（hashset,hashmap）等，就无法正常工作。</p>
<p>这一章主要是讨论何时以及如何覆盖这些非final的Object方法</p>
<p><strong>第8条 覆盖equals时请遵守通用约定</strong></p>
<h3 id="何时应该覆盖Object-equals？"><a href="#何时应该覆盖Object-equals？" class="headerlink" title="何时应该覆盖Object.equals？"></a>何时应该覆盖Object.equals？</h3><ul>
<li>①类具有自己特有的“逻辑相等”概念（<strong>不是对象等同</strong>），并且超类没有符号equals以实现期望的行为。<br>“值类”一般就属于这种，也就是仅仅表示值的类，比如Integer或者Date。<br>我们在使用equals方法时，希望知道他们逻辑上是否相等，而不是想知道他们是否指向同一个对象。</li>
</ul>
<p>要满足这种期望，不但要重写equals方法，还要使这个类的实例可以被map或者set用作key。</p>
<p>但是有一些“值类”不需要覆盖equals方法：比如用实例受控（第一条）来确保“每个值至多只存在一个对象”的类。枚举类型就属于这种类。对于这种类，逻辑相同和对象等同是一回事，所以Object的equals方法等同于逻辑意义上的equals方法。</p>
<p>覆盖equals方法时候，要遵守以下通用约定：<br>1）自反性。对于任何非null的引用值x，x.equals(x)必须返回true<br>2）对称性。对于任何非null的引用值x和y，x.equals(y)是等价的y.equals(x）</p>
<p>以下代码可能会违反这个特性：</p>
<p><img src="http://ovwunej09.bkt.clouddn.com/EF81.png" alt="clipboard.png"></p>
<p>这个比较是不区分大小写的，并且试图完成与普通String的互操作，但是</p>
<p>对于：</p>
<p><img src="http://ovwunej09.bkt.clouddn.com/EF82.png" alt="clipboard.png"></p>
<p>cis.equasl(s)会返回true，s.equals(cis)却会返回false，因为String的equal是区分大小写的</p>
<p>要想保持特性需要重构这个方法：</p>
<p><img src="http://ovwunej09.bkt.clouddn.com/EF83.png" alt="clipboard.png"></p>
<p><strong>感觉这个代码不对啊,,,, 如果是CIS了… 就不用转换了。但为什么还是&amp;&amp;？</strong></p>
<p><strong>这时，针对是同一个类的不同实例之间的比较，不再是不同类的不同实例的比较了。</strong></p>
<p>3）传递性。对于任何非null的引用值x,y和z，如果x.equals(y)并且y.equals(z)那么y.equals(z)</p>
<p><img src="http://ovwunej09.bkt.clouddn.com/EF84.png" alt="clipboard.png"></p>
<p>如果打算扩展这个类，增加颜色信息：</p>
<p><img src="http://ovwunej09.bkt.clouddn.com/EF85.png" alt="clipboard.png"></p>
<p>很明显，如果不重写equals，那么作equals操作时，颜色信息就会被忽略掉。</p>
<p>如果这样重写：</p>
<p><img src="http://ovwunej09.bkt.clouddn.com/EF86.png" alt="clipboard.png"></p>
<p>如果O只是一个普通Point，那么需要忽略颜色进行比较。</p>
<p><strong>问题：为什么不用super.equals(o)而用o.equals(this);</strong><br>如果O是一个有色Point，那么调用父类的equals比较位置，并且比较颜色。<br>由于进行A.equals(B)时，调用了子类的equals，说明A是有色Point，那么构造它肯定会首先构造父类（super(x,y)），所以在调用equals时，super.equals(o)意味着用A构造的父类对象和O进行位置的比较，再单独比较颜色。<br>但是假设：</p>
<p><img src="http://ovwunej09.bkt.clouddn.com/EF87.png" alt="clipboard.png"></p>
<p>那么p.equals(cp)，直接调用了普通Point的equals。首先cp instanceof<br>Point是真，那么就接着判断位置，相同的，所以返回true；</p>
<p>cp.equals(p)，调用的是有色Point的equals。首先p instanceof<br>ColorPoint是假，所以返回false。</p>
<p><strong>这样就丧失了对称性！</strong></p>
<p><strong>所以需要进行修改：</strong></p>
<p><img src="http://ovwunej09.bkt.clouddn.com/EF88.png" alt="clipboard.png"></p>
<p>先判断是不是Point，如果是的话，判断是不是colorPoint，不是的话说明它仅仅是普通点，那么调用o.equals(this),这样的话调用的就是父类的equal了。</p>
<p>否则当然就是有色点，先调用父类的equals，再比较color。</p>
<p><strong>这样虽然保留了对称性，但是丧失了传递性！</strong></p>
<p><img src="http://ovwunej09.bkt.clouddn.com/EF89.png" alt="clipboard.png"></p>
<p>p1.equals(p2)返回true,p2.equals(p3)也返回true，但是p1.equals(p3)却不能返回true。</p>
<p><strong>这是面向对象中关于等价关系的一个基本问题，我们无法在扩展可实例化的类的同时，既增加新的值组件，同时又保留equals约定。</strong></p>
<p><strong>如果使用getClass()代替instanceof测试，可以扩展可实例化的类和增加新的值组件，同时保留equals约定。</strong></p>
<p><img src="http://ovwunej09.bkt.clouddn.com/EF810.png" alt="clipboard.png"></p>
<p>但是<strong>这违反了里氏替换原则。</strong>此时只有当对象具有相同的实现时，才能使对象等同。这样不算糟糕，但是the<br>consequences are unacceptable</p>
<p><strong>为什么说违反了里氏替换原则？？</strong></p>
<p><strong>假设有一个方法，用来检验某个整值点是否处在单位圆中：</strong></p>
<p><img src="http://ovwunej09.bkt.clouddn.com/EF811.png" alt="clipboard.png"></p>
<p>加入我们扩展point但是不增加值组件，只是让构造器记录创建了多少个实例：</p>
<p><img src="http://ovwunej09.bkt.clouddn.com/EF812.png" alt="clipboard.png"></p>
<p>里氏替换原则表示：一个类型的任何重要属性也将适用于它的子类型。所以为该类型编写的任何方法，在它的子类型上也应该同样运行得很好。</p>
<p>但是如果我们使用getClass的equals方法，那么我们把CounterPoint实例传入，onUnitCircle方法都会返回false。</p>
<p>也就是说，我们很难找到一个很好的办法，既扩展不可实例化的类，又增加值组件。</p>
<p>有一种方法可以作为权宜之计：复合由于继承。（有点像适配器…..）</p>
<p>比如我们不让ColorPoint扩展Point，而是在ColorPoint中加入一个私有的Point域，以及一个共有的view方法。</p>
<p><img src="http://ovwunej09.bkt.clouddn.com/EF813.png" alt="clipboard.png"></p>
<p>4）一致性。对于任何非null的引用值x,y，只要equals操作用到的object的信息没有修改，那么对于多次调用，会一致返回true或者false.<br>如果x.equals(y)并且y.equals(z)那么y.equals(z)</p>
<p>可变对象在不同的时候可以与不同的对象相等，不可变对象则不会这样。</p>
<p>在写类的时候，就应该考虑是否应该不可变。如果是的话，那么要保持这样的限制条件：<strong>相等的对象永远相等，不相等的对象永远不相等。</strong></p>
<p>但是无论类是否可变，都不要使equals方法依赖于不可靠的资源比如java.net.URL的equals方法依赖于对URL中主机IP地址的比较。<br>很明显主机名转变为的IP地址具有不稳定性。</p>
<p>5）非空性。对于任何非null的引用值x，x.equals(null)一定返回false。</p>
<p>一些类在equals中首先使用:</p>
<p><img src="http://ovwunej09.bkt.clouddn.com/EF814.png" alt="clipboard.png"></p>
<p>其实没什么必要。通常来说是直接使用instanceof判断类型。</p>
<p><img src="http://ovwunej09.bkt.clouddn.com/EF815.png" alt="clipboard.png"></p>
<p>如果漏掉了这一步的类型检查，并且传递给equals方法的参数又是错误的类型，那么equals方法会抛出ClassCastException异常。</p>
<p>所以综合以上要求，实现高质量equals方法的技巧：</p>
<p><strong>①使用“==”检查“参数是否为这个对象的引用”</strong>，如果返回真，那么equals也可以返回true。特别是equals操作比较昂贵时，可以使用这种方法提高性能。</p>
<p><strong>②使用instanceof操作符检查“参数是否为正确的类型”</strong>。如果返回假，那么equals直接防护假。</p>
<p>如果类实现的接口改进了equals约定，允许在实现了该接口的类之间进行比较，那么</p>
<p><strong>③把参数转换成正确的类型。</strong>由于进行了第②步，所以这步一定会成功。</p>
<p><strong>④对于该类中的每个“关键”域，检查参数中的域是否与该对象中对应的域想匹配。</strong></p>
<p><strong>比如为了避免NullPointerException：</strong></p>
<p><img src="http://ovwunej09.bkt.clouddn.com/EF816.png" alt="clipboard.png"></p>
<p>但是如果field和o.field常常是相同的对象引用，那么可以使用下面的做法：</p>
<p><img src="http://ovwunej09.bkt.clouddn.com/EF817.png" alt="clipboard.png"></p>
<p>为了获得最佳的性能，应该最先比较最有可能不一致的域。</p>
<p>⑤编写完了equals方法之后，有三个问题需要注意：是否是对称的；是否第传递的；是否是一致的。</p>
<p>自反性和非空性通常会自动满足。</p>
<p>总结：</p>
<p>①覆盖equals总要覆盖hashCode</p>
<p>②不要企图让equals方法过于智能</p>
<p>③不要将equals声明中的Object对象替换为其他的类型</p>
<p><img src="http://ovwunej09.bkt.clouddn.com/EF818.png" alt="clipboard.png"></p>
<p>这种方法不是重写了equals而是重载了Object</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/07/06/EF2_7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ke Yu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coco">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/07/06/EF2_7/" itemprop="url">Effective Java 读书笔记（2.5）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-07-06T22:23:42+08:00">
                2017-07-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>第二章 创建和销毁对象</p>
<p><strong>第七条 避免使用终结（finalizer）方法</strong></p>
<h3 id="终结方法的缺点"><a href="#终结方法的缺点" class="headerlink" title="终结方法的缺点"></a><strong>终结方法的缺点</strong></h3><ul>
<li><p>①<strong>不能保证会被及时地执行，升职不能保证它会执行。</strong>从一个对象不可达开始，到它的终结方法被执行，所花费的这段时间是任意长的。</p>
<p>  比如，用终结方法来关闭已经打开的文件是不对的，因为打开文件的描述符是一种有限的资源。由于JVM会延迟执行终结方法，所以大量的文件会保留在打开的状态，当一个程序再不能打开文件的时候，可能会运行失败。</p>
<p>  <strong>及时执行终结方法是垃圾回收算法的一个主要功能，这种算法在不同的JVM实现中会大相径庭。</strong></p>
<p>  在一些情况下，为类提供终结方法，可能会随意地延迟其实例的回收过程。</p>
<p>  <strong>结论：不应该依赖终结方法来更新重要的持久状态。比如依赖终结方法释放共享资源（比如数据库）上的永久锁。</strong></p>
<p>  System.gc和System.runFinalization增加了终结方法被执行的机会，但不保证终结方法一定会被执行。唯一保证终结方法执行的方法是：System.runFinalizersOnExit和它臭名昭著的孪生兄弟：Runtime.runFinalizersOnExit.<br>  这两个方法都被废弃了。</p>
</li>
<li><p>②如果未被捕获的异常在终结过程中被抛出，那么这种异常会被忽略，并且该对象的终结过程也会被终止。这会使对象处于破坏的状态，如果有另一个线程企图使用这种被破坏的对象，会产生意想不到的结果。<strong>发生在终结方法中的异常不会打印出stack<br>trace.</strong></p>
</li>
<li><p><strong>③使用终结方法会有严重的性能损失。</strong></p>
<p>  <strong>如果类对象的资源（文件或者线程等）需要终止的话，怎么做才能不用编写终结方法呢？</strong></p>
<p>  <strong>提供显式的终止方法。</strong><br>  并要求该类的客户端在每个实例不再有用的时候调用这个方法。但是，<strong>实例必须记录下自己是否已经被终止了，需要在一个私域中记录下“该对象不再有效”，如果这些方法是在对象已经终止之后被调用，其他的方法就必须检查这个域，如果检查到这个域已经不再有效，就会抛出异常。</strong></p>
<p>  使用显式调用的终止方法的几个例子：<br>  a.InputStream；<br>  b.OutputStream<br>  c.java.sql.Connection 上的close方法<br>  d.java.util.Timer的cancel方法</p>
<p>  用法：</p>
<p>  <img src="http://ovwunej09.bkt.clouddn.com/EF71.png" alt="clipboard.png"></p>
<p>  在finally中显式地调用终止方法，即使try中有异常抛出，也会执行finally中的方法。</p>
</li>
</ul>
<h3 id="终结方法的优点"><a href="#终结方法的优点" class="headerlink" title="终结方法的优点"></a>终结方法的优点</h3><ul>
<li><p>①当对象的所有者<strong>忘记调用显式的终止方法时，终结方法可以充当“安全网”</strong>，虽然这个方法不会及时被调用，但如果客户端无法通过调用显式的终止方法来正常结束操作，那么迟一点释放资源总比不释放资源好。如果<strong>终结方法发现资源还未终止，则应该在日志中记录一条警告。这表示客户端中有bug。</strong></p>
<p>  刚才列举的显示调用终止方法的四个类，都有终结方法。终止方法未被调用的时候，终结方法会充当安全网。</p>
</li>
<li><p>②与对象的本地对等体（native peer）有关。本地对等体是一个本地对象（native object），<br>普通方法通过本地方法（native method）委托给一个本地对象，因为本地对等体不是一个普通对象，所以垃圾回收器不会知道它。它的JAVA对等体被回收的时候，它不会被回收。如果本地对等体拥有必须被及时终止的资源，那么该类就应该具有一个显式的终止方法。<strong>终止方法应该完成所有必要的工作以便释放关键的资源。</strong></p>
<p>  <strong>终止方法可以是本地方法，或者它也可以调用本地方法。</strong></p>
<p>  “终结方法链”并不会被自动执行。如果类有终结方法，并且子类覆盖了终结方法，子类的终结方法就必须手工调用超类的终结方法。<strong>可以在try块中终结子类，并在相应的finally块中调用超类的终结方法。<br>这样即使子类的终结过程抛出异常，超类的终结方法也会执行。反之亦然。</strong></p>
<p>  <strong>如果子类覆盖了超类的终结方法，但忘记手工调用超类supe的终结方法，怎么避免这种粗心或者恶意？？</strong></p>
<p>  <strong>为每个要被终结的对象（外围实例Foo）创建一个附加的对象，把终结方法放到匿名类中，这个匿名类（下图的finalizerGuardian）的作用就是终结它的外围实例。这个匿名类的单个实例被称为终结方法守卫者（finallzer guardian）</strong></p>
<p>  <img src="http://ovwunej09.bkt.clouddn.com/EF72.png" alt="clipboard.png"></p>
<p>  外围类的每个实例都会创建这样一个守卫者，<strong>外围实例在它的私有实例域中保存着一个对其终结方法守卫者的唯一引用</strong>，所以终结方法守卫者和外围实例可以同时启动终结过程。</p>
<p>  <strong>守卫者被终结的时候，它执行外围实例所期望的终结行为</strong>，就好像它的终结方法是外围对象上的一个方法一样。</p>
<p>  这个例子中的Foo没有终结方法，它的子类所以是否调用super.finalize并不重要。</p>
<p>  <strong>但是对于带有finalize的非final公有类，都应该考虑使用守卫者的这种方法以确保子类不调用super.finalize时也能执行终结方法。</strong></p>
<p>  所以，只有需要以上两种用途的时候，需要使用终结方法，其他时候，最好都不要使用。</p>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/07/04/EF2_6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ke Yu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coco">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/07/04/EF2_6/" itemprop="url">Effective Java 读书笔记（2.1）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-07-04T23:53:42+08:00">
                2017-07-04
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>第二章 创建和销毁对象</p>
<p><strong>第6条.消除过期的对象引用</strong></p>
<h3 id="内存泄漏的一个原因—-过期的对象引用"><a href="#内存泄漏的一个原因—-过期的对象引用" class="headerlink" title="内存泄漏的一个原因—-过期的对象引用"></a>内存泄漏的一个原因—-过期的对象引用</h3><p><img src="http://ovwunej09.bkt.clouddn.com/EF61.png" alt="clipboard.png"></p>
<p>pop()后，从栈中弹出的对象不会被当做垃圾回收，（这些对象只是不能再从栈中取到而已），下标大于等于size的部分，属于对象的过期引用（永远不会被解除的引用），这就造成了内存泄漏。</p>
<h4 id="修复方法"><a href="#修复方法" class="headerlink" title="修复方法"></a>修复方法</h4><p>只要对象引用过期，就清空这些引用，pop()像这样修改：</p>
<p><img src="http://ovwunej09.bkt.clouddn.com/EF62.png" alt="clipboard.png"></p>
<p>这样就清除了过期引用，并且如果以后又被错误地解除引用，程序还会抛出nullPointerException异常。<br>但<strong>清除对象引用只是一种例外，不是一种规范工作。清除过期引用的最好方法是让包含该引用的变量结束其生命周期。</strong></p>
<p><strong>何时应该清除引用？</strong><br>在<strong>需要自己管理内存的时候需要格外注意</strong>。比如我们举例的Stack类。存储池中包含了elements数组，垃圾回收期不知道哪些是活动的，哪些是非活动的，所以程序员需要在数组元素变成非活动部分的一部分的时候，手工清空这些数组元素。</p>
<h3 id="缓存造成的内存泄漏"><a href="#缓存造成的内存泄漏" class="headerlink" title="缓存造成的内存泄漏"></a>缓存造成的内存泄漏</h3><p>对象引用放到缓存中后，很容易被遗忘掉。</p>
<h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>只要缓存之外有对某个项的<strong>键</strong>的引用，该项就有意义，可以使用WeakHashMap。缓存中的项过期后，他们会被自动删除。</p>
<p>但是 缓存项的生命周期是否有意义<br>并不是很容易确定，随着时间推移，其中的项会变得越来越没有价值，所以缓存应该时不时清楚掉没用的项，可以使用后台线程（如timer或者scheduledThreadPoolExcutor）来完成。</p>
<h3 id="监听器和其他回调"><a href="#监听器和其他回调" class="headerlink" title="监听器和其他回调"></a>监听器和其他回调</h3><p>比如在一个API中注册回调，但没有显式的取消注册。</p>
<h4 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h4><p>确保回调立即被当作垃圾回收的最佳方法是只保存他们的弱引用，比如，只将他们保存成WeakHashMap中的键。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/07/03/EF2_5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ke Yu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coco">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/07/03/EF2_5/" itemprop="url">Effective Java 读书笔记（2.5）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-07-03T22:23:42+08:00">
                2017-07-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>第二章 创建和销毁对象</p>
<p><strong>第五条.避免创建不必要的对象</strong></p>
<h3 id="①"><a href="#①" class="headerlink" title="①"></a>①</h3><p><img src="http://ovwunej09.bkt.clouddn.com/EF50.png" alt="clipboard.png"></p>
<p>传进去的参数“stringette”本身就是一个实例，然后又用new新建一个实例。很明显创建了不必要的实例。</p>
<p><img src="http://ovwunej09.bkt.clouddn.com/EF51.png" alt="clipboard.png"></p>
<p>这种方法，就只会创建一个实例。</p>
<h3 id="②"><a href="#②" class="headerlink" title="②"></a><strong>②</strong></h3><p><img src="http://ovwunej09.bkt.clouddn.com/EF52.png" alt="clipboard.png"></p>
<p><img src="http://ovwunej09.bkt.clouddn.com/EF53.png" alt="clipboard.png"></p>
<p>TimeZone tz1 = timeZone.getTimeZone(“GMT”); // 指定时区<br>Calendar cal1 = Calendar.getInstance(tz1); // 使用指定的时区和当前语言环境的日历<br>每次isbabyboomer()被调用的时候，都会创建一个calendar，一个timezone和两个date。<br>改进：将两个Date声明为static<br>final，把他们的初始化和Calendar的声明定义一起放到static代码块中。</p>
<p><img src="http://ovwunej09.bkt.clouddn.com/ef54.png" alt="clipboard.png"></p>
<p>这种方法只在类初始化时创建Date，Calendar，TimeZone一次。不会在每次调用isBabyBoomer()的时候创建这些实例，那么<strong>万一isBabyBoomer()永远不被调用</strong>，不是浪费了BoomStart和BoomEND吗？可以采用延迟初始化的方法进行，也就是第一次调用isBabyBoomer()的时候进行初始化。但书上不建议这么做，认为这会使方法变得更复杂，并且无法带来太大的性能提高。</p>
<h3 id="③考虑适配器，也被叫做视图。"><a href="#③考虑适配器，也被叫做视图。" class="headerlink" title="③考虑适配器，也被叫做视图。"></a>③考虑适配器，也被叫做视图。</h3><p>Map接口的keySet()返回Map对象的Set视图，视图中包含Map中所以的key。每次调用keySet()返回的都是同样的Set实例。所以当对其中一个返回Set实例进行更改时，其他的Set实例也会被改变。</p>
<p>④JAVA5开始，有一种<strong>创建多余对象的新方法，也就是自动装箱。</strong>基本类型和装箱类型混用，按需要自动装箱或者拆箱，他们的差别变得模糊，但还是有区别。比如以下这个例子：</p>
<p><img src="http://ovwunej09.bkt.clouddn.com/EF55.png" alt="clipboard.png"></p>
<p>这样程序会构造2\^31个多余的Long实例，在for循环中，每次增加long时，i都会被转为Long实例。如果把sum的声明从Long改成long，会显著提高性能。</p>
<p>建议：<strong>优先使用基本类型而不是装箱基本类型，</strong>以防止无意识的自动装箱。</p>
<p>但是这个条目并不是说要避免创建对象，一些小对象的创建和回收动作是很廉价的，所以通过创建附加的对象，可以提升程序的清晰性、简洁性和功能性。<br>维护自己的对象池反而不是一种好做法。除非其中的对象非常重量级。（比如android中的bitmap）。维护对象池会增加内存的占用，损害性能，所以进行不要使用轻量级对象池。</p>
<p>对象池的典型用法：数据库连接池。<br>建立数据库连接代价很昂贵，所以重用对象很有意义。</p>
<p>这个条目讲的是<strong>，应该重用现有对象的时候，不要创建新的对象。</strong></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.jpg"
                alt="Ke Yu" />
            
              <p class="site-author-name" itemprop="name">Ke Yu</p>
              <p class="site-description motion-element" itemprop="description">Keep moving. Don't settle.</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">34</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">7</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">47</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Ke Yu</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
