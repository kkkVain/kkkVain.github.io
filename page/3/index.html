<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="en">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="Keep moving. Don&apos;t settle.">
<meta property="og:type" content="website">
<meta property="og:title" content="Coco">
<meta property="og:url" content="http://yoursite.com/page/3/index.html">
<meta property="og:site_name" content="Coco">
<meta property="og:description" content="Keep moving. Don&apos;t settle.">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Coco">
<meta name="twitter:description" content="Keep moving. Don&apos;t settle.">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/3/"/>





  <title>Coco</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Coco</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Hello world</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/11/查找算法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ke Yu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coco">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/11/查找算法/" itemprop="url">常见查找算法总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-09-11T19:31:14+08:00">
                2017-09-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="一、静态查找"><a href="#一、静态查找" class="headerlink" title="一、静态查找"></a>一、静态查找</h3><h4 id="1）顺序查找：时间复杂度O（N）"><a href="#1）顺序查找：时间复杂度O（N）" class="headerlink" title="1）顺序查找：时间复杂度O（N）"></a>1）顺序查找：<strong>时间复杂度O（N）</strong></h4><p><strong>平均查找长度：(n+1）/2  </strong><br><strong>优点：对表的结构没有要求</strong></p>
<h4 id="2）二分查找：期望时间复杂度O（logN）这是一定的！"><a href="#2）二分查找：期望时间复杂度O（logN）这是一定的！" class="headerlink" title="2）二分查找：期望时间复杂度O（logN）这是一定的！"></a>2）二分查找：<strong>期望时间复杂度O（logN）这是一定的！</strong></h4><p><strong>平均查找长度：log(N+1)-1</strong><br><strong>成功查找为log(N）+1</strong><br><strong>不成功查找为log(N）+1</strong></p>
<p>如果需要添加或者删除一个数据，整个结构都要重建，代价太大。<br>优点：时间性能比顺序查找好，效率较高<br>缺点：只适用于顺序存储结构</p>
<p>扩展：</p>
<p><strong>插值查找</strong>， 不从1/2处断开，而是从1/3,1/4等等地方分开。<br>时间复杂度为O（log(logN))<br><strong>适合于关键字分布又均匀的表。</strong> 如果分布不均匀，那么不适合用插值查找。<br>mid=(low+high)/2, 即mid=low+1/2*(high-low);<br>通过类比，我们可以将查找的点改进为如下：<br>mid=low+<strong>(key-a[low])/(a[high]-a[low])</strong>*(high-low)，<br>斐波那契查找，按黄金比例进行分割。</p>
<h4 id="3）分块查找"><a href="#3）分块查找" class="headerlink" title="3）分块查找"></a>3）分块查找</h4><p>也称索引顺序查找。是1）和2）的改进。<br>把线性表分为若干块；块内无序；块间有序<br>建立一个索引表，存储<strong>每块内的最大值和这块的起始地址</strong>。</p>
<p><strong>时间复杂度为O（N）~ O（logN）</strong><br><strong>平均查找长度：(n/s+s)/2+1 ( s是每块的元素个数）</strong><br><strong>优点：顺序存储和链式存储都适用；查找效率高</strong><br><strong>缺点：需要将表分块排序，并且需要为索引表增加存储空间</strong></p>
<p><img src="http://ovwunej09.bkt.clouddn.com/search01.png" alt="conclusion"></p>
<h3 id="二、动态查找"><a href="#二、动态查找" class="headerlink" title="二、动态查找"></a>二、动态查找</h3><h4 id="3）二叉查找树：便于插入和删除，解决了2）的问题"><a href="#3）二叉查找树：便于插入和删除，解决了2）的问题" class="headerlink" title="3）二叉查找树：便于插入和删除，解决了2）的问题"></a>3）二叉查找树：便于插入和删除，解决了2）的问题</h4><p>树可能退化为线性结构，<strong>此时是最坏情况，O（N）</strong><br><strong>最好情况是O（logN）</strong></p>
<h4 id="4）平衡二叉树-AVL-其实是平衡二叉查找树）"><a href="#4）平衡二叉树-AVL-其实是平衡二叉查找树）" class="headerlink" title="4）平衡二叉树(AVL,其实是平衡二叉查找树）"></a>4）平衡二叉树(AVL,其实是平衡二叉查找树）</h4><p>不会出现3的最坏情况。<br><strong>时间复杂度是O（logN） </strong><br>插入、删除时需要做左旋和右旋等操作。</p>
<p>平衡二叉树又被称为AVL树（有别于AVL算法），且具有以下性质：<strong>它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。</strong></p>
<h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>(1) 查找代价：</p>
<p>AVL是严格平衡的BST（平衡因子不超过1）。那么查找过程与BST一样，只是AVL不会出现最差情况的BST(单支树)。因此<strong>查找效率最好，最坏情况都是O(logN)数量级的。</strong></p>
<p>(2) 插入代价：</p>
<p>AVL必须要保证严格平衡<strong>(|bf|\&lt;=1)</strong>，那么每一次插入数据使得AVL中某些结点的平衡因子超过1就必须进行旋转操作。事实上，AVL的每一次插入结点操作最多只需要旋转1次(单旋转或双旋转)。<strong>因此，总体上插入操作的代价仍然在O(logN)级别上</strong>(插入结点需要首先查找插入的位置)。</p>
<p>(3) 删除代价：</p>
<p>AVL删除结点的算法可以参见BST的删除结点，但是<strong>删除之后必须检查从删除结点开始到根结点路径上的所有结点的平衡因子。因此删除的代价稍微要大一些。每一次删除操作最多需要O(logN)次旋转。因此，删除操作的时间复杂度为O(logN)+O(logN)=O(2logN)</strong></p>
<p>缺点：</p>
<ul>
<li>为了保持平衡性，动态插入和删除的代价过高；</li>
<li>二叉查找树的查找代价都与树高有关，所以需要减小树高。</li>
</ul>
<h4 id="5）红黑树：并不完全平衡"><a href="#5）红黑树：并不完全平衡" class="headerlink" title="5）红黑树：并不完全平衡"></a>5）红黑树：并不完全平衡</h4><p>根节点为黑色；所有叶子节点是黑色；每个红色节点的两个子节点是黑色；<br><strong>时间复杂度：O（logN)进行搜索、插入、删除。</strong></p>
<h5 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h5><p><strong>(1) 查找代价：</strong></p>
<p><strong>由于红黑树的性质(最长路径长度不超过最短路径长度的2倍)，可以说明红黑树虽然不像AVL一样是严格平衡的，但平衡性能还是要比BST要好。其查找代价基本维持在O(logN)左右，但在最差情况下(最长路径是最短路径的2倍少1)，比AVL要略逊色一点。</strong></p>
<p><strong>(2) 插入代价：</strong></p>
<p><strong>RBT插入结点时，需要旋转操作和变色操作。但由于只需要保证RBT基本平衡就可以了。因此插入结点最多只需要2次旋转，这一点和AVL的插入操作一样。虽然变色操作需要O(logN)，但是变色操作十分简单，代价很小。</strong></p>
<p><strong>(3) 删除代价：</strong></p>
<p><strong>RBT的删除操作代价要比AVL要好的多，删除一个结点最多只需要3次旋转操作。</strong></p>
<h4 id="6）多路查找树（B-B"><a href="#6）多路查找树（B-B" class="headerlink" title="6）多路查找树（B~,B+)"></a>6）多路查找树（B~,B+)</h4><p>一个节点上拥有多于2个节点的二叉查找树。<br>B（B-）树：待插入结构图</p>
<h5 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h5><p>(1) 查找代价：</p>
<p>B-Tree作为一个平衡多路查找树(m-叉)。B树的查找分成两种：一种是从一个结点查找另一结点的地址的时候，需要定位磁盘地址(查找地址)，查找代价极高。另一种是将结点中的有序关键字序列放入内存，进行优化查找(可以用折半)，相比查找代价极低。而<strong>B树的高度很小，因此在这一背景下，B树比任何二叉结构查找树的效率都要高很多。而且B+树作为B树的变种，其查找效率更高。</strong></p>
<p>(2)插入代价：</p>
<p><strong>B-Tree的插入会发生结点的分裂操作。当插入操作引起了s个节点的分裂时，磁盘访问的次数为h(读取搜索路径上的节点)＋2s(回写两个分裂出的新节点)＋1（回写新的根节点或插入后没有导致分裂的节点）。因此，所需要的磁盘访问次数是h+2s+1，最多可达到3h+1。因此插入的代价是很大的。</strong></p>
<p>(3)删除代价：</p>
<p><strong>B-Tree的删除会发生结点合并操作。最坏情况下磁盘访问次数是3h＝（找到包含被删除元素需要h次读访问）+（获取第2至h层的最相邻兄弟需要h-1次读访问）+（在第3至h层的合并需要h-2次写访问）+（对修改过的根节点和第2层的两个节点进行3次写访问）。</strong></p>
<p>B+：待插入结构图</p>
<p>应用场景：<br>来自知乎<a href="https://www.zhihu.com/question/30527705/answer/52750388：" target="_blank" rel="noopener">https://www.zhihu.com/question/30527705/answer/52750388：</a><br>AVL是一种高度平衡的二叉树，所以通常的结果是，维护这种高度平衡所付出的代价比从中获得的效率收益还大，故而实际的应用不多，更多的地方是用追求局部而不是非常严格整体平衡的红黑树。当然，如果场景中对插入删除不频繁，只是对查找特别有要求，AVL还是优于红黑的。<br>红黑树的应用就很多了，除了上面同学提到的STL，还有</p>
<ul>
<li>著名的linux进程调度<a href="https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Completely_Fair_Scheduler" target="_blank" rel="noopener">Completely Fair<br>Scheduler</a>,用红黑树管理进程控制块</li>
<li>epoll在内核中的实现，用红黑树管理事件块</li>
<li>nginx中，用红黑树管理timer等</li>
<li>Java的TreeMap实现<br>B和B+主要用在文件系统以及数据库中做索引等，比如Mysql：<a href="https://link.zhihu.com/?target=https%3A//guptavikas.wordpress.com/2012/12/17/b-tree-index-in-mysql/" target="_blank" rel="noopener">B-Tree Index in<br>MySql</a></li>
</ul>
<p>trie树的一个典型应用是前缀匹配，比如下面这个很常见的场景，在我们输入时，搜索引擎会给予提示</p>
<h4 id="7）哈希"><a href="#7）哈希" class="headerlink" title="7）哈希"></a>7）哈希</h4><p>查找复杂度<strong>为O（1）</strong>，可以通过变换哈希函数在空间和时间上做出权衡。</p>
<p><img src="media/20d9923d23ee1ed7437cb641fa9dd379.png" alt="clipboard.png"></p>
<p>平均查找长度：<strong>等概率</strong>下一次查找<strong>所有元素</strong>的比较次数。<br>二分查找，查找成功的最大次数为：logN（取下限），logN（取下限）+1。</p>
<h4 id="相关题目（基础知识应用）"><a href="#相关题目（基础知识应用）" class="headerlink" title="相关题目（基础知识应用）"></a>相关题目（基础知识应用）</h4><p>1.长度为12的无重复有序表，查找成功的平均比较次数为：37/12<br>把1到12的查找次数都算出来相加除以12（这方法太傻<br>注意：查找1的次数为3,2的次数为2，所以二分法用的是法1， 不是法2<br>画二叉树来计算：</p>
<pre><code>      6

3             9
</code></pre><p>   2    5     7         11</p>
<p>1     4          8   10  12</p>
<p>1*1+2*2+4*3+5*4=37</p>
<p>2.但是找77 ，34,99 这三个数的时候又是用法二…</p>
<p>3.顺序查找都是将target与元素逐一比较，所以无论表是有序还是无序，查找长度都是n</p>
<p>4.设有关键字n=2\^h-1，<br>构成二叉排序树……，概率相等，查找成功的ASL最大是n：错。<br>注意读题！ASL是平均查找长度，最坏为线性查找（n+1)/2,<br>时间复杂度为O（n），注意n和O（n）是不同的！！</p>
<p>5.找82的那个数，比较4次，用的方法2…</p>
<p>6.从n个数中找最大的两个数理论上需要几次比较：<br>找最大的：n-1    找第二大的：logn-1<br>一共n+logn-2</p>
<p>7.顺序查找中，有序表和无序表的查找失败的平均查找长度不同：<br>对于有序表，如果找不到，可以直接退出<br>对于无序表，要全部遍历完才可以确定查找失败。</p>
<p>8.既希望较快的查找又便于<strong>线性表</strong>动态变化的查找方法是：<strong>索引顺序查找。</strong></p>
<p><strong>不是哈希！如果哈希的存储不是链式，一般情况随着关键字的增多，冲突频繁发生，查找性能会下降，并且利于动态变化。</strong></p>
<p>9.<strong>n个顶点的树一定有n-1条边</strong>，所以如果n个顶点m条边的全连通图需要去掉m-(n-1)条边</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/10/eventBus/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ke Yu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coco">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/10/eventBus/" itemprop="url">EventBus源码解析(1)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-09-10T20:19:30+08:00">
                2017-09-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>3.EventBus</strong></p>
<p>由于没有用过，所以先在这里理解一下几个重点名词：</p>
<p>event：我们想监听的事件，比如点击按钮，网页请求返回了响应</p>
<p>eventType：我们想监听的事件的类型</p>
<p>subscrible：订阅者，订阅事件的对象，当订阅者订阅的事件发生后，就会执行订阅者的响应函数，onEvent。</p>
<p><strong>使用第一步：在接收消息的activity中(onStart())</strong></p>
<p><strong>EventBus.getDefault().register(this); —>B</strong></p>
<p><strong>字母开头和1字母开头的，都是rigister的延伸。</strong></p>
<p><strong>使用第二步：在发送消息的activity中，</strong></p>
<p><strong>EventBus.getDefault().post(new Event(“Event btn clicked”)); ——>2A</strong></p>
<p><strong>2字母开头的，都是这个的延伸。</strong></p>
<p><strong>使用第三步：在接收消息的activity中（onStop())</strong></p>
<p><strong>EventBus.getDefault().unregister(this);——->3A</strong></p>
<p><strong>①EventBus.JAVA</strong></p>
<p><strong>A.</strong></p>
<p>单例模式，双重检查+volatile ，获取eventBus的实例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">volatile</span> EventBus defaultInstance;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> EventBus <span class="title">getDefault</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (defaultInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">synchronized</span> (EventBus.class) &#123;</span><br><span class="line">			<span class="keyword">if</span> (defaultInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">				defaultInstance = <span class="keyword">new</span> EventBus();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> defaultInstance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>3A.</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Unregisters the given subscriber from all event classes. 这是通过订阅者找出订阅类型来注销这个订阅者的所有订阅*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">unregister</span><span class="params">(Object subscriber)</span> </span>&#123;</span><br><span class="line"><span class="comment">//取出订阅者订阅的所有事件类型</span></span><br><span class="line">List&lt;Class&lt;?&gt;&gt; subscribedTypes = typesBySubscriber.get(subscriber);</span><br><span class="line">	<span class="keyword">if</span> (subscribedTypes != <span class="keyword">null</span>) &#123;</span><br><span class="line">	<span class="comment">//遍历所有事件类型，注销订阅</span></span><br><span class="line">	<span class="keyword">for</span> (Class&lt;?&gt; eventType : subscribedTypes) &#123;</span><br><span class="line">		unsubscribeByEventType(subscriber, eventType);----&gt;<span class="number">3</span>B</span><br><span class="line">	&#125;</span><br><span class="line">	typesBySubscriber.remove(subscriber);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123; <span class="comment">//这个订阅者没有订阅过任何事件。</span></span><br><span class="line">	但是，没有订阅过，有可能register啊...？？？？</span><br><span class="line">	Log.w(TAG, <span class="string">"Subscriber to unregister was not registered before: "</span> + subscriber.getClass());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>3B.</strong></p>
<p><strong>更新subscriptionsByEventType，而不是typesBySubscriber，typesBySubscriber在3A中（unregister)更新了</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Only updates subscriptionsByEventType, not typesBySubscriber! Caller must</span></span><br><span class="line"><span class="comment">update typesBySubscriber. 这是通过事件类型找出所有订阅者来取消订阅*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unsubscribeByEventType</span><span class="params">(Object subscriber, Class&lt;?&gt; eventType)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//通过事件类型取出订阅该类型的所有subscriptions，**注意，定义的时候，value是copyOnWriteList,这里就直接List了？？**</span></span><br><span class="line">List&lt;Subscription&gt; subscriptions =</span><br><span class="line">subscriptionsByEventType.get(eventType);</span><br><span class="line">	<span class="keyword">if</span> (subscriptions != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">int</span> size = subscriptions.size();</span><br><span class="line"><span class="comment">//遍历subscription,找到当前要注销的subcriber，更改active状态，并且从这个list中将它移出</span></span><br><span class="line"><span class="comment">// 这个find并且remove的过程- -真是清新自然，没有更简单的方法？？</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">			Subscription subscription = subscriptions.get(i);</span><br><span class="line">			<span class="keyword">if</span> (subscription.subscriber == subscriber) &#123;</span><br><span class="line">				subscription.active = <span class="keyword">false</span>;</span><br><span class="line">				subscriptions.remove(i);</span><br><span class="line">				i--;</span><br><span class="line">				size--;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2A.</strong></p>
<p><strong>从这里到2I，都是这个函数的延伸。</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">post</span><span class="params">(Object event)</span> </span>&#123;</span><br><span class="line">	PostingThreadState postingState =</span><br><span class="line">	currentPostingThreadState.get();---&gt;<span class="number">2</span>B</span><br><span class="line">	List&lt;Object&gt; eventQueue = postingState.eventQueue; <span class="comment">//postingThread的queue</span></span><br><span class="line">	eventQueue.add(event); <span class="comment">//向这个List添加事件</span></span><br><span class="line">	<span class="keyword">if</span> (!postingState.isPosting) &#123;</span><br><span class="line">		<span class="comment">//这个boolean值，都没有被赋值过...所以是取默认值？？boolean的默认值是false，所以就说得通了。</span></span><br><span class="line">		<span class="comment">//判断进行post的线程是否主线程</span></span><br><span class="line">		postingState.isMainThread = Looper.getMainLooper() == Looper.myLooper();</span><br><span class="line">		<span class="comment">//当前线程的isPosting为真</span></span><br><span class="line">		postingState.isPosting = <span class="keyword">true</span>;</span><br><span class="line">		<span class="comment">//如果取消了，抛出异常。</span></span><br><span class="line">		<span class="keyword">if</span> (postingState.canceled) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">"Internal error. Abort state was not reset"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">while</span> (!eventQueue.isEmpty()) &#123;</span><br><span class="line">				<span class="comment">//如果当前线程要post的事件队列不为空，取出队首，执行了postSingleEventForEventType，然后在里面又执行了postToSubscription，完成了post</span></span><br><span class="line">				postSingleEvent(eventQueue.remove(<span class="number">0</span>), postingState);---&gt;<span class="number">2</span>D</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			<span class="comment">//finally里面初始化成员变量</span></span><br><span class="line">			postingState.isPosting = <span class="keyword">false</span>;</span><br><span class="line">			postingState.isMainThread = <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>2D.</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postSingleEvent</span><span class="params">(Object event, PostingThreadState postingState)</span> <span class="keyword">throws</span> Error </span>&#123;</span><br><span class="line">	Class&lt;?&gt; eventClass = event.getClass();</span><br><span class="line">	<span class="keyword">boolean</span> subscriptionFound = <span class="keyword">false</span>;</span><br><span class="line">	<span class="keyword">if</span> (eventInheritance) &#123;</span><br><span class="line">	List&lt;Class&lt;?&gt;&gt; eventTypes = lookupAllEventTypes(eventClass);---&gt;<span class="number">2</span>E,得到这个eventClass的所有超类和父接口（也就是它可以对应的所有事件类型）</span><br><span class="line">	<span class="keyword">int</span> countTypes = eventTypes.size();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> h = <span class="number">0</span>; h &lt; countTypes; h++) &#123;</span><br><span class="line">			Class&lt;?&gt; clazz = eventTypes.get(h);</span><br><span class="line">			subscriptionFound |= postSingleEventForEventType(event, postingState, clazz);----&gt;<span class="number">2</span>G，在postSingleEventForEventType里面遍历所有监听了这个事件类型的subcription,通过postToSubscription去找线程调用订阅者的响应方法</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123; <span class="comment">//没有进入else，就直接调用postSingleEventForEventType	</span></span><br><span class="line">		subscriptionFound = postSingleEventForEventType(event, postingState, eventClass);----&gt;<span class="number">2</span>G</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!subscriptionFound) &#123;<span class="comment">//如果</span></span><br><span class="line">postSingleEventForEventType没执行成功，也就是这个事件没有订阅者订阅这类事件！！</span><br><span class="line">		<span class="keyword">if</span> (logNoSubscriberMessages) &#123;</span><br><span class="line">			Log.d(TAG, <span class="string">"No subscribers registered for event "</span> + eventClass);</span><br><span class="line">		&#125;</span><br><span class="line"><span class="comment">//这个判断有点奇怪。 eventClass 和 NoSubscriberEvent.class</span></span><br><span class="line">,怎么可能相等...不过看到post(<span class="keyword">new</span>...）就明白了，最开始的时候当然都是！=，不过重新<span class="keyword">new</span>了NoSubscriberEvent去post，当然可能==了。</span><br><span class="line">		<span class="keyword">if</span> (sendNoSubscriberEvent &amp;&amp; eventClass != NoSubscriberEvent.class &amp;&amp; eventClass != SubscriberExceptionEvent.class) &#123;----&gt;<span class="number">2</span>H，<span class="number">2</span>I</span><br><span class="line">			post(<span class="keyword">new</span> NoSubscriberEvent(<span class="keyword">this</span>,event));<span class="comment">//用当前类（调用post的类）和被post的event构造NoSubscriberEvent，所以有可能出现if中的第二种情况!!厉害了。但是第三种呢？？</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2H.</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 被post的事件没有订阅者订阅 哈哈哈哈哈 好惨</span></span><br><span class="line"><span class="comment"> This Event is posted by EventBus when no subscriber is found for a posted event.</span></span><br><span class="line"><span class="comment"> @author Markus</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NoSubscriberEvent</span> </span>&#123;</span><br><span class="line"><span class="comment">/* The &#123;\@link EventBus&#125; instance to with the original event was posted to.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">final</span> EventBus eventBus;</span><br><span class="line">	<span class="comment">/* The original event that could not be delivered to any subscriber. */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">final</span> Object originalEvent;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">NoSubscriberEvent</span><span class="params">(EventBus eventBus, Object originalEvent)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.eventBus = eventBus;</span><br><span class="line">		<span class="keyword">this</span>.originalEvent = originalEvent;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2I.</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 这个post的事件在订阅者响应函数中出现异常（需要理解下...</span></span><br><span class="line"><span class="comment"> This Event is posted by EventBus when an exception occurs inside a subscriber's event handling method.*</span></span><br><span class="line"><span class="comment"> @author Markus*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SubscriberExceptionEvent</span> </span>&#123;</span><br><span class="line"><span class="comment">/* The &#123;\@link EventBus&#125; instance to with the original event was posted to.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">final</span> EventBus eventBus;</span><br><span class="line">	<span class="comment">/* The Throwable thrown by a subscriber.*/</span></span><br><span class="line">	<span class="comment">//订阅者抛出的异常</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">final</span> Throwable throwable;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* The original event that could not be delivered to any subscriber. */</span></span><br><span class="line">	<span class="comment">//无法再被post给任何订阅者的event</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">final</span> Object causingEvent;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* The subscriber that threw the Throwable. */</span></span><br><span class="line">	<span class="comment">//抛出异常的订阅者</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">final</span> Object causingSubscriber;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">SubscriberExceptionEvent</span><span class="params">(EventBus eventBus, Throwable throwable,Object causingEvent,Object causingSubscriber)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.eventBus = eventBus;</span><br><span class="line">		<span class="keyword">this</span>.throwable = throwable;</span><br><span class="line">		<span class="keyword">this</span>.causingEvent = causingEvent;</span><br><span class="line">		<span class="keyword">this</span>.causingSubscriber = causingSubscriber;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2G.</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">postSingleEventForEventType</span><span class="params">(Object event, PostingThreadState postingState, Class&lt;?&gt; eventClass)</span> </span>&#123;</span><br><span class="line">	CopyOnWriteArrayList&lt;Subscription&gt; subscriptions;</span><br><span class="line">	<span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">	<span class="comment">//取出这个事件class所涉及的所有subscription(里面存储了订阅者和处理这个事件的方法）</span></span><br><span class="line">		subscriptions = subscriptionsByEventType.get(eventClass);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 这个if里面，不是一个意思？？？</span></span><br><span class="line">	<span class="comment">// 存在订阅这种事件类型的订阅者</span></span><br><span class="line">	<span class="keyword">if</span> (subscriptions != <span class="keyword">null</span> &amp;&amp; !subscriptions.isEmpty()) &#123;</span><br><span class="line">		<span class="keyword">for</span> (Subscription subscription : subscriptions) &#123;</span><br><span class="line">			<span class="comment">//遍历所有的subscription,设置postingState的参数</span></span><br><span class="line">			postingState.event = event;</span><br><span class="line">			postingState.subscription = subscription;</span><br><span class="line">			<span class="keyword">boolean</span> aborted = <span class="keyword">false</span>;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				postToSubscription(subscription, event,postingState.isMainThread);----&gt;<span class="number">1</span>D,在subscribe(..）粘性事件那里分析过了，所以那里的疑惑就解决了....那里的post是由于“粘性”立即post最近的event给订阅者，这里的postToSubscription是发送信息的一方直接调用post导致的</span><br><span class="line">				aborted = postingState.canceled; <span class="comment">//判断是否abort</span></span><br><span class="line">			&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">				<span class="comment">//当前状态的变量置为null，由于if可能结束循环，所以在finally中置空，避免内存泄漏。个人觉得...为什么不直接for循环外面置空，一定要置空了再赋值？？</span></span><br><span class="line">				postingState.event = <span class="keyword">null</span>;</span><br><span class="line">				postingState.subscription = <span class="keyword">null</span>;</span><br><span class="line">				postingState.canceled = <span class="keyword">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (aborted) &#123;</span><br><span class="line">				<span class="keyword">break</span>;<span class="comment">//如果abort了，那么这个事件的post就结束了</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//for循环结束，返回true</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//没进入if，返回false</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>2E.</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Looks up all Class objects including super classes and interfaces. Should also work for interfaces. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;Class&lt;?&gt;&gt; lookupAllEventTypes(Class&lt;?&gt; eventClass)&#123;</span><br><span class="line">	<span class="keyword">synchronized</span> (eventTypesCache) &#123;</span><br><span class="line">		<span class="comment">//从事件类的缓存中，根据事件class取出队列</span></span><br><span class="line">		List&lt;Class&lt;?&gt;&gt; eventTypes = eventTypesCache.get(eventClass);</span><br><span class="line">		<span class="keyword">if</span> (eventTypes == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="comment">//如果没有该类型的event，新建List</span></span><br><span class="line">			eventTypes = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">			Class&lt;?&gt; clazz = eventClass;</span><br><span class="line">			<span class="keyword">while</span> (clazz != <span class="keyword">null</span>) &#123;</span><br><span class="line">				eventTypes.add(clazz); <span class="comment">// 把当前事件类加到这个list中</span></span><br><span class="line">				<span class="comment">//clazz.getInterfaces(),又是反射机制，可以获得这个class实现自哪些接口。</span></span><br><span class="line">				addInterfaces(eventTypes,clazz.getInterfaces());---&gt;<span class="number">2F</span>，递归获得事件类的所有父接口，加到eventTypes这个list中</span><br><span class="line">				clazz = clazz.getSuperclass();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//然后把这个eventClass以及它可以对应的所有事件类型（List集合保存)加入cache</span></span><br><span class="line">			eventTypesCache.put(eventClass, eventTypes);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> eventTypes;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>2F.</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Recurses through super interfaces. */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addInterfaces</span><span class="params">(List&lt;Class&lt;?&gt;&gt; eventTypes, Class&lt;?&gt;[]</span></span></span><br><span class="line"><span class="function"><span class="params">interfaces)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (Class&lt;?&gt; interfaceClass : interfaces) &#123;</span><br><span class="line">	<span class="comment">//遍历事件类实现的接口，如果这个事件类型的List中不包含有这个接口</span></span><br><span class="line">		<span class="keyword">if</span> (!eventTypes.contains(interfaceClass)) &#123;</span><br><span class="line">			eventTypes.add(interfaceClass);<span class="comment">// 把这个接口添加进list</span></span><br><span class="line">		<span class="comment">// 继续用interfaceClass.getInterfaces()得到interfaceClass实现的接口</span></span><br><span class="line">		<span class="comment">//迭代这个方法</span></span><br><span class="line">			addInterfaces(eventTypes, interfaceClass.getInterfaces());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>2B</strong>.一个成员变量，<strong>PostingThreadState类型—&gt;2C</strong>的ThreadLocal<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ThreadLocal&lt;PostingThreadState&gt;</span><br><span class="line">currentPostingThreadState = <span class="keyword">new</span> ThreadLocal&lt;PostingThreadState&gt;() &#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> PostingThreadState <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//这个ThreadLocal的初始化就是new一个新的PostingThreadState();</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> PostingThreadState();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><strong>2C.一个静态常量内部类</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* For ThreadLocal, much faster to set (and get multiple values). */</span></span><br><span class="line"><span class="comment">//为了ThreadLocal可以更快的set和get？这里就是之前看threadLocal时提到的，postingThreadState用到了threadLocal</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PostingThreadState</span> </span>&#123;</span><br><span class="line">	<span class="keyword">final</span> List&lt;Object&gt; eventQueue = <span class="keyword">new</span> ArrayList&lt;Object&gt;();</span><br><span class="line">	<span class="keyword">boolean</span> isPosting;</span><br><span class="line">	<span class="keyword">boolean</span> isMainThread;</span><br><span class="line">	Subscription subscription;</span><br><span class="line">	Object event;</span><br><span class="line">	<span class="keyword">boolean</span> canceled;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>B</strong>.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(Object subscriber)</span> </span>&#123;</span><br><span class="line"><span class="comment">//首先通过反射，获取订阅者的类</span></span><br><span class="line">Class&lt;?&gt; subscriberClass = subscriber.getClass();</span><br><span class="line"><span class="comment">// 然后通过类，找类的方法，不是简单的用getMethod()</span></span><br><span class="line">List\&lt;SubscriberMethod\&gt; subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriberClass);---&gt;C，C~S都是这个函数的延伸，主要是两种方法来查找订阅者的方法</span><br><span class="line">	<span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">		<span class="keyword">for</span> (SubscriberMethod subscriberMethod : subscriberMethods) &#123;</span><br><span class="line">			<span class="comment">// 遍历订阅者的方法，然后执行subscribe---&gt;1A，重点就是处理subscriberMethod，其实不知道放进去在哪一步被执行...</span></span><br><span class="line">			subscribe(subscriber, subscriberMethod);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>1A.</strong><br><strong>1开头的，都是这个函数延伸出去的调用。</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 涉及到数据结构：private final Map&lt;Class&lt;?&gt;, CopyOnWriteArrayList&lt;Subscription&gt;&gt; subscriptionsByEventType;</span></span><br><span class="line"><span class="comment">/* Must be called in synchronized block*</span></span><br><span class="line"><span class="comment">*订阅者subscriber*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(Object subscriber, SubscriberMethod subscriberMethod)</span></span>&#123;</span><br><span class="line">	<span class="comment">//订阅者的方法要订阅的事件类</span></span><br><span class="line">	Class&lt;?&gt; eventType = subscriberMethod.eventType;</span><br><span class="line">	Subscription newSubscription = <span class="keyword">new</span> Subscription(subscriber,</span><br><span class="line">	subscriberMethod);---&gt;<span class="number">1</span>B,封装了这个订阅者和订阅者的响应函数以及是否订阅这三个信息</span><br><span class="line">	CopyOnWriteArrayList&lt;Subscription&gt; subscriptions =</span><br><span class="line">	subscriptionsByEventType.get(eventType); </span><br><span class="line">	<span class="comment">//根据eventType取出订阅这个情况的所有订阅情况</span></span><br><span class="line">	<span class="keyword">if</span> (subscriptions == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="comment">//如果这个event还从未被订阅，自然新建一个它所对应的subscription</span></span><br><span class="line">		subscriptions = <span class="keyword">new</span> CopyOnWriteArrayList&lt;&gt;();	</span><br><span class="line">		subscriptionsByEventType.put(eventType, subscriptions);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">//如果这个订阅关系已经存在， 抛出异常。Subscriber..already registered to event，和自己理解的一样~~~~ 开心</span></span><br><span class="line">		<span class="keyword">if</span> (subscriptions.contains(newSubscription)) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">"Subscriber "</span> + subscriber.getClass() +<span class="string">"already registered to event "</span>+ eventType);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 这个事件有多少个订阅方法（\@subscribe的方法或者onEvent..)</span></span><br><span class="line">	<span class="keyword">int</span> size = subscriptions.size();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= size; i++) &#123;</span><br><span class="line">		<span class="comment">// 如果当前这个订阅方法的优先级比当前这个订阅方法的优先级高，就把它加入到第i位（也就是倒数第二位），然后break。</span></span><br><span class="line">		<span class="comment">// 如果直接到了size，说明当前方法优先级最低，直接插入尾部。</span></span><br><span class="line">		<span class="keyword">if</span> (i == size || subscriberMethod.priority &gt; subscriptions.get(i).subscriberMethod.priority) &#123;</span><br><span class="line">			subscriptions.add(i, newSubscription);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//涉及到private final Map&lt;Object, List&lt;Class&lt;?&gt;&gt;&gt; typesBySubscriber;</span></span><br><span class="line">	<span class="comment">//查看这个订阅者要订阅的事件类型</span></span><br><span class="line">	List&lt;Class&lt;?&gt;&gt; subscribedEvents = typesBySubscriber.get(subscriber);</span><br><span class="line">	<span class="keyword">if</span> (subscribedEvents == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="comment">//原来这个subscriber没有订阅过事件，那么现在增加订阅者的 subscribedEvents(是一个list）</span></span><br><span class="line">		subscribedEvents = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		typesBySubscriber.put(subscriber, subscribedEvents);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//不管subscriber是否订阅过事件,都把这个事件类型加入到这个subscriber的订阅事件列表中</span></span><br><span class="line">	subscribedEvents.add(eventType);</span><br><span class="line">	<span class="comment">//如果这个响应函数是粘性的。 如果不是粘性的？？哪里涉及到线程去执行？</span></span><br><span class="line">	<span class="comment">//个人理解：</span></span><br><span class="line">	这是<span class="number">3.0</span>增加的新特性：从代码可以看出stickyEvents的entry，其实是一个map，map的key是事件类型（<span class="class"><span class="keyword">class</span>\&lt;?\&gt;），<span class="title">value</span>是事件实例(<span class="title">Object</span>),由于是粘性事件，那么，当这个<span class="title">subscriberMethod</span>订阅这个事件类型，就把最近的事件类型的事件（<span class="title">Object</span>)</span></span><br><span class="line"><span class="class">通过<span class="title">checkPostStickyEventToSubscription</span>立刻将这个事件找到对应的处理线程，进行排队（有可能排）后，由对应的<span class="title">subcriberMethod</span>进行处理。</span></span><br><span class="line"><span class="class">	<span class="title">if</span> (<span class="title">subscriberMethod</span>.<span class="title">sticky</span>) </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (eventInheritance) &#123;</span><br><span class="line">		<span class="comment">/* Existing sticky events of all subclasses of eventType have to be</span></span><br><span class="line"><span class="comment">		considered.这个事件类型的所有子类的粘性事件都要考虑</span></span><br><span class="line"><span class="comment">		Note: Iterating over all events may be inefficient with lots of sticky events, 如果粘性事件比较多，遍历所有的事件可能不够高效</span></span><br><span class="line"><span class="comment">		thus data structure should be changed to allow a more efficient lookup*应该更改数据结构，进行更高效的遍历  (e.g. an additional map storing sub classes of super classes: Class -&gt; List&lt;Class&gt;).*/</span></span><br><span class="line">			Set&lt;Map.Entry&lt;Class&lt;?&gt;, Object&gt;&gt; entries = stickyEvents.entrySet();</span><br><span class="line">		    <span class="comment">//取出保存粘性事件的set</span></span><br><span class="line">			<span class="keyword">for</span> (Map.Entry&lt;Class&lt;?&gt;, Object&gt; entry : entries) &#123;</span><br><span class="line">			<span class="comment">//遍历set中每个元素，取出每个元素的key，也就是事件类型class&lt;?&gt;</span></span><br><span class="line">				Class&lt;?&gt; candidateEventType = entry.getKey();</span><br><span class="line">				<span class="comment">//如果当前订阅方法监听的事件类型，是之前存在的事件的 父类</span></span><br><span class="line">				<span class="keyword">if</span> (eventType.isAssignableFrom(candidateEventType)) &#123;</span><br><span class="line">					<span class="comment">// 取出value,也就是这个事件类型的实例</span></span><br><span class="line">					Object stickyEvent = entry.getValue();</span><br><span class="line">					checkPostStickyEventToSubscription(newSubscription, stickyEvent);----&gt;<span class="number">1</span>C</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			Object stickyEvent = stickyEvents.get(eventType);</span><br><span class="line">			checkPostStickyEventToSubscription(newSubscription, stickyEvent);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>1C. 主要是调用了postToSubscription，选择了合适的线程，执行了post</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkPostStickyEventToSubscription</span><span class="params">(Subscription</span></span></span><br><span class="line"><span class="function"><span class="params">newSubscription, Object stickyEvent)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (stickyEvent != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="comment">/*If the subscriber is trying to abort the event, it will fail (event is not tracked in posting state) 如果订阅者想阻止这个事件，将会失败--&gt; Strange corner case, which we don't take care of here.奇怪的case，我们不用在意？？？ 这注释有点迷...*/</span></span><br><span class="line">		postToSubscription(newSubscription, stickyEvent, Looper.getMainLooper() == Looper.myLooper());---&gt;<span class="number">1</span>D,真正处理event的函数（终于涉及了线程），赞！</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>1D.根据订阅者方法的threadMode，决定这个方法由哪个线程执行。</strong></p>
<p><strong>由各个poster去处理pengdingPost，可能由handler执行，也可能是线程池去执行runnable</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postToSubscription</span><span class="params">(Subscription subscription, Object event,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">boolean</span> isMainThread)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">switch</span> (subscription.subscriberMethod.threadMode) &#123;</span><br><span class="line">		<span class="keyword">case</span> POSTING:</span><br><span class="line">			invokeSubscriber(subscription,event);---&gt;<span class="number">1</span>E，通过java反射机制，使用method.invoke()调用了subscirber对象中的参数为event订阅方法</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> MAIN:</span><br><span class="line">			<span class="keyword">if</span> (isMainThread) &#123;</span><br><span class="line">				<span class="comment">//如果当前就是主线程，那么就当前线程执行subscription.subscriberMethod</span></span><br><span class="line">				invokeSubscriber(subscription, event);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">//mainThreadPoster = new HandlerPoster(this, Looper.getMainLooper(), 10);有主线程的looper</span></span><br><span class="line">				mainThreadPoster.enqueue(subscription, event);----&gt;<span class="number">1F</span>，插入给主线程的handler，会将这个事件和方法放入queue，等待主线程执行，如果主线程的queue之前为空，那么就直接sendMsg。</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> BACKGROUND:</span><br><span class="line">			<span class="keyword">if</span> (isMainThread) &#123;</span><br><span class="line">				<span class="comment">//backgroundPoster = new BackgroundPoster(this);同理，这是后台线程的handler</span></span><br><span class="line">				backgroundPoster.enqueue(subscription, event);---&gt;<span class="number">1</span>I</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">//如果当前线程不是主线程，就直接用当前线程执行，invokeSubscriber是当前的eventBus中的函数</span></span><br><span class="line">				invokeSubscriber(subscription, event);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> ASYNC:</span><br><span class="line">			asyncPoster.enqueue(subscription, event);---&gt;<span class="number">1</span>J</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Unknown thread mode: "</span> + subscription.subscriberMethod.threadMode);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>1E.</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">invokeSubscriber</span><span class="params">(Subscription subscription, Object event)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">//method.invoke(Object obj, Object... args) 是反射机制的一个函数</span></span><br><span class="line">		<span class="comment">//对这个指定的对象obj，调用方法method，args是这个方法需要的参数数组。</span></span><br><span class="line">		<span class="comment">//也就是，调用subscriber这个对象的subscription.subscriberMethod.method方法，其中event是这个方法的参数...JAVA反射好厉害-</span></span><br><span class="line">		subscription.subscriberMethod.method.invoke(subscription.subscriber, event);</span><br><span class="line">	&#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">		handleSubscriberException(subscription, event, e.getCause());</span><br><span class="line">	&#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Unexpected exception"</span>, e);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>1K. 差点以为是1E…</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">invokeSubscriber</span><span class="params">(PendingPost pendingPost)</span> </span>&#123;</span><br><span class="line">	Object event = pendingPost.event; <span class="comment">//取出这个post对应的event obj</span></span><br><span class="line">	<span class="comment">//再取出对应的订阅信息</span></span><br><span class="line">	Subscription subscription = pendingPost.subscription;</span><br><span class="line">	PendingPost.releasePendingPost(pendingPost);----&gt;<span class="number">1L</span></span><br><span class="line">	<span class="keyword">if</span> (subscription.active) &#123;</span><br><span class="line">	<span class="comment">//这个变量注释就说是这里会用到，为了避免race conditions（资源竞争）</span></span><br><span class="line">		invokeSubscriber(subscription, event);---&gt;<span class="number">1</span>E</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>SubscriberMethodFinder.JAVA</strong></p>
<p><strong>C.</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">List&lt;SubscriberMethod&gt; <span class="title">findSubscriberMethods</span><span class="params">(Class&lt;?&gt; subscriberClass)</span></span>&#123;</span><br><span class="line">	<span class="comment">//先直接从缓存中取</span></span><br><span class="line">	List&lt;SubscriberMethod&gt; subscriberMethods = METHOD_CACHE.get(subscriberClass);</span><br><span class="line">	<span class="keyword">if</span> (subscriberMethods != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> subscriberMethods;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//如果没有的话，判断是否要忽略注解器：</span></span><br><span class="line">	<span class="keyword">if</span> (ignoreGeneratedIndex) &#123;</span><br><span class="line">		<span class="comment">//忽略的话，用反射来获取类的方法信息</span></span><br><span class="line">		subscriberMethods = findUsingReflection(subscriberClass);---&gt;D</span><br><span class="line">		<span class="comment">/*D~N，都是利用反射找方法的过程，主要是通过findState，把subscriberClass放进去，找到对应方法，再找它的父类，依次向上。总体来说findUsingReflection就是一个while循环遍历所有相关类，根据类找方法时需要用到反射和注解...*/</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		subscriberMethods = findUsingInfo(subscriberClass); ---&gt;O</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (subscriberMethods.isEmpty()) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">"Subscriber "</span> + subscriberClass + <span class="string">" and its super classes have no public methods with the \@Subscribe annotation"</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		METHOD_CACHE.put(subscriberClass, subscriberMethods);</span><br><span class="line">		<span class="keyword">return</span> subscriberMethods;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>P.</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> SubscriberInfo <span class="title">getSubscriberInfo</span><span class="params">(FindState findState)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 看描述subscriberInfo本来就一直为null啊... 是一个接口的变量</span></span><br><span class="line">	<span class="comment">// getSuperSubscriberInfo()是接口的一个函数，AbstractSubscriberInfo是接口实现</span></span><br><span class="line">	<span class="keyword">if</span> (findState.subscriberInfo != <span class="keyword">null</span> &amp;&amp; findState.subscriberInfo.getSuperSubscriberInfo() != <span class="keyword">null</span>) &#123; ----&gt;Q</span><br><span class="line">		<span class="comment">//如果订阅者信息不为空且订阅者信息子类不为空</span></span><br><span class="line">		SubscriberInfo superclassInfo = findState.subscriberInfo.getSuperSubscriberInfo();</span><br><span class="line">		<span class="comment">//如果findstate当前的clazz和订阅者子类一样，返回这个子类信息。</span></span><br><span class="line">		<span class="keyword">if</span> (findState.clazz == superclassInfo.getSubscriberClass()) &#123;</span><br><span class="line">			<span class="keyword">return</span> superclassInfo;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//如果订阅者信息下标不为空（是一个List),那么遍历List，通过index取出clazz的信息，并返回。</span></span><br><span class="line">	<span class="keyword">if</span> (subscriberInfoIndexes != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">for</span> (SubscriberInfoIndex index : subscriberInfoIndexes) &#123;</span><br><span class="line">			SubscriberInfo info = index.getSubscriberInfo(findState.clazz);</span><br><span class="line">			<span class="keyword">if</span> (info != <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">return</span> info;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>O.看看和DList<subscribermethod> findUsingReflection(Class&lt;?&gt;<br>subscriberClass)有什么不同</subscribermethod></strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> List&lt;SubscriberMethod&gt; <span class="title">findUsingInfo</span><span class="params">(Class&lt;?&gt; subscriberClass)</span> </span>&#123;</span><br><span class="line">	FindState findState = prepareFindState(); <span class="comment">// same</span></span><br><span class="line">	findState.initForSubscriber(subscriberClass); <span class="comment">// same</span></span><br><span class="line">	<span class="keyword">while</span> (findState.clazz != <span class="keyword">null</span>) &#123; <span class="comment">// same</span></span><br><span class="line">		findState.subscriberInfo =</span><br><span class="line">getSubscriberInfo(findState);---&gt;P,经过PQ，取到订阅者的信息</span><br><span class="line">		<span class="keyword">if</span> (findState.subscriberInfo != <span class="keyword">null</span>) &#123; <span class="comment">//订阅者信息不为空</span></span><br><span class="line">			SubscriberMethod[] array = findState.subscriberInfo.getSubscriberMethods();---&gt;R<span class="comment">//调用接口函数，根据方法信息构建方法，并返回</span></span><br><span class="line">		<span class="keyword">for</span> (SubscriberMethod subscriberMethod : array) &#123;</span><br><span class="line">		<span class="comment">// 遍历方法，但是否能将订阅者方法和要监听的事件类型添加到findState中</span></span><br><span class="line">			<span class="keyword">if</span> (findState.checkAdd(subscriberMethod.method, subscriberMethod.eventType)) &#123;</span><br><span class="line">			<span class="comment">// 将这个方法加入到findState的list中去</span></span><br><span class="line">				findState.subscriberMethods.add(subscriberMethod);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="comment">//订阅者信息为空，那就通过这个方法，用反射得到findState.clazz的相关信息，并构造订阅方法（new SubscriberMethod（....)），add进findState中</span></span><br><span class="line">		findUsingReflectionInSingleClass(findState);</span><br><span class="line">	&#125;</span><br><span class="line">	findState.moveToSuperclass(); <span class="comment">//继续往上找</span></span><br><span class="line">&#125;</span><br><span class="line">	<span class="keyword">return</span> getMethodsAndRelease(findState); <span class="comment">//释放这个findState</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">D.</span><br><span class="line"><span class="function"><span class="keyword">private</span> List&lt;SubscriberMethod&gt; <span class="title">findUsingReflection</span><span class="params">(Class&lt;?&gt;</span></span></span><br><span class="line"><span class="function"><span class="params">subscriberClass)</span> </span>&#123;</span><br><span class="line">	FindState findState = prepareFindState();----&gt;E,得到一个FindState</span><br><span class="line">	findState.initForSubscriber(subscriberClass);---&gt;F,为这个findstate赋值它记在的订阅类，也就是subscriberClass，这是起点，此时findState中的clazz就是它</span><br><span class="line">	<span class="keyword">while</span> (findState.clazz != <span class="keyword">null</span>) &#123;</span><br><span class="line">		findUsingReflectionInSingleClass(findState);----&gt;G</span><br><span class="line">	<span class="comment">/*G到K，终于把subscriberClass里面的订阅方法加入到相应的findState了</span></span><br><span class="line"><span class="comment">	findState.moveToSuperclass();---&gt;L,把findState的clazz换成clazz的父类（超类不能为系统类）</span></span><br><span class="line"><span class="comment">	注意这是一个while循环，所以是从子类开始一直向上，把相应clazz的方法加入到findState*/</span></span><br><span class="line">&#125;</span><br><span class="line">	<span class="keyword">return</span> getMethodsAndRelease(findState);-----&gt;M，释放findstate,<span class="keyword">while</span>循环结束它就功成身退了，把它还给statePool</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>E.从findStatePool中取出第一个不为空的state，取出后把池中这个位置的state置为空。<br>有可能池为空，那么直接new一个FindState();</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> FindState <span class="title">prepareFindState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">synchronized</span> (FIND_STATE_POOL) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; POOL_SIZE; i++) &#123;	</span><br><span class="line">			FindState state = FIND_STATE_POOL[i];</span><br><span class="line">			<span class="keyword">if</span> (state != <span class="keyword">null</span>) &#123;</span><br><span class="line">				FIND_STATE_POOL[i] = <span class="keyword">null</span>;</span><br><span class="line">				<span class="keyword">return</span> state;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> FindState();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>G.利用反射原理取出当前findState中的订阅类的方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">findUsingReflectionInSingleClass</span><span class="params">(FindState findState)</span> </span>&#123;</span><br><span class="line">	Method[] methods;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">	<span class="comment">// This is faster than getMethods, especially when subscribers are fat classes</span></span><br><span class="line">	like Activities</span><br><span class="line">	<span class="comment">/*getMethods()返回某个类的所有公用（public）方法包括其继承类的公用方法，当然也包括它所实现接口的方法。getDeclaredMethods()对象表示的类或接口声明的所有方法，包括公共、保护、默认（包）访问和私有方法，但不包括继承的方法。当然也包括它所实现接口的方法。*/</span></span><br><span class="line">	methods = findState.clazz.getDeclaredMethods();</span><br><span class="line">	&#125; <span class="keyword">catch</span> (Throwable th) &#123;</span><br><span class="line">	<span class="comment">/* Workaround for java.lang.NoClassDefFoundError, see</span></span><br><span class="line"><span class="comment">	https://github.com/greenrobot/EventBus/issues/149*</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">		methods = findState.clazz.getMethods();</span><br><span class="line">		findState.skipSuperClasses = <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">	<span class="comment">//返回类或接口的以整数编码的JAVA语言修饰符，比如得到整数i=1，那么Modefier.toString(i)可以得到String的public</span></span><br><span class="line">	<span class="keyword">int</span> modifiers = method.getModifiers();</span><br><span class="line">	<span class="comment">//如果是public，不是abstract,不是static，不是BRIDGE,不是SYNTHETIC？</span></span><br><span class="line">	<span class="keyword">if</span> ((modifiers &amp; Modifier.PUBLIC) != <span class="number">0</span> &amp;&amp; (modifiers &amp; MODIFIERS_IGNORE)</span><br><span class="line">== <span class="number">0</span>)&#123;</span><br><span class="line">	<span class="comment">//获得方法的各参数的类型数组，不管类型是否一样，都算1，比如 int string</span></span><br><span class="line">	<span class="keyword">int</span>，那么共<span class="number">3</span>个</span><br><span class="line">	Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();</span><br><span class="line">	<span class="comment">// 3.0开始，不是onEvent..开头的方法，也可以作为响应函数了</span></span><br><span class="line">	<span class="comment">// 但是必须只有一个参数（也就是监听的事件event这个参数</span></span><br><span class="line">	<span class="keyword">if</span> (parameterTypes.length == <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="comment">//获得Subscribe.class的注解，这个注解标签（定义的名称）是Subscribe。</span></span><br><span class="line">		<span class="comment">// 有@Subscribe 注解的，都是响应函数，也就是不仅能用onEvent..这四个函数了</span></span><br><span class="line">		Subscribe subscribeAnnotation = method.getAnnotation(Subscribe.class);</span><br><span class="line">		<span class="keyword">if</span> (subscribeAnnotation != <span class="keyword">null</span>) &#123; <span class="comment">// 如果\@Subscribe不为空</span></span><br><span class="line">			Class&lt;?&gt; eventType = parameterTypes[<span class="number">0</span>]; <span class="comment">//取出参数对应的类</span></span><br><span class="line">			<span class="keyword">if</span> (findState.checkAdd(method, eventType)) &#123;-----&gt;H，一系列检查看是否能为这个事件类型添加对应的方法</span><br><span class="line">				ThreadMode threadMode = subscribeAnnotation.threadMode();---&gt;</span><br><span class="line">			findState.subscriberMethods.add(<span class="keyword">new</span> SubscriberMethod(method, eventType,</span><br><span class="line">threadMode,subscribeAnnotation.priority(), subscribeAnnotation.sticky()));</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="comment">//把这个订阅方法以及相关的事件类型、响应模式等封装后，加入到findState保存的订阅者方法的list中去，这是newSubscriberMethod的起点，顺便去看看这个类</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (strictMethodVerification &amp;&amp; method.isAnnotationPresent(Subscribe.class)) &#123;</span><br><span class="line">			<span class="comment">// 如果不止一个参数类型并且.....</span></span><br><span class="line">			<span class="comment">// 获取这个方法的所在的类名，以及方法名</span></span><br><span class="line">			String methodName = method.getDeclaringClass().getName() + <span class="string">"."</span> +</span><br><span class="line">		method.getName();</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">"\@Subscribe method "</span> + methodName +</span><br><span class="line">			<span class="string">"must have exactly 1 parameter but has "</span> + parameterTypes.length);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (strictMethodVerification &amp;&amp;</span><br><span class="line">		method.isAnnotationPresent(Subscribe.class)) &#123; </span><br><span class="line">			<span class="comment">//这个elseif对应的是最外层那个public &amp;&amp; 非abstract ....</span></span><br><span class="line">			String methodName = method.getDeclaringClass().getName() + <span class="string">"."</span> + method.getName();</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(methodName + <span class="string">" is a illegal \@Subscribe method: must be public, non-static, and non-abstract"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>M.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> List&lt;SubscriberMethod&gt; <span class="title">getMethodsAndRelease</span><span class="params">(FindState findState)</span></span>&#123;</span><br><span class="line">	<span class="comment">//把findState里面的subscriberMethods列表复制过来</span></span><br><span class="line">	List&lt;SubscriberMethod&gt; subscriberMethods = <span class="keyword">new</span></span><br><span class="line">	ArrayList&lt;&gt;(findState.subscriberMethods);</span><br><span class="line">	findState.recycle(); ---&gt;N ,就是把findState的各个成员变量清空。</span><br><span class="line">	<span class="keyword">synchronized</span> (FIND_STATE_POOL) &#123;</span><br><span class="line">		<span class="comment">// 从前开始遍历，把这个findstate还给这个pool</span></span><br><span class="line">		<span class="comment">// 之前取的时候，把[i]位置置为了null，所以这里还回去时候找值为null的=</span></span><br><span class="line">		<span class="comment">// 这思路真是简单易懂- -</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; POOL_SIZE; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (FIND_STATE_POOL[i] == <span class="keyword">null</span>) &#123;</span><br><span class="line">				FIND_STATE_POOL[i] = findState;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> subscriberMethods;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>SubscriberMethodFinder.java中的一个静态内部类：<br>static class FindState {}<br>成员变量：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//subscriber的订阅方法</span></span><br><span class="line"><span class="keyword">final</span> List&lt;SubscriberMethod&gt; subscriberMethods = <span class="keyword">new</span></span><br><span class="line">ArrayList&lt;&gt;();</span><br><span class="line"><span class="comment">//订阅方法的事件类型</span></span><br><span class="line"><span class="keyword">final</span> Map&lt;Class, Object&gt; anyMethodByEventType = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="keyword">final</span> Map&lt;String, Class&gt; subscriberClassByMethodKey = <span class="keyword">new</span></span><br><span class="line">HashMap&lt;&gt;();</span><br><span class="line"><span class="keyword">final</span> StringBuilder methodKeyBuilder = <span class="keyword">new</span> StringBuilder(<span class="number">128</span>);</span><br><span class="line">Class&lt;?&gt; subscriberClass;</span><br><span class="line">Class&lt;?&gt; clazz;</span><br><span class="line"><span class="keyword">boolean</span> skipSuperClasses;</span><br><span class="line">SubscriberInfo subscriberInfo;</span><br><span class="line"><span class="comment">//主要保存了订阅类的所有订阅方法信息.</span></span><br></pre></td></tr></table></figure></p>
<p><strong>N.</strong><br><strong><em>集合类用clear()，builder用setLength(0),对象实例用null。</em></strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">recycle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	subscriberMethods.clear();</span><br><span class="line">	anyMethodByEventType.clear();</span><br><span class="line">	subscriberClassByMethodKey.clear();</span><br><span class="line">	methodKeyBuilder.setLength(<span class="number">0</span>);</span><br><span class="line">	subscriberClass = <span class="keyword">null</span>;</span><br><span class="line">	clazz = <span class="keyword">null</span>;</span><br><span class="line">	skipSuperClasses = <span class="keyword">false</span>;</span><br><span class="line">	subscriberInfo = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>F</strong>.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initForSubscriber</span><span class="params">(Class&lt;?&gt; subscriberClass)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.subscriberClass = clazz = subscriberClass;</span><br><span class="line">	skipSuperClasses = <span class="keyword">false</span>;</span><br><span class="line">	subscriberInfo = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>H</strong>.<br><strong>检查是否添加这个方法，</strong>checkAddWithMethodSignature这个方法有点迷惑…记得回来看</p>
<p>两层检查，第一层检查事件类型，第二层检查签名（方法名称+参数类型）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">checkAdd</span><span class="params">(Method method, Class&lt;?&gt; eventType)</span> </span>&#123;</span><br><span class="line">	<span class="comment">/* 2 level check: 1st level with event type only (fast), 2nd level with</span></span><br><span class="line"><span class="comment">	complete signature when required.</span></span><br><span class="line"><span class="comment">	Usually a subscriber doesn't have methods listening to the same event type.*/</span></span><br><span class="line">	<span class="comment">// map的put方法，如果之前Key没有对应的value，那么返回null，否则返回之前对应的值</span></span><br><span class="line">	Object existing = anyMethodByEventType.put(eventType, method);</span><br><span class="line">	<span class="keyword">if</span> (existing == <span class="keyword">null</span>) &#123;</span><br><span class="line">	<span class="comment">//说明之前这个key没有对应值，那么这个类型可以对应这个方法</span></span><br><span class="line">	<span class="comment">//也就是这个事件只有当前这种方法订阅了</span></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="comment">// 如果之前订阅这个事件A的method和当前想订阅事件A的method类型一样</span></span><br><span class="line">		<span class="keyword">if</span> (existing <span class="keyword">instanceof</span> Method) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!checkAddWithMethodSignature((Method) existing, eventType))-----&gt;I&#123; <span class="comment">// 如果之前的classOld是现在methodClass的子类，那么抛出异常</span></span><br><span class="line">				<span class="comment">// Paranoia check</span></span><br><span class="line">				<span class="comment">// 也就是之前存在的classOld是当前方法的子类时，不用重新订阅，需要遵循子类覆写。</span></span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// Put any non-Method object to "consume" the existing Method</span></span><br><span class="line">			<span class="comment">//没有出现父类想和子类抢同一个事件的异常，那么这个事件类型的订阅者就是this</span></span><br><span class="line">			anyMethodByEventType.put(eventType, <span class="keyword">this</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> checkAddWithMethodSignature(method, eventType);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>I.方法签名的检查</strong></p>
<p>这是一个优化，如果现在保存的是旧的子类，那么保存新的，返回true<br>否则没必要保存，直接保存旧的那个父类就行了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">checkAddWithMethodSignature</span><span class="params">(Method method, Class&lt;?&gt; eventType)</span> </span>&#123;</span><br><span class="line">	methodKeyBuilder.setLength(<span class="number">0</span>);</span><br><span class="line">	methodKeyBuilder.append(method.getName()); <span class="comment">//方法名</span></span><br><span class="line">	methodKeyBuilder.append(<span class="string">'&gt;'</span>).append(eventType.getName());</span><br><span class="line">	<span class="comment">// 类名即事件类型名称</span></span><br><span class="line">	<span class="comment">// 用这两个值当做key</span></span><br><span class="line">	String methodKey = methodKeyBuilder.toString();</span><br><span class="line">	<span class="comment">// 得到这个方法所对应的类对象</span></span><br><span class="line">	Class&lt;?&gt; methodClass = method.getDeclaringClass();</span><br><span class="line">	Class&lt;?&gt; methodClassOld = subscriberClassByMethodKey.put(methodKey, methodClass);</span><br><span class="line">	<span class="comment">//methodClassOld为空，或者是父类</span></span><br><span class="line">	<span class="comment">//methodClassOld为空时：说明这个方法签名（methodKey=方法名+事件类型)之前没有彼此对应。那么允许为这个方法添加订阅事件，返回true</span></span><br><span class="line">	<span class="keyword">if</span> (methodClassOld == <span class="keyword">null</span> ||</span><br><span class="line">	methodClassOld.isAssignableFrom(methodClass)) &#123;</span><br><span class="line">		<span class="comment">//这个函数，Class.isAssignableFrom()是用来判断一个类Class1是否Class2的superClass或者superInterface，或者是相同类或者接口。</span></span><br><span class="line">		格式为： Class1.isAssignableFrom(Class2)</span><br><span class="line">		这是判断类之间的关系，<span class="keyword">instanceof</span>是判断实例之间的关系</span><br><span class="line">		<span class="comment">// Only add if not already found in a sub class</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// Revert the put, old class is further down the class hierarchy</span></span><br><span class="line">		<span class="comment">/*methodClassOld不为空，并且它是新的methodClass的子类，把methodClassOld放回去并且返回false，**代表子类classOld覆写了父类的订阅方法，让子类method的订阅方法订阅这个事件而不是父类。*/</span></span><br><span class="line">		subscriberClassByMethodKey.put(methodKey,methodClassOld);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>L.</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">moveToSuperclass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (skipSuperClasses) &#123;</span><br><span class="line">		clazz = <span class="keyword">null</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		clazz = clazz.getSuperclass();</span><br><span class="line">		String clazzName = clazz.getName();</span><br><span class="line">		<span class="comment">/* Skip system classes, this just degrades performance. */</span></span><br><span class="line">		<span class="comment">//跳过系统类，也就是以java, javax,android开头的类</span></span><br><span class="line">		<span class="keyword">if</span> (clazzName.startsWith(<span class="string">"java."</span>) ||clazzName.startsWith(<span class="string">"javax."</span>) || clazzName.startsWith(<span class="string">"android."</span>)) &#123;</span><br><span class="line">			clazz = <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>③注解类\@Subscribe</strong></p>
<p><strong>J.</strong></p>
<p>终于遇到注解了！！看别人的分析，注解中应该还有<br>String[] actions() default {};  </p>
<p>这个版本好像没有了！！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.*RUNTIME*)</span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.*METHOD*&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Subscribe &#123;</span><br><span class="line">	<span class="function">ThreadMode <span class="title">threadMode</span><span class="params">()</span> <span class="keyword">default</span></span></span><br><span class="line"><span class="function">	ThreadMode.POSTING</span>;---&gt;K</span><br><span class="line">	<span class="comment">/*如果是真，如果有订阅者在这个sticky事件发布后才订阅这个事件，那么依然会把最近的这个事件类型的sticky事件发送给这个subscriber*/</span></span><br><span class="line">	<span class="comment">/* If true, delivers the most recent sticky event (posted with &#123;\@link EventBus #postSticky(Object)&#125;) to this subscriber (if event available).*/</span></span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">sticky</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line">	<span class="comment">/* 对于同一个传送线程，优先级高的订阅者更快地接收到事件</span></span><br><span class="line"><span class="comment">	Subscriber priority to influence the order of event delivery.*/</span></span><br><span class="line">	<span class="comment">/* Within the same delivery thread (&#123;\@link ThreadMode&#125;), higher priority subscribers will receive events before*/</span> others with a lower priority. The <span class="keyword">default</span> priority is <span class="number">0</span>. Note: the priority</span><br><span class="line">	does \*NOT\* affect the order of delivery among subscribers with different &#123;\<span class="meta">@link</span> ThreadMode&#125;s! */</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">priority</span><span class="params">()</span> <span class="keyword">default</span> 0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>K.</strong><br>public enum ThreadMode{}<br>枚举类型，共四种：<br><em>POSTING</em>：订阅者的响应函数直接由发起post事件的线程执行，如果发起post的是主线程，那么响应函数不应该是耗时操作。如果要执行的task耗时很短，建议使用这种模式。<br><em>MAIN</em>: 订阅者的响应函数由主线程执行。如果posting<br>thread是主线程，事件响应函数将会直接被这个线程call。<br><em>BACKGROUND</em>：订阅者的响应函数由后台线程执行，如果posting<br>thread不是主线程，事件响应函数将会直接被这个线程call。如果posting<br>thread是主线程，那么eventBus将会使用一个单独的single后台线程，这个线程会按序执行这些响应函数。但还是不建议有很耗时的操作，以避免阻塞这个后台线程。<br><em>ASYNC：</em><br>订阅者的响应函数由一个独立的线程去执行，这个线程不是主线程，也不是posting<br>thread。如果有比较耗时的操作，建议用这种模式，比如网络访问。EventBus使用了线程池来重用线程进行异步操作。</p>
<p><strong>SubscriberMethod.JAVA</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubscriberMethod</span> </span>&#123;</span><br><span class="line">	<span class="keyword">final</span> Method method;</span><br><span class="line">	<span class="keyword">final</span> ThreadMode threadMode;</span><br><span class="line">	<span class="keyword">final</span> Class&lt;?&gt; eventType;</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">int</span> priority;</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">boolean</span> sticky;</span><br><span class="line">	<span class="comment">/* Used for efficient comparison */</span></span><br><span class="line">	String methodString;</span><br><span class="line">....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>构造函数就是对前五个变量进行赋值，很好理解。</p>
<p><strong>AbstractSubscriberInfo.JAVA，实现SubscriberInfo接口</strong><br>public abstract class AbstractSubscriberInfo implements SubscriberInfo<br>{}<br>private final Class subscriberClass;<br>private final Class&lt;? extends SubscriberInfo&gt;<br>superSubscriberInfoClass;<br>private final boolean shouldCheckSuperclass;<br>主要是三个成员变量：<br>订阅者对应的类；订阅者信息的子类（这是什么鬼…); 检查超类的布尔变量</p>
<p><strong>P.</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SubscriberInfo <span class="title">getSuperSubscriberInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 如果没有信息子类，直接返回Null</span></span><br><span class="line">	<span class="keyword">if</span>(superSubscriberInfoClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> superSubscriberInfoClass.newInstance();</span><br><span class="line">	&#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">	&#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>S.</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">simpleSubscriberInfo中的getSubscriberMethods()会调用该函数：</span><br><span class="line"><span class="function"><span class="keyword">protected</span> SubscriberMethod <span class="title">createSubscriberMethod</span><span class="params">(String methodName, Class&lt;?&gt; eventType, ThreadMode threadMode,<span class="keyword">int</span> priority, <span class="keyword">boolean</span> sticky)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		Method method = subscriberClass.getDeclaredMethod(methodName, eventType);</span><br><span class="line">		<span class="comment">//通过方法名称，和方法参数列表（其实就是方法签名）从class中找到类</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> SubscriberMethod(method, eventType, threadMode, priority, sticky); <span class="comment">//然后构造subscriber方法，似乎比第一种通过反射的方式简单</span></span><br><span class="line">	&#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(**<span class="string">"Could not find subscriber method in "</span> + subscriberClass + <span class="string">". Maybe a missing ProGuard rule?"</span>, e);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>**⑥SimpleSubscriberInfo.JAVA<br>又继承了AbstractSubscriberInfo（就不能一次写完吗…)<br>一个成员变量：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> SubscriberMethodInfo[] methodInfos;</span><br><span class="line"><span class="comment">// 存储了订阅者所有的方法信息，用数组保存。</span></span><br></pre></td></tr></table></figure></p>
<p><strong>R.</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> SubscriberMethod[] getSubscriberMethods() &#123;</span><br><span class="line">	<span class="keyword">int</span> length = methodInfos.length;</span><br><span class="line">	<span class="comment">//建立一个方法数组（不是方法信息）</span></span><br><span class="line">	SubscriberMethod[] methods = <span class="keyword">new</span> SubscriberMethod[length];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">		<span class="comment">//取出方法信息	</span></span><br><span class="line">		SubscriberMethodInfo info = methodInfos[i];</span><br><span class="line">		<span class="comment">//根据信息建立方法（调用父类的createSubscriberMethod）</span></span><br><span class="line">		methods[i] = createSubscriberMethod(info.methodName, info.eventType, info.threadMode, info.priority, info.sticky);----&gt;S</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> methods; <span class="comment">//根据信息构造了方法数组，返回去。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>⑦Subscription.JAVA</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Subscription</span> </span>&#123;&#125;</span><br><span class="line"><span class="comment">//三个成员变量：</span></span><br><span class="line"><span class="keyword">final</span> Object subscriber; <span class="comment">//注册的订阅者</span></span><br><span class="line"><span class="keyword">final</span> SubscriberMethod subscriberMethod; <span class="comment">//订阅者响应事件的函数</span></span><br><span class="line"><span class="comment">/*Becomes false as soon as &#123;@link EventBus#unregister(Object)&#125; is called, which is checked by queued event delivery &#123;@link EventBus#invokeSubscriber(PendingPost)&#125; to prevent race conditions.*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">boolean</span> active; <span class="comment">// unrigester之后为false</span></span><br></pre></td></tr></table></figure></p>
<p><strong>1B.</strong></p>
<p>构造函数就是为这三个变量赋值：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Subscription(Object subscriber, SubscriberMethod subscriberMethod)&#123;</span><br><span class="line">	<span class="keyword">this</span>.subscriber = subscriber;</span><br><span class="line">	<span class="keyword">this</span>.subscriberMethod = subscriberMethod;</span><br><span class="line">	active = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>⑧HandlerPoster.JAVA</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HandlerPoster</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;&#125;</span><br><span class="line">	<span class="comment">//四个成员变量：</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> PendingPostQueue queue;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> maxMillisInsideHandleMessage;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> EventBus eventBus;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">boolean</span> handlerActive;</span><br></pre></td></tr></table></figure>
<p><strong>1F.</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Subscription subscription, Object event)</span> </span>&#123;</span><br><span class="line">	PendingPost pendingPost = PendingPost.obtainPendingPost(subscription, event);---&gt; <span class="number">1</span>G,根据订阅信息和event取出pendingPost，</span><br><span class="line">		<span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">			queue.enqueue(pendingPost); <span class="comment">//插入等待队列</span></span><br><span class="line">			<span class="keyword">if</span> (!handlerActive) &#123;</span><br><span class="line">			<span class="comment">//如果handler不活跃，就打开它（可能之前没有msg给handler处理）直接发送消息进行处理</span></span><br><span class="line">				handlerActive = <span class="keyword">true</span>;</span><br><span class="line">			<span class="keyword">if</span> (!sendMessage(obtainMessage())) &#123; </span><br><span class="line">			<span class="comment">//handler发送msg出去----&gt;1H</span></span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(**<span class="string">"Could not send handler message"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>1H.消息处理函数</strong>，但是handleMessage有三个级别,handler的是最不优先的- -</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">boolean</span> rescheduled = <span class="keyword">false</span>;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="keyword">long</span> started = SystemClock.uptimeMillis();</span><br><span class="line">		<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">			PendingPost pendingPost = queue.poll();</span><br><span class="line">			<span class="comment">//移出并返回队头，如果queue是空的，就返回null，不会抛异常</span></span><br><span class="line">			<span class="keyword">if</span> (pendingPost == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="comment">//如果队列为空</span></span><br><span class="line">				<span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123; <span class="comment">//锁住当前handler</span></span><br><span class="line">				<span class="comment">// Check again, this time in synchronized*</span></span><br><span class="line">					pendingPost = queue.poll(); <span class="comment">//再取？</span></span><br><span class="line">					<span class="keyword">if</span> (pendingPost == <span class="keyword">null</span>) &#123;</span><br><span class="line">					<span class="comment">//还是空，那么这个handler没事干了</span></span><br><span class="line">						handlerActive = <span class="keyword">false</span>;</span><br><span class="line">						<span class="keyword">return</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="comment">//又调用eventBus的invokeSubscriber函数，1E已经分析了。利用反射调用订阅方法。</span></span><br><span class="line">		eventBus.invokeSubscriber(pendingPost);----&gt;不是<span class="number">1</span>E！参数不同！<span class="number">1</span>K,不过最终还是可能调用<span class="number">1</span>E</span><br><span class="line">		<span class="keyword">long</span> timeInMethod = SystemClock.uptimeMillis() - started;</span><br><span class="line">		<span class="comment">//如果执行method的时间大于了handleMsg规定的时间</span></span><br><span class="line">		<span class="keyword">if</span> (timeInMethod &gt;= maxMillisInsideHandleMessage) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!sendMessage(obtainMessage())) &#123; <span class="comment">//又发送出去执行？？</span></span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">"Could not send handler message"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			rescheduled = <span class="keyword">true</span>;<span class="comment">// 重新调度了</span></span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">	handlerActive = rescheduled; <span class="comment">//如果发生了重新调度，handlerActive为真</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>⑨PendingPost.JAVA</strong></p>
<p>四个成员变量：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> List&lt;PendingPost&gt; pendingPostPool = <span class="keyword">new</span></span><br><span class="line">ArrayList&lt;PendingPost&gt;();</span><br><span class="line">Object event;</span><br><span class="line">Subscription subscription;</span><br><span class="line">PendingPost next;</span><br></pre></td></tr></table></figure></p>
<p>一个构造函数：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">PendingPost</span><span class="params">(Object event, Subscription subscription)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.event = event;</span><br><span class="line">	<span class="keyword">this</span>.subscription = subscription;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>1G.</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> PendingPost <span class="title">obtainPendingPost</span><span class="params">(Subscription subscription, Object event)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">synchronized</span> (pendingPostPool) &#123;</span><br><span class="line">		<span class="keyword">int</span> size = pendingPostPool.size();</span><br><span class="line">		<span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="comment">//取出postPool中最后一个pendingPost</span></span><br><span class="line">			PendingPost pendingPost = pendingPostPool.remove(size - <span class="number">1</span>);</span><br><span class="line">			pendingPost.event = event;</span><br><span class="line">			pendingPost.subscription = subscription;</span><br><span class="line">			pendingPost.next = <span class="keyword">null</span>;</span><br><span class="line">			<span class="keyword">return</span> pendingPost;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//如果pengdingPostPool为空，直接用事件和订阅信息new一个新的pendingPost</span></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> PendingPost(event, subscription);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>1L.</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">releasePendingPost</span><span class="params">(PendingPost pendingPost)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//将pendingPost的各变量置为null</span></span><br><span class="line">	pendingPost.event = <span class="keyword">null</span>;</span><br><span class="line">	pendingPost.subscription = <span class="keyword">null</span>;</span><br><span class="line">	pendingPost.next = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">synchronized</span> (pendingPostPool) &#123;</span><br><span class="line">		<span class="comment">/*锁住postPool，把这个pendingPost放进去= =话说，为什么不直接pendingPost=null...恩，如果里面的这三个变量不为null，那么应该无法回收，但是也可以先把变量置为null,再把pendingPost=null</span></span><br><span class="line"><span class="comment">		但是这里直接把变量置为null然后重用？ 所以这是传说中的对象池...恩</span></span><br><span class="line"><span class="comment">		// Don't let the pool grow indefinitely</span></span><br><span class="line"><span class="comment">		if (pendingPostPool.size() &lt; 10000) &#123;</span></span><br><span class="line"><span class="comment">			pendingPostPool.add(pendingPost);</span></span><br><span class="line"><span class="comment">		&#125;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br></pre></td></tr></table></figure>
<p><strong>⑩BackgroundPoster.java</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">BackgroundPoster</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;&#125;</span><br><span class="line"><span class="comment">//是一个线程,三个成员变量：</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> PendingPostQueue queue; <span class="comment">//等到这个线程处理的事件队列</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> EventBus eventBus;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> executorRunning;</span><br></pre></td></tr></table></figure>
<p>构造函数：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BackgroundPoster(EventBus eventBus) &#123;</span><br><span class="line">	<span class="keyword">this</span>.eventBus = eventBus;</span><br><span class="line">	queue = <span class="keyword">new</span> PendingPostQueue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>持有了eventBus的引用，也许有内存泄漏？</p>
<p><strong>1I.</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Subscription subscription, Object event)</span> </span>&#123;</span><br><span class="line">PendingPost pendingPost = PendingPost.obtainPendingPost(subscription, event);</span><br><span class="line"><span class="comment">//根据subscription和要发布的事件构造pendingPost</span></span><br><span class="line">	<span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">		queue.enqueue(pendingPost); <span class="comment">//入队</span></span><br><span class="line">		<span class="keyword">if</span> (!executorRunning) &#123; <span class="comment">//这个runnable此时没有在执行</span></span><br><span class="line">			executorRunning = <span class="keyword">true</span>;<span class="comment">//那么可以利用起来了</span></span><br><span class="line">			<span class="comment">//eventBus的线程池执行当前runnable</span></span><br><span class="line">			eventBus.getExecutorService().execute(**<span class="keyword">this</span>**);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>⑪AsyncPoster.JAVA</strong></p>
<p>三个成员变量：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> PendingPostQueue queue;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> EventBus eventBus;</span><br></pre></td></tr></table></figure></p>
<p>构造函数：持有了eventBus的引用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">AsyncPoster(EventBus eventBus) &#123;</span><br><span class="line">	<span class="keyword">this</span>.eventBus = eventBus;</span><br><span class="line">	queue = <span class="keyword">new</span> PendingPostQueue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>1J.</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造了pendingPost后直接进入队列，执行让eventBus的线程池执行它= =</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Subscription subscription, Object event)</span> </span>&#123;</span><br><span class="line">	PendingPost pendingPost = PendingPost.obtainPendingPost(subscription, event);</span><br><span class="line">	queue.enqueue(pendingPost);</span><br><span class="line">	eventBus.getExecutorService().execute(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//从队列里面取出pendingPost</span></span><br><span class="line">	PendingPost pendingPost = queue.poll();</span><br><span class="line">	<span class="keyword">if</span>(pendingPost == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"No pending post available"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*1E分析过，反射机制执行subscription里面的method（打脸，这不是1E</span></span><br><span class="line"><span class="comment">	eventBus.invokeSubscriber(pendingPost);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/07/Android中各种监控原理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ke Yu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coco">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/07/Android中各种监控原理/" itemprop="url">Android中监测各种数据的方法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-09-07T20:33:24+08:00">
                2017-09-07
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="监测内存"><a href="#监测内存" class="headerlink" title="监测内存"></a>监测内存</h3><pre><code>* 监测方法
Runtime runtime = Runtime.getRuntime();
通过runtime可以获得当前虚拟机的总内存、使用中内存。
</code></pre><h3 id="监测CPU"><a href="#监测CPU" class="headerlink" title="监测CPU"></a>监测CPU</h3><pre><code>* 监测方法
1）/proc/cpuinfo ： 读取cpu类型、名字等信息
2）/sys/devices/system/cpu/ ：读取cpu频率
3）/proc/stat：读取cpu使用情况（想想学OS时候cpu计算的那些值...)
</code></pre><h3 id="监测FPS"><a href="#监测FPS" class="headerlink" title="监测FPS"></a>监测FPS</h3><h3 id="监测卡顿"><a href="#监测卡顿" class="headerlink" title="监测卡顿"></a>监测卡顿</h3><pre><code>* 主线程执行的内容：
UI绘制、系统事件、输入事件、程序回调服务等

* 监测方法：
1）直接通过连续的FPS帧数计算丢帧率。缺点：FPS刷新频率太快，容易发生抖动。

2）检测主线程消息循坏执行的时间。（想想MainLooper）。如果主线程消息循坏执行时间超过某个阙值T，那么就认为是发生了一次卡顿。
优化：
方案①：每一次都进行循环超时检测肯定不太现实，可以考虑检测N次循环时间，看是否超过阙值N*T；
方案②：以一个时间段为标准，每次卡顿阙值为T，卡顿次数阙值为K次，如果一个时间段里面卡顿次数大于K，那么进行上报。

* 如何定位问题：
1）抓取发生卡顿时的堆栈，有两个问题：
① 何时抓取，当时是要在卡顿发生时抓取
② 堆栈怎么归类，和Crash堆栈归类的区别
</code></pre><h3 id="监测流量"><a href="#监测流量" class="headerlink" title="监测流量"></a>监测流量</h3><pre><code>注意这是客户端的流量监测，而不是服务端的流量监测。为什么有两种？
a.一些网络请求可能无法到达服务端，无法被服务端监测的; b.网络请求都到达了服务端，但是不一定将流量监测结果成功上报。

* 监测方法
AOP拦截网络请求API（代码没看懂....)

* 如何定位问题
1）流量来源，API、H5还是CDN
对于一个只有API请求的客户端来说，当然可以确定来源，但作为一个框架开发，肯定要考虑各种各样的情景。
一个简单的方法是通过域名来判断，但如果一个域名又有API服务，又有Web服务怎么办呢？
“检验返回包的MIMEType&quot; 啥意思。

2）网络类型，WIFI,4G,3G，未知
</code></pre><h3 id="监测页面加载速度"><a href="#监测页面加载速度" class="headerlink" title="监测页面加载速度"></a>监测页面加载速度</h3><pre><code>* 监测方法

加载时间：
1）测试UI渲染时间
2）测试网络数据获取时间
3）页面最后显示出来花的时间
怎么获得时间呢？
方法①：在完成相关操作时进行埋点，明显很低效
方法②：映射每个页面和对应的api，在api请求的基类中埋点
猜想：通过api获得Activity，从而埋点。
方法③：hook关键节点上的api调用，注入埋点代码（hook到底是什么鬼意思....)
</code></pre><p>​<br>​    </p>
<p>​    </p>
<p><a href="https://mp.weixin.qq.com/s/MwgjpHj_5RaG74Z0JjNv5g" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/MwgjpHj_5RaG74Z0JjNv5g</a><br><a href="http://www.jianshu.com/p/d4c3d4f45504" target="_blank" rel="noopener">http://www.jianshu.com/p/d4c3d4f45504</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/07/SparseArray/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ke Yu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coco">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/07/SparseArray/" itemprop="url">SparseArray源码解析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-09-07T20:31:14+08:00">
                2017-09-07
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Creates a new SparseArray containing no mappings that will not</span><br><span class="line"> * require any additional memory allocation to store the specified</span><br><span class="line"> * number of mappings.  If you supply an initial capacity of 0, the</span><br><span class="line"> * sparse array will be initialized with a light-weight representation</span><br><span class="line"> * not requiring any additional array allocations.</span><br><span class="line"> */</span><br><span class="line">public SparseArray(int initialCapacity) &#123;</span><br><span class="line">    if (initialCapacity == 0) &#123;</span><br><span class="line">        mKeys = EmptyArray.INT;</span><br><span class="line">        mValues = EmptyArray.OBJECT;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        mValues = ArrayUtils.newUnpaddedObjectArray(initialCapacity);</span><br><span class="line">        mKeys = new int[mValues.length];</span><br><span class="line">    &#125;</span><br><span class="line">    mSize = 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>查找</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public E get(int key) &#123;</span><br><span class="line">    return get(key, null);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Gets the Object mapped from the specified key, or the specified Object</span><br><span class="line"> * if no such mapping has been made.</span><br><span class="line"> */</span><br><span class="line">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">public E get(int key, E valueIfKeyNotFound) &#123;</span><br><span class="line">    int i = ContainerHelpers.binarySearch(mKeys, mSize, key);</span><br><span class="line"></span><br><span class="line">    if (i &lt; 0 || mValues[i] == DELETED) &#123;</span><br><span class="line">        return valueIfKeyNotFound;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return (E) mValues[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>插入</li>
</ul>
<p>插入时，参数既要有key又要有value。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">/**  put插入</span><br><span class="line">     * Adds a mapping from the specified key to the specified value,</span><br><span class="line">     * replacing the previous mapping from the specified key if there</span><br><span class="line">     * was one.</span><br><span class="line">     */</span><br><span class="line">    public void put(int key, E value) &#123;</span><br><span class="line">        int i = ContainerHelpers.binarySearch(mKeys, mSize, key);</span><br><span class="line"></span><br><span class="line">        if (i &gt;= 0) &#123;</span><br><span class="line">            mValues[i] = value;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            i = ~i;</span><br><span class="line">            // 空间已经有了,但是被删除了，那么重新赋值</span><br><span class="line">            if (i &lt; mSize &amp;&amp; mValues[i] == DELETED) &#123;</span><br><span class="line">                mKeys[i] = key;</span><br><span class="line">                mValues[i] = value;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            // 空间超出，先gc一下</span><br><span class="line">            if (mGarbage &amp;&amp; mSize &gt;= mKeys.length) &#123;</span><br><span class="line">                gc();</span><br><span class="line"></span><br><span class="line">                // Search again because indices may have changed.</span><br><span class="line">                i = ~ContainerHelpers.binarySearch(mKeys, mSize, key);</span><br><span class="line">            &#125;</span><br><span class="line">            // 扩展数组</span><br><span class="line">            mKeys = GrowingArrayUtils.insert(mKeys, mSize, i, key);</span><br><span class="line">            mValues = GrowingArrayUtils.insert(mValues, mSize, i, value);</span><br><span class="line">            mSize++; // SparseArray大小增加</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**  append插入</span></span><br><span class="line"><span class="comment">     * Puts a key/value pair into the array, optimizing for the case where</span></span><br><span class="line"><span class="comment">     * the key is greater than all existing keys in the array.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">append</span><span class="params">(<span class="keyword">int</span> key, E value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mSize != <span class="number">0</span> &amp;&amp; key &lt;= mKeys[mSize - <span class="number">1</span>]) &#123;</span><br><span class="line">            put(key, value);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 优化了key大于数组中所有key的情况，mKeys[mSize-1]是这个数组中最大的一个key</span></span><br><span class="line">        <span class="keyword">if</span> (mGarbage &amp;&amp; mSize &gt;= mKeys.length) &#123;</span><br><span class="line">            gc();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mKeys = GrowingArrayUtils.append(mKeys, mSize, key);</span><br><span class="line">        mValues = GrowingArrayUtils.append(mValues, mSize, value);</span><br><span class="line">        mSize++;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>整理空间</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">gc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// Log.e("SparseArray", "gc start with " + mSize);</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">int</span> n = mSize;</span><br><span class="line">      <span class="keyword">int</span> o = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">int</span>[] keys = mKeys;</span><br><span class="line">      Object[] values = mValues;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">          Object val = values[i];</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (val != DELETED) &#123;</span><br><span class="line">              <span class="keyword">if</span> (i != o) &#123;</span><br><span class="line">                  keys[o] = keys[i];</span><br><span class="line">                  values[o] = val;</span><br><span class="line">                  values[i] = <span class="keyword">null</span>;</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">              o++;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      mGarbage = <span class="keyword">false</span>;</span><br><span class="line">      mSize = o;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Log.e("SparseArray", "gc end with " + mSize);</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Removes the mapping from the specified key, if there was any.</span><br><span class="line"> */</span><br><span class="line">public void delete(int key) &#123;</span><br><span class="line">    int i = ContainerHelpers.binarySearch(mKeys, mSize, key);</span><br><span class="line"></span><br><span class="line">    if (i &gt;= 0) &#123;</span><br><span class="line">        if (mValues[i] != DELETED) &#123;</span><br><span class="line">            mValues[i] = DELETED;</span><br><span class="line">            mGarbage = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>最关键的二分法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// This is Arrays.binarySearch(), but doesn&apos;t do any argument validation.</span><br><span class="line">static int binarySearch(int[] array, int size, int value) &#123;</span><br><span class="line">    int lo = 0;</span><br><span class="line">    int hi = size - 1;</span><br><span class="line"></span><br><span class="line">    while (lo &lt;= hi) &#123;</span><br><span class="line">        final int mid = (lo + hi) &gt;&gt;&gt; 1;</span><br><span class="line">        final int midVal = array[mid];</span><br><span class="line"></span><br><span class="line">        if (midVal &lt; value) &#123;</span><br><span class="line">            lo = mid + 1;</span><br><span class="line">        &#125; else if (midVal &gt; value) &#123;</span><br><span class="line">            hi = mid - 1;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return mid;  // value found</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return ~lo;  // value not present</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>可以看出SparseArray里面的元素是按照key从小到大排序的，所以插入、删除、查找的速度都很快</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/07/Android四大组件----Activity（2）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ke Yu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coco">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/07/Android四大组件----Activity（2）/" itemprop="url">Activity(2)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-09-07T17:19:20+08:00">
                2017-09-07
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Android四大组件—-Activity（2）"><a href="#Android四大组件—-Activity（2）" class="headerlink" title="Android四大组件—-Activity（2）"></a>Android四大组件—-Activity（2）</h1><ul>
<li><p><a href="#Android四大组件----Activity（2）-基础概念">基础概念</a></p>
<ul>
<li><p><a href="#Android四大组件----Activity（2）-通信">通信</a></p>
<ul>
<li><p><a href="#Android四大组件----Activity（2）-1.ActivityMa">1.ActivityManagerService</a></p>
</li>
<li><p><a href="#Android四大组件----Activity（2）-2.IApplicati">2.IApplicationThread</a></p>
</li>
<li><p><a href="#Android四大组件----Activity（2）-3.IActivityM">3.IActivityManager</a></p>
</li>
<li><p><a href="#Android四大组件----Activity（2）-4.基本联系">4.基本联系</a></p>
</li>
</ul>
</li>
<li><p><a href="#Android四大组件----Activity（2）-协助">协助</a></p>
<ul>
<li><p><a href="#Android四大组件----Activity（2）-1.ActivityRe">1.ActivityRecord</a></p>
</li>
<li><p><a href="#Android四大组件----Activity（2）-2.TaskRecord">2.TaskRecord</a></p>
</li>
<li><p><a href="#Android四大组件----Activity（2）-3.ActivitySt">3.ActivityStack</a></p>
</li>
<li><p><a href="#Android四大组件----Activity（2）-4.ActivityTh">4.ActivityThread</a></p>
</li>
</ul>
</li>
<li><p><a href="#Android四大组件----Activity（2）-5.Instrument">5.Instrumentation</a></p>
</li>
</ul>
</li>
<li><p><a href="#Android四大组件----Activity（2）-基本过程">基本过程</a></p>
</li>
<li><p><a href="#Android四大组件----Activity（2）-一些问题">一些问题</a></p>
<ul>
<li><p><a href="#Android四大组件----Activity（2）-问题1">问题1</a></p>
</li>
<li><p><a href="#Android四大组件----Activity（2）-问题2">问题2</a></p>
</li>
</ul>
</li>
</ul>
<h3 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h3><h4 id="通信"><a href="#通信" class="headerlink" title="通信"></a>通信</h4><h5 id="1-ActivityManagerService"><a href="#1-ActivityManagerService" class="headerlink" title="1.ActivityManagerService"></a>1.ActivityManagerService</h5><p>主要管理应用进程的生命周期以及进程的Activity,Service,Broadcast等等。</p>
<p>可以分为client端与Server端：</p>
<ul>
<li><p>Client端运行在app的各个进程，这些进程实现了具体的activity和service，通过调用系统接口来完成显示。</p>
</li>
<li><p>Service端运行在系统进程中，是系统级别的AMS的实现，响应client端的系统调用请求，并且管理client端的各个APP的生命周期。</p>
</li>
</ul>
<h5 id="2-IApplicationThread"><a href="#2-IApplicationThread" class="headerlink" title="2.IApplicationThread"></a>2.IApplicationThread</h5><p>该接口定义了AMS访问App的接口。AMS通过这个接口的实现控制App的进程完成App的响应。</p>
<p>实现：ApplicationThread。实质上是一个Binder对象，在进程启动，创建ActivityThread时实例化，AMS通过它的代理ApplicationThreadProxy和Activity进行进程间通信。</p>
<h5 id="3-IActivityManager"><a href="#3-IActivityManager" class="headerlink" title="3.IActivityManager"></a>3.IActivityManager</h5><p>该接口定义了App访问AMS的接口。App通过这个接口的实现对请求AMS完成某些操作。</p>
<p>实现：ActivityManagerNative。Activity通过代理ActivityManagerProxy将请求送到AMS进行进程间通信。</p>
<h5 id="4-基本联系"><a href="#4-基本联系" class="headerlink" title="4.基本联系"></a>4.基本联系</h5><ul>
<li><p>一个进程对应一个ActivityThread实例，这个进程里面所有的activity对应这一个ActivityThread实例</p>
</li>
<li><p>一个进程对应一个ApplicationThread对象，此对象是ActivityThread 与<br>ActivityManagerService连接的桥梁。</p>
</li>
</ul>
<h4 id="协助"><a href="#协助" class="headerlink" title="协助"></a>协助</h4><h5 id="1-ActivityRecord"><a href="#1-ActivityRecord" class="headerlink" title="1.ActivityRecord"></a>1.ActivityRecord</h5><ul>
<li>记录一个Activity的相关信息</li>
</ul>
<h5 id="2-TaskRecord"><a href="#2-TaskRecord" class="headerlink" title="2.TaskRecord"></a>2.TaskRecord</h5><ul>
<li><p>记录当前Task中所有Activity：ArrayList\&lt;ActivityRecord> mActivities</p>
</li>
<li><p>ActivityStack成员stack记录Task所在的栈，用于执行ActivityStack的方法</p>
</li>
</ul>
<h5 id="3-ActivityStack"><a href="#3-ActivityStack" class="headerlink" title="3.ActivityStack"></a>3.ActivityStack</h5><p>管理协调ActivityRecord和TaskRecord</p>
<ul>
<li><p>记录所有的栈</p>
</li>
<li><p>通知WindowManagerService的监听器</p>
</li>
</ul>
<h5 id="4-ActivityThread"><a href="#4-ActivityThread" class="headerlink" title="4.ActivityThread"></a>4.ActivityThread</h5><ul>
<li><p>应用程序的入口</p>
</li>
<li><p>管理【应用程序的主线程】—–它自己不是线程</p>
</li>
<li><p>根据AMS的要求，进行Activity的调度</p>
</li>
</ul>
<h4 id="5-Instrumentation"><a href="#5-Instrumentation" class="headerlink" title="5.Instrumentation"></a>5.Instrumentation</h4><ul>
<li><p>管理监测Android控件的运行</p>
</li>
<li><p>根据ActivityThread的要求，完成Activity的生命周期控制</p>
</li>
</ul>
<h3 id="基本过程"><a href="#基本过程" class="headerlink" title="基本过程"></a>基本过程</h3><p>step1：无论是launcher启动，还是activity内部调用startActivity接口来启动新的Activity，都是通过Binder的进程间通信进入到AMS进程中，然后调用ActivityManagerService.startActivity。</p>
<p>期间主要经历以下过程：</p>
<p> 1)在Launcher.startActivity中由于.MainActivity在注册文件中设置了intent，所以点击图标时，launcher会将这个activity启动。<br>问题1：intent的信息怎么被Launcher找到？</p>
<p> 2)在Activity.startActivityForResult中，通过mMainThread（应用的主线程）.getApplicationThread获得了<strong>ApplicationThread</strong>对象，用于AMS和ActivityThread的通信，然后执行了Instrumentation.execStartActivity。</p>
<p> 3)在Instrumentation.execStartActivity中，通过ActivityManagerNative.getDefault返回ActivityManagerService的远程接口，得到了<strong>ActivityManagerProxy</strong>接口。</p>
<p> 4)通过<strong>ActivityManagerProxy</strong>接口，向AMS发出请求，也就是执行ActivityManagerService.startActivity。</p>
<p>step2：AMS.startActivity将操作转发给成员变量mMainStack（ActivityStack类型）的startActivityMayWait函数，来准备要启动的Activity的相关信息。</p>
<p>之后会经历以下过程：</p>
<p> 1)在 ActivityStack.startActivityLocked中，可以从传进来的参数中得到调用者的信息，即Laucher应用程序的进程信息。</p>
<p> 2)在ActivityStack.startActivityUncheckedLocked中，根据当前Activity的启动模式、taskAfiinity属性，设置的intent<br>flags等选择Task。为当前新创建的ActivityRecord找到Task。</p>
<pre><code>比较复杂，其实是理解启动模式的关键。还是需要结合源码才能理解。
</code></pre><p> 3)根据启动模式的相关知识，寻找Task还涉及到Task顶端的Activty。这个过程由resumeTopActivityLocked完成，主要就是看我们要启动的Activity是否在栈顶，如果不是的话，需要将当前运行的Activity暂停。这个工作还是由ActivityStack.startPausingLocked()来完成。</p>
<p>step3：ActivityStack在startPausingLocked中会将需要暂停的Activity暂停，主要经历以下过程：</p>
<p> 1)通过ApplicationThread.schedulePauseActivity进行通信，告诉ActivityThread执行handlePauseActivity</p>
<p> 2)ActivityThread接收到通知，于是通过ActivityManager向ActivityManagerService发起activityPaused的请求</p>
<p> 3) ActivityManagerService接收到请求，把工作交给ActivityStack，它进行了Activity的停止工作</p>
<p> 4)停止了该停止了Activity，又通过ApplicationThread来告诉系统服务进程要进行真正的Activity启动调度了。这个系统进程就是在step1中发出startActivity请求的Activity对应的进程，比如对于点击程序图标启动，那么就是Launcher所在进程，而对于Activity内部调用startActivity的情景，这个就是这个Activity所在进程。</p>
<p>step4：ApplicationThread不执行真正的启动操作，它通过ActivityManagerService.activityPause接口进入到AMS进程中，看是否需要创建新的进程来启动Activity。<br>如果是点击应用图标启动的话， ActivityManagerService<br>在这步会调用startProcessLocked来创建一个新的进程，而对于通过在Activty内部调用startActivity来启动新的Activity来说，这步不需要，因为新的activity就在原来的activity所在的进程中启动。</p>
<p>step5：ActivityManagerService调用ApplicationThread.scheduleLaunchActivity，通知相应的进程执行Activity的操作。<br>ApplicationThread把这个启动Activity的操作转发给ActivityThread，ActivityThread发送msg，接收到消息后进行handleLaunchActivity操作，该操作主要是调用进行PerformLaunchActivity</p>
<p>主要是以下过程：</p>
<pre><code>1）ActivityThread
</code></pre><p>调用Instrumentation的newOnActivity方法，通过ClassLoader导入相应的Activity类</p>
<p>2）创建Application对象（一个应用只有一个Application），然后通过attach把activity的上下文信息（Context）设置到mainActivity去。</p>
<p>3）Instrumentation调用callActivityOnCreate()执行Activity的onCreate()方法。</p>
<h3 id="一些问题"><a href="#一些问题" class="headerlink" title="一些问题"></a>一些问题</h3><h4 id="问题1"><a href="#问题1" class="headerlink" title="问题1"></a>问题1</h4><p>Launcher怎么获得intent信息？</p>
<ul>
<li>涉及到PackageManagerService。它负责apk的安装、卸载等，在安装apk时会进行package的解析，把四大组件的相关信息存储下来。解析时，PMS中有相关的操作，对intentFiters查找、添加与匹配。对于一个新安装的应用，PMS找到intent-fileter中action为“android.intent.action.MAIN”并且category为“android.intent.category.LAUNCHER”的Activity，就会为这种应用程序创建桌面图标。</li>
</ul>
<h4 id="问题2"><a href="#问题2" class="headerlink" title="问题2"></a>问题2</h4><p>ActivityThread如何管理主线程？</p>
<ul>
<li><p>从上述对Activity启动过程的简单介绍中，可以看到ActivityThread会执行handlePauseActivity、PerformLaunchActivity等操作，也就是说ActivityThread控制了Activity的暂停、创建等操作，在ActivityThread的main()函数中可以看到它做了这样的事：</p>
</li>
<li><p>1)创建Looper</p>
</li>
<li><p>2)创建ActivityThread对象</p>
</li>
<li><p>3)创建binder对象ApplicationThread，将它和当前ActivityThread以及Application绑定</p>
</li>
<li><p>4)Looper循环，Handler接收消息，然后ActivityThread就可以执行handle方法，通过ActivityManager向ActivityManagerService发出请求</p>
</li>
</ul>
<p>参考资料：</p>
<p><a href="http://blog.csdn.net/luoshengyang/article/details/6689748" target="_blank" rel="noopener">http://blog.csdn.net/luoshengyang/article/details/6689748</a></p>
<p><a href="http://blog.csdn.net/luoshengyang/article/details/6685853" target="_blank" rel="noopener">http://blog.csdn.net/luoshengyang/article/details/6685853</a></p>
<p><a href="http://www.2cto.com/kf/201610/554316.html" target="_blank" rel="noopener">http://www.2cto.com/kf/201610/554316.html</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/07/volleySourceAny/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ke Yu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coco">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/07/volleySourceAny/" itemprop="url">volly源码解析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-09-07T14:09:30+08:00">
                2017-09-07
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="①Request-java"><a href="#①Request-java" class="headerlink" title="①Request.java"></a>①Request.java</h3><p><strong>实现了</strong> Comparable&lt;Request<t>&gt; 接口</t></p>
<p>抽象类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Request</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span></span></span><br><span class="line"><span class="class"><span class="title">Comparable</span>&lt;<span class="title">Request</span>&lt;<span class="title">T</span>&gt;&gt; </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>两个构造函数，有一个已经废弃了(所以后面的所有具体实现中，有一个构造函数也是被弃用了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Request</span><span class="params">(<span class="keyword">int</span> method, String url, Response.ErrorListener listener)</span></span>;</span><br></pre></td></tr></table></figure>
<p>具体分析一下几种request：</p>
<p>a.StringRequest:</p>
<p>1）方法、URL、监听器<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">StringRequest</span><span class="params">(<span class="keyword">int</span> method, String url, Listener&lt;String&gt; listener,ErrorListener errorListener)</span></span></span><br></pre></td></tr></table></figure></p>
<p>2）结束时，调用父类的方法（其实父类中也是置空监听器）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onFinish</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">super</span>.onFinish();</span><br><span class="line">	mListener = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3）回调接口函数<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">deliverResponse</span><span class="params">(String response)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(mListener != <span class="keyword">null</span>) &#123;</span><br><span class="line">		mListener.onResponse(response);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>4）把接收到的response信息解析，主要是cache分发器和network分发器会用到，response不是像我们一样简单的弄成String，而是专门根据类型存放一个在Response&lt;&gt;对象中<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Response\&lt;String\&gt; parseNetworkResponse(NetworkResponse response)</span><br><span class="line">&#123;</span><br><span class="line">	String parsed;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		parsed = <span class="keyword">new</span> String(response.data,</span><br><span class="line">		HttpHeaderParser.parseCharset(response.headers));</span><br><span class="line">	&#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">		parsed = <span class="keyword">new</span> String(response.data);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> Response.success(parsed,</span><br><span class="line">	HttpHeaderParser.parseCacheHeaders(response)); --&gt; 这个函数其实是response构造</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>b.JsonRequest</p>
<p>1)构造函数<br>参数：方法、url、requestBody、监听器<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">JsonRequest</span><span class="params">(<span class="keyword">int</span> method, String url, String requestBody,</span></span></span><br><span class="line"><span class="function"><span class="params">	Listener&lt;T&gt; listener,ErrorListener errorListener)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">super</span>(method, url, errorListener);</span><br><span class="line">	mListener = listener;</span><br><span class="line">	mRequestBody = requestBody;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>2）onFinish（）和diliverResponse（）与上面一样。</p>
<p>3）交给JsonArrayRequest和JsonObjectRequest去实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">abstract</span> <span class="keyword">protected</span> Response&lt;T&gt; <span class="title">parseNetworkResponse</span><span class="params">(NetworkResponse response)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>4）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getBodyContentType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> PROTOCOL_CONTENT_TYPE; <span class="comment">// utf-8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>5）把请求体的内容转为bytes[]类型（String的方法 getBytes）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">byte</span>[] getBody() &#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> mRequestBody == <span class="keyword">null</span> ? <span class="keyword">null</span> : mRequestBody.getBytes(PROTOCOL_CHARSET);</span><br><span class="line">	&#125; <span class="keyword">catch</span> (UnsupportedEncodingException uee) &#123;</span><br><span class="line">		VolleyLog.wtf(<span class="string">"Unsupported Encoding while trying to get the bytes of %s</span></span><br><span class="line"><span class="string">		using %s"</span>,mRequestBody, PROTOCOL_CHARSET);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>c.ImageRequest（这种方法过时了）</p>
<p>1)构造函数<br>在加载图片时如果图片超过期望的最大宽度和高度则会进行压缩。注意两个类型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//@param scaleType The ImageViews ScaleType used to calculate the needed image size.</span></span><br><span class="line"><span class="comment">//@param decodeConfig Format to decode the bitmap to</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ImageRequest</span><span class="params">(String url, Response.Listener&lt;Bitmap&gt; listener,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">int</span> maxWidth, <span class="keyword">int</span> maxHeight, ScaleType scaleType, Config decodeConfig, Response.ErrorListener errorListener)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">super</span>(Method.GET, url, errorListener);</span><br><span class="line">	setRetryPolicy(<span class="keyword">new</span> DefaultRetryPolicy(IMAGE_TIMEOUT_MS, IMAGE_MAX_RETRIES,IMAGE_BACKOFF_MULT));</span><br><span class="line">	mListener = listener;</span><br><span class="line">	mDecodeConfig = decodeConfig;</span><br><span class="line">	mMaxWidth = maxWidth;</span><br><span class="line">	mMaxHeight = maxHeight;</span><br><span class="line">	mScaleType = scaleType;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2)同样的，要对response进行解析：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Response&lt;Bitmap&gt; <span class="title">parseNetworkResponse</span><span class="params">(NetworkResponse response)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// Serialize all decode on a global lock to reduce concurrent heap usage.*</span></span><br><span class="line">	<span class="keyword">synchronized</span> (sDecodeLock) &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> doParse(response);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (OutOfMemoryError e) &#123;</span><br><span class="line">			VolleyLog.e(<span class="string">"Caught OOM for %d byte image, url=%s"</span>,</span><br><span class="line">			response.data.length, getUrl());</span><br><span class="line">			<span class="keyword">return</span> Response.error(<span class="keyword">new</span> ParseError(e));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3）解析函数</p>
<p>和最近写图片压缩方法一样，但是，desiredWidth 和desiredHeight ， 到底是什么鬼？ =<br>= 没看懂，仔细看传值，maxPrimary 和 secondPrimary 主维和二维..就是图片的宽高…</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Response&lt;Bitmap&gt; <span class="title">doParse</span><span class="params">(NetworkResponse response)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">byte</span>[] data = response.data;</span><br><span class="line">	BitmapFactory.Options decodeOptions = <span class="keyword">new</span> BitmapFactory.Options();</span><br><span class="line">	Bitmap bitmap = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">if</span> (mMaxWidth == <span class="number">0</span> &amp;&amp; mMaxHeight == <span class="number">0</span>) &#123;</span><br><span class="line">		decodeOptions.inPreferredConfig = mDecodeConfig;</span><br><span class="line">		bitmap = BitmapFactory.decodeByteArray(data, <span class="number">0</span>, data.length,</span><br><span class="line">		decodeOptions);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// If we have to resize this image, first get the natural bounds.</span></span><br><span class="line">		decodeOptions.inJustDecodeBounds = <span class="keyword">true</span>;</span><br><span class="line">		BitmapFactory.decodeByteArray(data, <span class="number">0</span>, data.length, decodeOptions);</span><br><span class="line">		<span class="keyword">int</span> actualWidth = decodeOptions.outWidth;</span><br><span class="line">		<span class="keyword">int</span> actualHeight = decodeOptions.outHeight;</span><br><span class="line">		<span class="comment">// Then compute the dimensions we would ideally like to decode to.</span></span><br><span class="line">		<span class="keyword">int</span> desiredWidth = getResizedDimension(mMaxWidth, mMaxHeight,</span><br><span class="line">		actualWidth, actualHeight, mScaleType);</span><br><span class="line">		<span class="keyword">int</span> desiredHeight = getResizedDimension(mMaxHeight, mMaxWidth,</span><br><span class="line">		actualHeight, actualWidth, mScaleType);</span><br><span class="line">		<span class="comment">// Decode to the nearest power of two scaling factor.</span></span><br><span class="line">		decodeOptions.inJustDecodeBounds = <span class="keyword">false</span>;</span><br><span class="line">		<span class="comment">// TODO(ficus): Do we need this or is it okay since API 8 doesn't support it?</span></span><br><span class="line">		<span class="comment">// decodeOptions.inPreferQualityOverSpeed = PREFER_QUALITY_OVER_SPEED;</span></span><br><span class="line">		decodeOptions.inSampleSize =</span><br><span class="line">		findBestSampleSize(actualWidth, actualHeight, desiredWidth, desiredHeight);</span><br><span class="line">		Bitmap tempBitmap =</span><br><span class="line">		BitmapFactory.decodeByteArray(data, <span class="number">0</span>, data.length, decodeOptions);</span><br><span class="line">		<span class="comment">// If necessary, scale down to the maximal acceptable size.</span></span><br><span class="line">		<span class="keyword">if</span> (tempBitmap != <span class="keyword">null</span> &amp;&amp; (tempBitmap.getWidth() &gt; desiredWidth ||</span><br><span class="line">		tempBitmap.getHeight() &gt; desiredHeight)) &#123;</span><br><span class="line">		<span class="comment">// 可以根据原来的位图创建一个新的位图。= =有点无语，那之前为什么要有inSamplesize?</span></span><br><span class="line">		<span class="comment">// 因为上面是图片内存的压缩= =</span></span><br><span class="line">		由于要考虑samplesize，所以可能达不到desired，这里就 重新来一遍？</span><br><span class="line">		bitmap = Bitmap.createScaledBitmap(tempBitmap,</span><br><span class="line">		desiredWidth, desiredHeight, <span class="keyword">true</span>);</span><br><span class="line">		tempBitmap.recycle();</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		bitmap = tempBitmap;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (bitmap == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> Response.error(<span class="keyword">new</span> ParseError(response));</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> Response.success(bitmap,</span><br><span class="line">		HttpHeaderParser.parseCacheHeaders*(response));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>5）<br>这个函数用来计算desiredWidth和desiredHeight，计算出来这两个值，再用他们来计算samplesize，这其实就是自己写 图片压缩 时候的reqWidth,和 reqHeight， 感觉这里处理得比较巧妙。<br>自己实现的时候，就在想reqWidth和reqHeight要赋值什么- - ，<br>这里让用户设置可以接收的maxWidth和maxHeight（也可以不设置），然后根据规则再计算req的宽高。<br>计算desiredHeight的时候，主维就是mMaxHeight。<br>没懂这个规则= =暂时跳过了…</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getResizedDimension</span><span class="params">(<span class="keyword">int</span> maxPrimary, <span class="keyword">int</span></span></span></span><br><span class="line"><span class="function"><span class="params">maxSecondary, <span class="keyword">int</span> actualPrimary,<span class="keyword">int</span> actualSecondary, ScaleType scaleType)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// If no dominant value at all, just return the actual.</span></span><br><span class="line">	<span class="keyword">if</span> ((maxPrimary == <span class="number">0</span>) &amp;&amp; (maxSecondary == <span class="number">0</span>)) &#123;</span><br><span class="line">		<span class="keyword">return</span> actualPrimary;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// If ScaleType.FIT_XY fill the whole rectangle, ignore ratio.*</span></span><br><span class="line">	<span class="comment">// 填充整个矩形</span></span><br><span class="line">	<span class="keyword">if</span> (scaleType == ScaleType.FIT_XY) &#123;</span><br><span class="line">		<span class="keyword">if</span> (maxPrimary == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> actualPrimary;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> maxPrimary;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// If primary is unspecified, scale primary to match secondary's scaling</span></span><br><span class="line">	ratio.</span><br><span class="line">	<span class="keyword">if</span> (maxPrimary == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">double</span> ratio = (<span class="keyword">double</span>) maxSecondary / (<span class="keyword">double</span>) actualSecondary;</span><br><span class="line">		<span class="keyword">return</span> (<span class="keyword">int</span>) (actualPrimary \ ratio);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (maxSecondary == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> maxPrimary;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">double</span> ratio = (<span class="keyword">double</span>) actualSecondary / (<span class="keyword">double</span>) actualPrimary;</span><br><span class="line">	<span class="keyword">int</span> resized = maxPrimary;</span><br><span class="line">	<span class="comment">// If ScaleType.CENTER_CROP fill the whole rectangle, preserve aspect ratio.</span></span><br><span class="line">	<span class="keyword">if</span> (scaleType == ScaleType.CENTER_CROP) &#123;</span><br><span class="line">		<span class="keyword">if</span> ((resized * ratio) &lt; maxSecondary) &#123;</span><br><span class="line">			resized = (<span class="keyword">int</span>) (maxSecondary / ratio);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> resized;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> ((resized * ratio) &gt; maxSecondary) &#123;</span><br><span class="line">		resized = (<span class="keyword">int</span>) (maxSecondary / ratio);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> resized;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>d.ImageLoader（太长了…在代码里写注释了 = = 不在这里写了…</p>
<p>1）构造函数<br>有七个成员变量，两个涉及构造函数：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ImageLoader</span><span class="params">(RequestQueue queue, ImageCache imageCache)</span> </span>&#123;</span><br><span class="line">	mRequestQueue = queue;</span><br><span class="line">	mCache = imageCache;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>2）内部类，请求的holder，记录该种请求，对应的key,对应的bitmap,以及监听器。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImageContainer</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>3）内部类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">BatchedImageRequest</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>②RequestQueue.java<br>涉及到的数据结构：</p>
<p>0）<br>用于请求队列的递增序号 ， 也即记录了请求的数量<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> AtomicInteger mSequenceGenerator = <span class="keyword">new</span> AtomicInteger();</span><br></pre></td></tr></table></figure></p>
<p><strong>1）用于查找是否有相同cachekey的重复请求（get(cachekey）为null说明没有</strong></p>
<p><strong>key是string,value是一个请求队列！等待中的请求集合，也就是没有被分给cache也没被分给network</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Queue&lt;Request&lt;?&gt;&gt;&gt; mWaitingRequests =</span><br><span class="line"><span class="keyword">new</span> HashMap&lt;String, Queue&lt;Request&lt;?&gt;&gt;&gt;();</span><br></pre></td></tr></table></figure>
<p>2）当前正在处理的请求</p>
<p>如果请求正在任意一个queue中wating，或者正在由任意一个分发函数处理，就会在这个set中<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Set&lt;Request&lt;?&gt;&gt; mCurrentRequests = <span class="keyword">new</span> HashSet&lt;Request&lt;?&gt;&gt;();</span><br></pre></td></tr></table></figure></p>
<p>3）cache类的请求</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> PriorityBlockingQueue&lt;Request&lt;?&gt;&gt; mCacheQueue = <span class="keyword">new</span> PriorityBlockingQueue&lt;Request&lt;?&gt;&gt;();</span><br></pre></td></tr></table></figure>
<p>4）network类的请求</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> PriorityBlockingQueue&lt;Request&lt;?&gt;&gt; mNetworkQueue =</span><br><span class="line"><span class="keyword">new</span> PriorityBlockingQueue&lt;Request&lt;?&gt;&gt;();</span><br></pre></td></tr></table></figure>
<p>5）网络请求最大线程数目：4<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_NETWORK_THREAD_POOL_SIZE = <span class="number">4</span>;</span><br></pre></td></tr></table></figure></p>
<p>6）完成请求后的回调接口：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">\\ Callback <span class="class"><span class="keyword">interface</span> <span class="title">for</span> <span class="title">completed</span> <span class="title">requests</span>. </span></span><br><span class="line"><span class="class">// 完成请求后的回调接口*</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">static</span> <span class="title">interface</span>** <span class="title">RequestFinishedListener</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">\\ Called when a request has finished processing. </span><br><span class="line"><span class="comment">// 请求事务结束后会回调</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onRequestFinished</span><span class="params">(Request&lt;T&gt; request)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>7）任务完成后的监听器队列<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> List&lt;RequestFinishedListener&gt; mFinishedListeners = <span class="keyword">new</span> ArrayList&lt;RequestFinishedListener&gt;();</span><br></pre></td></tr></table></figure></p>
<p>8）三个构造函数：cache,network参数是必须。其余两个分别是线程池默认大小4以及<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> ExecutorDelivery(<span class="keyword">new</span> Handler(Looper.getMainLooper())。</span><br></pre></td></tr></table></figure></p>
<p>最终归于这个：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">RequestQueue</span><span class="params">(Cache cache, Network network, <span class="keyword">int</span> threadPoolSize, ResponseDelivery delivery)</span> </span>&#123;</span><br><span class="line">	mCache = cache;</span><br><span class="line">	mNetwork = network;</span><br><span class="line">	mDispatchers = <span class="keyword">new</span> NetworkDispatcher[threadPoolSize];</span><br><span class="line">	mDelivery = delivery;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>delivery其实是是来自这里，= =<br>读完了response回到这里，发现这个局早在requestQueue里面就布好了…厉害…<br>一开始就把UI线程的handler传给了ExecutorDelivery，这样在cache分发线程的mDelivery.postResponse（）才能很好的调用= =。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">RequestQueue</span><span class="params">(Cache cache, Network network, <span class="keyword">int</span> threadPoolSize)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>(cache, network, threadPoolSize,</span><br><span class="line">	<span class="keyword">new</span> ExecutorDelivery(<span class="keyword">new</span> Handler(Looper.getMainLooper())));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>9）过滤器接口<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RequestFilter</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">apply</span><span class="params">(Request\&lt;?\&gt; request)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>10）两个cancelAll的方法，一个是通过过滤器，一个是通过Object tag</p>
<p>其实tag的方法中，也是靠定义一个 request.getTag()==tag的过滤器实现的。</p>
<p><strong>11） 把请求添加到分发队列中 , add</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Request&lt;T&gt; <span class="title">add</span><span class="params">(Request&lt;T&gt; request)</span> ；</span></span><br><span class="line"><span class="function">首先request.<span class="title">setRequestQueue</span><span class="params">(<span class="keyword">this</span>)</span></span>; 将这个请求标记为属于这个队列</span><br><span class="line">然后<span class="keyword">synchronized</span> (mCurrentRequests) &#123;</span><br><span class="line">	mCurrentRequests.add(request);</span><br><span class="line">&#125;在当前请求队列中加上这个请求</span><br><span class="line">再request.setSequence(getSequenceNumber()); 设置这个请求的序列号</span><br><span class="line">并加上标记。</span><br><span class="line">接着</span><br><span class="line"><span class="keyword">if</span> (!request.shouldCache()) &#123;</span><br><span class="line">	mNetworkQueue.add(request);</span><br><span class="line">	<span class="keyword">return</span> request;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果该请求不要求缓存， 将请求加到newtwork队列中，返回请求。</span></span><br><span class="line">request.shouldCache()</span><br><span class="line"><span class="comment">//是一个返回boolean的函数，可知有一个boolean为每个请求设置了是否需要缓存的标志。</span></span><br><span class="line"><span class="comment">//如果要求缓存，继续下一步：</span></span><br><span class="line"><span class="comment">//判断mWaitingRequests中是否存在相同key的请求队列，也就是是否有相同key的请求在等待，在该结构中，一个string对应了一个队列，其实是一个链表吧...linkedlist</span></span><br><span class="line">Queue&lt;Request&lt;?&gt;&gt; stagedRequests = mWaitingRequests.get(cacheKey);</span><br><span class="line"><span class="comment">//如果有的话，取出这个请求队列（Queue&lt;Request&lt;?&gt;&gt; ） 为空的话:</span></span><br><span class="line"><span class="keyword">if</span> (stagedRequests == <span class="keyword">null</span>) &#123;</span><br><span class="line">	stagedRequests = <span class="keyword">new</span> LinkedList&lt;Request&lt;?&gt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//然后把请求加到这个链表中。再把&lt;Key,链表&gt;存入到 mWaitingRequests 中。</span></span><br><span class="line"><span class="comment">//如果不存在的话，将&lt;key,null&gt;存入到这 mWaitingRequests</span></span><br><span class="line"><span class="comment">//中，然后给cacheQueue加上请求。也就是：</span></span><br><span class="line">mWaitingRequests.put(cacheKey, <span class="keyword">null</span>);</span><br><span class="line">mCacheQueue.add(request);</span><br></pre></td></tr></table></figure>
<p>思考：为什么含有key时，stagedRequests可能为空，并且如果为空也要新建一个实例后才把&lt;key,链表&gt;插入<br>而没有key时，直接&lt;key,null&gt; 插入？？<br>JAVA基础啊 = = hashmap.remove(key)之后，再用key去get，得到的是null。<br>因为，含有key时，说明有相同请求正在执行（有可能调用了remove(key），所以导致这个key对应的队列为null)（甚至可能还有在等待的相同请求，所以需要先把当前请求用一个<br>LinkedList封装起来，再放到等待队列中，当然了，如果相同key中除了正在执行的，还有在等待的，那么stageRequest不会为空，直接把request放进去就可以了。<br>而没有key的话，这个请求会mCacheQueue.add(request);<br>也就是丢给cache处理，所以它此时正在被处理，那么自然是把&lt;key,null&gt;存到mWaitingRequests中了。</p>
<p>最后finish:</p>
<p>这个finish可能在request的finish中被调用：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (mRequestQueue != <span class="keyword">null</span>) &#123; <span class="comment">// 这是这个reuquest对应的queue</span></span><br><span class="line">	<span class="comment">// 如果请求队列不为空，结束当前请求</span></span><br><span class="line">	<span class="comment">// 让当前请求处于onFinish（）</span></span><br><span class="line">	mRequestQueue.finish(<span class="keyword">this</span>);</span><br><span class="line">	onFinish();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意这个finish是requestQueue的finish，不是request的finish！两者是有区别的。</p>
<p>思考：为什么还有相同key的请求时，把这些所有请求都一下加入到cacheQueue中呢？<br>别人解释：<br>第二步就是判断这个请求有没有要求缓存，如果有（waitingRequests不为null）：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Queue&lt;Request&lt;?&gt;&gt; waitingRequests = mWaitingRequests.remove(cacheKey);</span><br></pre></td></tr></table></figure></p>
<p>注意这个remove(key)，虽然说把key对应的value从map中清理了，但是返回了这个key对应的value（删除前的value）。<br>于是要将mWaitingQueue中相同CacheKey的所有requests放入cacheQueue中，<br>因为前面我们不知道相同CacheKey的那个请求到底在缓存中有没有，如果没有，它需要去网络中获取，那就等到它从网络中获取之后，<strong>放到缓存中后，它结束了，并且已经缓存了（意思就是到这步时，这个key的response已经放到cache中了）</strong>，这个时候，我们就可以保证后面那堆相同CacheKey的请求可以在缓存中去取到数据了，而不需要再去网络中获取了。</p>
<h3 id="②DiskCacheBased-java"><a href="#②DiskCacheBased-java" class="headerlink" title="②DiskCacheBased.java"></a>②DiskCacheBased.java</h3><p>1)inputSteam的三种read:</p>
<p><strong>a.read() : 对流一个字节一个字节读，返回的int就是这个byte的int表示方式。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">InputStream in = Test.class.getResourceAsStream(<span class="string">"/tt.txt"</span>);</span><br><span class="line"><span class="keyword">byte</span>[]tt=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">15</span>];<span class="comment">//测试用的事前知道有15个字节码</span></span><br><span class="line"><span class="keyword">while</span>(in.available()!=<span class="number">0</span>)&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i\&lt;<span class="number">15</span>;i++)&#123; tt[i]=(<span class="keyword">byte</span>)in.read();&#125;</span><br><span class="line">&#125;</span><br><span class="line">String ttttt=<span class="keyword">new</span> String(tt,<span class="string">"utf-8"</span>);</span><br><span class="line">System.out.println(ttttt);</span><br><span class="line">in.close();</span><br></pre></td></tr></table></figure>
<p><strong>b.read(byte[] b):规定一个数组长度，把流中的字节缓冲到数组b中去，返回真实的字节个数</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">in = Test.class.getResourceAsStream(<span class="string">"/tt.txt"</span>);</span><br><span class="line"><span class="keyword">byte</span> [] tt=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">int</span> b;</span><br><span class="line"><span class="keyword">while</span>((b=in.read(tt))!=-<span class="number">1</span>)&#123; System.out.println(b); &#125;</span><br><span class="line">String tzt=<span class="keyword">new</span> String(tt,<span class="string">"utf-8"</span>);</span><br><span class="line">System.out.println(tzt);</span><br></pre></td></tr></table></figure></p>
<p>读取的字节先存到b[0] 再存到b[1]…..</p>
<p><strong>c.read(byte[] b, int off, int len) ：从输入流中读取len个字节到数组b中，off是在数组b中写入数据的偏移。</strong></p>
<p>2.)cache有，cacheHader没有的：<br>byte[] data ; isExpired() ; refreshNeeded()</p>
<p>cache没有，cacheHeader有的：<br>string key</p>
<p>3)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> ；</span></span><br></pre></td></tr></table></figure></p>
<p>把根目录的所有file取到数组中，不为空，则将数组里的file清空。</p>
<p>4）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Entry <span class="title">get</span><span class="params">(String key)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>先通过key取出CacheHeader entry,如果entry不为空，根据key取出根目录中对应的文件。把这个文件转为CountingIS,接着<br>CacheHeader.readHeader（cis);<br>静态类，直接用类名调用函数！！根据cis获取头部数据，并把流cis转为byte[]类型，把byte[]数据通过entry.toCacheEntry(data)存到entry中。</p>
<p>5）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">()</span> ；</span></span><br></pre></td></tr></table></figure></p>
<p>根据根目录下的文件，初始化cache。把文件全部用BIS保存为流，再通过<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CacheHeader entry = CacheHeader.*readHeader*(fis);</span><br></pre></td></tr></table></figure></p>
<p>转化为cacheheader的实例再通过putEntry(entry.key, entry);把他放入mEntries这个cache的MAP集合里面。</p>
<p>6）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">putEntry</span><span class="params">(String key, CacheHeader entry)</span></span></span><br></pre></td></tr></table></figure></p>
<p>把&lt;key,cacheHeader&gt;放到map集合里面</p>
<h3 id="③CacheDispatcher-java"><a href="#③CacheDispatcher-java" class="headerlink" title="③CacheDispatcher.java"></a>③CacheDispatcher.java</h3><p>1)主要成员变量，构造函数需要的四个：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue\&lt;Request\&lt;?\&gt;\&gt; **mCacheQueue**;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue\&lt;Request\&lt;?\&gt;\&gt; **mNetworkQueue**;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Cache **mCache**;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ResponseDelivery **mDelivery**;</span><br></pre></td></tr></table></figure></p>
<p>2）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	mQuit = <span class="keyword">true</span>;</span><br><span class="line">	interrupt();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//停止cache的分发处理，调用thread的interrupt()</span></span><br></pre></td></tr></table></figure></p>
<p>3)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>用request = mCacheQueue.take();取得队列中的请求。</p>
<p>然后有几种情况：<br>a.请求取消了，request.isCanceled()为真，调用r.finish<br>然后此次循环结束，去处理下一个请求。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache.Entry entry = **mCache**.get(request.getCacheKey());</span><br></pre></td></tr></table></figure></p>
<p>b.通过r.getKey取得的key判断mCache中是否有这个entry，没有，交给Network</p>
<p>c.有这个key，但过期了,设置这个request的cacheEntry为entry ，并且交给net，结束循环</p>
<p>d.有key，且cache没过期，把entry里的数据解析了赋值给response</p>
<p>e.如果entry不需要更新，把response用deliver发送回去</p>
<p>f.要更新(Soft-expired cache hit)，response.intermediate = true;<br>意味着这个未更新的响应发回后，还有第二个更新过的响应要发回去。<br>由于还需要更新后的响应，所以这个请求还是要交给net。</p>
<h3 id="④HttpStack"><a href="#④HttpStack" class="headerlink" title="④HttpStack"></a>④HttpStack</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HttpStack</span> </span>&#123; <span class="keyword">public</span> HttpResponse performRequest ....&#125;</span><br></pre></td></tr></table></figure>
<p>这个接口被HurlStack.java实现了。</p>
<p><strong>HurlStack.java</strong></p>
<p>1)三个构造函数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">**<span class="keyword">public</span>** HurlStack(UrlRewriter urlRewriter, SSLSocketFactory sslSocketFactory)</span><br></pre></td></tr></table></figure>
<p>参数列表可为空。</p>
<p><strong>2）重写接口中唯一的一个方法（重要，用Httpurlconnection进行请求，并处理响应的函数）</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> HttpResponse <span class="title">performRequest</span><span class="params">(Request&lt;?&gt; request, Map&lt;String,</span></span></span><br><span class="line"><span class="function"><span class="params">String&gt; additionalHeaders)</span></span></span><br><span class="line"><span class="function">先使用</span></span><br><span class="line"><span class="function">HashMap&lt;String, String&gt; map </span>= <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">map.putAll(request.getHeaders());</span><br><span class="line">map.putAll(additionalHeaders);</span><br><span class="line">把请求头部的&lt;headerName,对应内容&gt;存到一个map中。</span><br><span class="line">用</span><br><span class="line">String url = request.getUrl();取得url，然后mUrlRewriter.rewriteUrl(url);取得一个新的url（没找到这个函数的实现...</span><br><span class="line">然后创建一个新的httpurlconnection, 遍历map，把所有的header加入conn的porperty中。</span><br><span class="line"></span><br><span class="line">然后：</span><br><span class="line"><span class="comment">//给conn设置请求的方法</span></span><br><span class="line">setConnectionParametersForRequest(connection, request);</span><br><span class="line">接着从这步开始都是处理响应了：</span><br><span class="line"><span class="comment">// 调用了getResponseCode()就会自动connect，不用明文调用.connect</span></span><br><span class="line"><span class="keyword">int</span> responseCode = connection.getResponseCode();</span><br></pre></td></tr></table></figure></p>
<p>首先判断响应码是不是符合要求，如果符合要求：<br>a.用函数C将connection得到的响应转化为实体</p>
<p>b.通过connection.getHeaderFields()，得到所有的响应头列表，foreach遍历这个结合，把每一条通过key单独取出来，做成header，加入到response的headers集合中。</p>
<p>2）<br><strong>C</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> HttpEntity <span class="title">entityFromConnection</span><span class="params">(HttpURLConnection</span></span></span><br><span class="line"><span class="function"><span class="params">connection)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>根据connection返回的信息，建立实体。</p>
<p>实体主要包括四个信息：content,contentLength,contentEncoding,contentType</p>
<p>使用volley时，新建一个queue（请求队列）,再将多个request放入queue中，之后发送queue</p>
<p>这时候处理queue的线程是异步，queue中也有调度，保证若干个request异步处理</p>
<p><strong>④BasickNetwork.java（实现了netWork的接口</strong><br><strong>缓存与重试策略的重点！！</strong><br><strong>原来上次看到这儿就停止了= = 难怪没有看到重试策略</strong><br><strong>而这个重要的函数，就是接口函数中的重写！</strong><br><strong>先复习一下有关缓存的这些变量：</strong></p>
<p><strong>1.request:</strong></p>
<ul>
<li>Cache-Control: max-age=0 以秒为单位</li>
<li>If-Modified-Since: Mon, 19 Nov 2012 08:38:01 GMT 缓存文件的最后修改时间。</li>
<li>If-None-Match: “0693f67a67cc1:0” 缓存文件的Etag值</li>
<li>Cache-Control: no-cache 不使用缓存</li>
<li>Pragma: no-cache 不使用缓存</li>
</ul>
<p><strong>2.response:</strong></p>
<ul>
<li>Cache-Control: public 响应被缓存，并且在多用户间共享</li>
<li>Cache-Control: private 响应只能作为私有缓存，不能在用户之间共享</li>
<li>Cache-Control:no-cache 提醒浏览器要从服务器提取文档进行验证</li>
<li>Cache-Control:no-store 绝对禁止缓存（用于机密，敏感文件）</li>
<li>Cache-Control: max-age=60 60秒之后缓存过期（相对时间）</li>
<li>Date: Mon, 19 Nov 2012 08:39:00 GMT 当前response发送的时间</li>
<li>Expires: Mon, 19 Nov 2012 08:40:01 GMT 缓存过期的时间（绝对时间）</li>
<li>Last-Modified: Mon, 19 Nov 2012 08:38:01 GMT 服务器端文件的最后修改时间</li>
<li>ETag: “20b1add7ec1cd1:0”<br>服务器端文件的Etag值，客户端收到后再次请求时用if-none-match返回，如<br>果etag状态没变，则返回状态304然后不返回</li>
</ul>
<p>x-cache-lookup项指专门查看代理服务器中<strong>是否有</strong>某个网页缓存。有就返回HIT,没有返回MISS。而x-cache项指浏览器从何处、是在哪个代理缓存载入的网页文件。服务器名后的3128指服务器端口。<br>X-Cache :HIT from proxy.domain.tld, MISS from proxy.local<br>X-Cache: 表示你的 http request 是由 proxy server 回的 .</p>
<p>MISS 表 proxy无资料,代理动作, HIT 表 proxy 直接回应</p>
<p><strong>1）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> NetworkResponse <span class="title">performRequest</span><span class="params">(Request\&lt;?\&gt; request)</span> **<span class="keyword">throws</span>**</span></span><br><span class="line"><span class="function">VolleyError </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>方法是执行网络请求的方法，那么理所当然的要进行请求重试也是在这里进行。如何进行请求重试，注意在<strong>方法的内部是用while(true)括起来的</strong>，也就是说如果该方法正常执行完毕或者抛出异常时，必然就跳出循环了，但是如果<strong>请求失败没有return并且在catch内也没有超过重试策略限定条件时</strong>，必然会while(true)下重新请求一次，这样就达到了重试的目的。</p>
<p><strong>这个函数比较长，分为几部分来说：</strong></p>
<p><strong>a.</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Gather headers.</span></span><br><span class="line"></span><br><span class="line">Map&lt;String, String&gt; headers = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向headers这个集合中添加cache entry</span></span><br><span class="line">addCacheHeaders(headers, request.getCacheEntry());---&gt;B</span><br><span class="line"></span><br><span class="line"><span class="comment">// mHttpStack (httpStack接口，有hurlStack类实现）</span></span><br><span class="line"><span class="comment">// 真正进行httpurlconnection 连接和处理 响应的地方，发送了连接请求，并且进行了响应的处理（主要是响应头的处理）</span></span><br><span class="line"></span><br><span class="line">httpResponse = mHttpStack.performRequest(request, headers);</span><br><span class="line">StatusLine statusLine = httpResponse.getStatusLine();</span><br><span class="line"><span class="keyword">int</span> statusCode = statusLine.getStatusCode(); <span class="comment">// 得到响应码</span></span><br><span class="line">responseHeaders = convertHeaders(httpResponse.getAllHeaders());</span><br></pre></td></tr></table></figure></p>
<p>然后通过statusCode判断是否缓存：<br>a.如果是304，那么就是not_modified：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 尝试获得request的entry</span></span><br><span class="line">Entry entry = request.getCacheEntry();</span><br></pre></td></tr></table></figure></p>
<p>如果entry为空，就用networkResponse根据之前的响应头构建响应并返回。<br>否则，就把刚才得到的响应头存到entry的响应头中，然后用新响应头构建响应并返回。</p>
<p>b.如果是301（永久搬迁）或者302（暂时搬迁）<br>那么需要重定向,request根据返回的重定向地址进行设置重定向url<br>String newUrl = responseHeaders.get(“Location”);<br>request.setRedirectUrl(newUrl);</p>
<p>c.可能没有响应体：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">responseContents = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>];</span><br><span class="line"><span class="comment">//有的话转为bytes:</span></span><br><span class="line"><span class="comment">//这里面就用到了bytespool了，似乎加快了内存的利用？但是也导致了无法存储太多东西？？</span></span><br><span class="line">responseContents = entityToBytes(httpResponse.getEntity());---&gt;D</span><br></pre></td></tr></table></figure></p>
<p>d.还可以打印请求花费的时间：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// requestLifetime 代表这个请求已经消耗的时间，可以用Log打印出来。*</span></span><br><span class="line"><span class="keyword">long</span> requestLifetime = SystemClock.elapsedRealtime() - requestStart;</span><br><span class="line">logSlowRequests(requestLifetime, request, responseContents, statusLine);</span><br></pre></td></tr></table></figure></p>
<p>e.如果状态码小于200超过299，直接抛出异常。</p>
<p>最后就是到return了，如果没有continue,异常等的抛出，就可以返回通过network得到的响应了。</p>
<p>3)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">D.<span class="keyword">private</span> <span class="keyword">byte</span>[] entityToBytes(HttpEntity entity) <span class="keyword">throws</span> IOException,</span><br><span class="line">ServerError &#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>终于用到了bytespool。<br>首先构造实体长度的一个bytearrayoutputStream: <strong>mPool就是这个basicNetwork的全局变量，byte池。</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">PoolingByteArrayOutputStream bytes = <span class="keyword">new</span> PoolingByteArrayOutputStream(mPool, (<span class="keyword">int</span>) entity.getContentLength());</span><br><span class="line"><span class="keyword">byte</span>[] buffer = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	InputStream in = entity.getContent();</span><br><span class="line">	<span class="keyword">if</span> (in == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> ServerError();</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//以下，从pool里面遍历mBuffersBySize，</span></span><br><span class="line"><span class="comment">//找到还有多余1024容量的bytes[],从这个数组中取走1024长度的内存，在pool的这个bytes[]中记得把取走的容量减去</span></span><br><span class="line">buffer = mPool.getBuf(<span class="number">1024</span>); ----&gt; byteArrayPool的函数</span><br><span class="line"><span class="keyword">int</span> count;</span><br><span class="line"><span class="comment">// 把inputstream的内容读到buffer中，又把buffer的内容写到函数开始创建的 流bytes中</span></span><br><span class="line"><span class="keyword">while</span> ((count = in.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">	bytes.write(buffer, <span class="number">0</span>, count);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> bytes.toByteArray();</span><br></pre></td></tr></table></figure></p>
<p>2）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">B.</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addCacheHeaders</span><span class="params">(Map&lt;String, String&gt; headers, Cache.Entry entry)</span> </span>&#123;</span><br><span class="line"><span class="comment">// If there's no cache entry, we're done.</span></span><br><span class="line"><span class="keyword">if</span> (entry == <span class="keyword">null</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (entry.etag != <span class="keyword">null</span>) &#123;</span><br><span class="line">	headers.put(<span class="string">"If-None-Match"</span>, entry.etag);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (entry.lastModified &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">// 原来这个地方是entry.serverDate，现在已经改过来了...</span></span><br><span class="line">	Date refTime = <span class="keyword">new</span> Date(entry.lastModified);</span><br><span class="line">		headers.put(<span class="string">"If-Modified-Since"</span>, DateUtils.formatDate(refTime));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>大神解释：<br>Date代表了响应产生的时间，正常情况下Date时间在Last-Modified时间之后,即Date比较晚，也就是Date&gt;=Last-Modified。<br>通过以上原理，既然Date&gt;=Last-Modified。那么我利用Date构建，也是完全正确的。<br>可能的问题出在服务端的 Http 实现上，如果服务端完全遵守 Http语义，采用时间比较的方式来验证If-Modified-Since，判断服务器资源文件修改时间是不是在If-Modified-Since之后。那么使用Date完全正确。<br>我：比如服务端LastModified在8点，Date时间在8点5秒，而客户端传来的If-Modified-Since是在7点，很明显无论如何I-M-S肯定小于L-M和Date,使用服务端的Date来和我们自己的request Entry的L-M-S比较也没关系。<br>可是有的服务端实现不是比较时间，而是直接的判断服务器资源文件修改时间，是否和If-Modified-Since所传时间相等。这样使用Date就不能实现正确的再验证，因为Date的时间总不会和服务器资源文件修改时间相等。<br>我：可以比较相等是因为客户端接收到这次资源的I-M-S等于服务端的L-M。所以如果服务端资源不变，那么L-M不变，还是等于客户端那边的I-M-S</p>
<h3 id="⑤-ExecutorDelivery-java-实现了-ResponseDelivery-，用于把response传送出去"><a href="#⑤-ExecutorDelivery-java-实现了-ResponseDelivery-，用于把response传送出去" class="headerlink" title="⑤ ExecutorDelivery.java 实现了 ResponseDelivery ，用于把response传送出去"></a>⑤ ExecutorDelivery.java 实现了 ResponseDelivery ，用于把response传送出去</h3><p>有一个Excutor成员。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Executor mResponsePoster;</span><br></pre></td></tr></table></figure></p>
<p>1）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ExecutorDelivery</span><span class="params">(<span class="keyword">final</span> Handler handler)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// Make an Executor that just wraps the handler.</span></span><br><span class="line">	mResponsePoster = <span class="keyword">new</span> Executor() &#123;</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">			handler.post(command);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>2）对于接口的重要实现（重要方法，在cache和net调度线程里用来传送响应的<br>最终其实是用excutor执行runnble:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postResponse</span><span class="params">(Request&lt;?&gt; request, Response&lt;?&gt; response)</span> </span>&#123; </span><br><span class="line">	postResponse(request, response, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postResponse</span><span class="params">(Request&lt;?&gt; request, Response&lt;?&gt; response,Runnable runnable)</span> </span>&#123;</span><br><span class="line">	request.markDelivered();</span><br><span class="line">	request.addMarker(<span class="string">"post-response"</span>);</span><br><span class="line">	mResponsePoster.execute(<span class="keyword">new</span> ResponseDeliveryRunnable(request, response, runnable));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> ResponseDeliveryRunnable(request, response, runnable)</span><br></pre></td></tr></table></figure>
<p>很明显是一个runnble，Excutor接口的execute函数在这个类的构造函数<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ExecutorDelivery</span><span class="params">(<span class="keyword">final</span> Handler handler)</span> </span>&#123;&#125;中实现。</span><br></pre></td></tr></table></figure></p>
<h3 id="⑥PoolingByteArrayOutputStream"><a href="#⑥PoolingByteArrayOutputStream" class="headerlink" title="⑥PoolingByteArrayOutputStream"></a>⑥PoolingByteArrayOutputStream</h3><p>继承自ByteArrayOutputStream 。不表。</p>
<h3 id="⑦btyeArrayPool"><a href="#⑦btyeArrayPool" class="headerlink" title="⑦btyeArrayPool"></a>⑦btyeArrayPool</h3><p>byte[]的缓存池，主要就是为了提高用户频繁进行数据请求时的性能，如果用户频繁进行数据请求，对象在很快的时间内创建又被丢弃，明显降低了性能，这里提供了一个一直存在的缓存池，提高了获取堆内存的性能。</p>
<p>两个集合：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> List&lt;<span class="keyword">byte</span>[]&gt; mBuffersByLastUse = <span class="keyword">new</span> LinkedList &lt;<span class="keyword">byte</span>[]&gt;();</span><br><span class="line"><span class="keyword">private</span> List&lt;<span class="keyword">byte</span>[]&gt; mBuffersBySize = <span class="keyword">new</span> ArrayList&lt;<span class="keyword">byte</span>[]&gt;(<span class="number">64</span>);</span><br></pre></td></tr></table></figure></p>
<p>第一个是按照使用顺序存储的byte[]集合，第二个是按照大小存储的byte[]集合。<br>需要用到byte[]时，从这个pool里面取，用完了又归还，提高了性能。</p>
<p>关于优缺点：<br>问题一、为什么不适合下载大文件，只适合数据量小的频繁请求？<br>1）存储时，从btyeArrayPool中取出一块已经分配的内存，这样不用每次都进行内存分配，而是先查找缓冲池中有没有合适的内存区域，有的话可以直接使用，减少了内存分配的次数。<br>如果数据量过大，byteArrayPool这个存储空间就会溢出。</p>
<p>2）线程池大小默认为4，如果上传数据大或者下载数据大，浪费比较长的时间，占用了线程，其余请求就会阻塞。</p>
<p>问题二、缓存机制（BasicNetwork.java)<br>只使用了Date来进行缓存验证（原来是这样，现在改了）<br>在BasicNetwork.java中：</p>
<h3 id="⑧-HttpHeaderParser-java"><a href="#⑧-HttpHeaderParser-java" class="headerlink" title="⑧ HttpHeaderParser.java"></a>⑧ HttpHeaderParser.java</h3><p><strong>(你亲自读过的呀… 注意重点是复习…复习，理解！！ ）</strong><br><strong>通过解析服务器返回的响应头部，构建保存的缓存请求的头部（ Cache.Entry）</strong>，比如<br>解析http头部的方法，有三个。</p>
<p>1）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Cache.<span class="function">Entry <span class="title">parseCacheHeaders</span><span class="params">(NetworkResponse response)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>首先，“DATE”，</strong>用parseDateAsEpoch（）把时间解析成EPOCH格式，响应生成时间。于是得到serverDate。</p>
<p><strong>第二，”Cache-Control”：</strong>有这个值，意味着hasCacheControl = true;，那么判断完头部，还要去设置<br>softExpire和finalExpire这两个值。</p>
<p>a.如果是no-cache或者no-store，就不缓存结果。前者是要从服务器提取文档进行验证。后者是绝对禁止缓存，用于机密文件2333</p>
<p>b.max-age开头：得到max-age。相对时间，多少秒之后过期。<br>比如max-age = 60，那么60秒之后缓存过期。</p>
<p>c.stale-while-revalidate 开头：得到stale-while-revalidate.RFC文档解释：<br>When present in an HTTP response, the stale-while-revalidate Cache- Control<br>extension indicates that caches MAY serve the response in which it appears after<br>it becomes stale, up to the indicated number of seconds.<br>也就是说，到达给定的时间后，服务器可能会返回新的内容。（也就是这个时间过后这个响应就陈旧了，所以会发新的过来）</p>
<p>d.如果是must-revalidate, 作用与no-cache相同，但更严格，强制意味更明显。但这只是理论上的描述。或者是proxy-revalidate，都是强制刷新。<br>于是mustRevalidate = true;</p>
<p><strong>第三，“Expires”，</strong>用parseDateAsEpoch（）把的时间解析成EPOCH格式。于是得到serverExpires。<strong>缓存过期的绝对时间，</strong>所以要取缓存时用到的isExpired()函数是这样写的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果缓存过期，返回true</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isExpired</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.ttl &lt; System.currentTimeMillis();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>第四，“Last-Modified“，</strong>用parseDateAsEpoch（）把的时间解析成EPOCH格式。于是得到lastModified。（<strong>客户端用if-not-modified返回</strong>，如果服务端文件在这个时间之后都没修改，那么返回304）</p>
<p><strong>第五，”ETag”，</strong>得到serverEtag（如果客户端用if-none-match加上etag的内容发回，服务端etag没变的话，返回状态304，内容不更新）</p>
<p>然后要看有没有cachecontrol的控制：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Cache-Control takes precedence over an Expires header, even if both exist and Expires is more restrictive.过期时间， Cache-Control比Expires优先级高。*/</span></span><br><span class="line"><span class="keyword">if</span> (hasCacheControl) &#123;</span><br><span class="line">	softExpire = now + maxAge * <span class="number">1000</span>; <span class="comment">//新鲜度时间，maxAge是秒为单位，但是开发时是毫秒为单位</span></span><br><span class="line">	finalExpire = mustRevalidate ? softExpire : softExpire + staleWhileRevalidate * <span class="number">1000</span>; <span class="comment">// 过期时间</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (serverDate &gt; <span class="number">0</span> &amp;&amp; serverExpires &gt;= serverDate) &#123;</span><br><span class="line">	<span class="comment">//没有cacheControl</span></span><br><span class="line">	<span class="comment">//Default semantic for Expire header in HTTP specification is softExpire.</span></span><br><span class="line">	softExpire = now + (serverExpires - serverDate); </span><br><span class="line">	<span class="comment">//现在时间+过期的绝对时间-生成文件的时间，因为serverExpires - serverDate代表从发送时的时间到过期时间还有多少时间T，这段时间过后就是过期了。</span></span><br><span class="line">	<span class="comment">//这是软过期时间，意味着从接受到响应开始（now),一定还可以保存T那么长的时间。</span></span><br><span class="line">	finalExpire = softExpire;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 各个值终于算好了，全部赋值给cache.entry，这样就用entry保存了这个request对应的cache</span></span><br></pre></td></tr></table></figure>
<p>印象最深的地方：</p>
<p>1）接口的使用很厉害(读到最后才明白这个妙处）<br>比如新建一个requsertQueue的时候，cache和network在volley.java的newRequestQueue里面是一定要有的，通常来说 ResponseDelivery delivery这个参数是可以不自己定义的，那么它就是这个值：</p>
<p>A.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">RequestQueue</span><span class="params">(Cache cache, Network network, <span class="keyword">int</span> threadPoolSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(cache, network, threadPoolSize,</span><br><span class="line">            <span class="keyword">new</span> ExecutorDelivery(<span class="keyword">new</span> Handler(Looper.getMainLooper())));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>将ExcutorDelivery和UI线程的handler绑定起来，</p>
<p>所以在ExDel的构造函数中，实现了Excutror接口中的函数excute，这个函数就是调用主线程的handler去处理Runn.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ExecutorDelivery</span><span class="params">(<span class="keyword">final</span> Handler handler)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Make an Executor that just wraps the handler.</span></span><br><span class="line">    <span class="comment">// 新建实例的时候重写接口方法，但是也是要.excute才会运行的...不是说实例建了就开始运行...</span></span><br><span class="line">    mResponsePoster = <span class="keyword">new</span> Executor() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">            handler.post(command);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当然了，这只是构造函数中，那么这个excute何时被调用呢….？？我们读到response的时候就会解开谜底。去到B！</p>
<p>这个ExcutorDel本身也是 接口的实现！！重载了这个函数：</p>
<p>可以看到，runnble经过了一点改造，在</p>
<p>private class ResponseDeliveryRunnable implements Runnable {}<br>中，除了本身的runnalbe要被run外，还有增加了：</p>
<p>C.<br>对runnable进行了一点改造，用来<strong>在request的类的delResponse函数中调用我们的回调接口！</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (mResponse.isSuccess()) &#123;</span><br><span class="line">	mRequest.deliverResponse(mResponse.result);</span><br></pre></td></tr></table></figure></p>
<p>有了这一句，才会在<strong>各个xxxRequest类中，重载request类的deliverResponse函数</strong>，onResponse是什么呢。。。就是调用了我们自己设置的onResponse函数，这样就可以干我们想做的事了….所以其实最后的response的回调显示也是在各个request中完成的。</p>
<p>在每个xxxRequest中都重写了这个函数：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">deliverResponse</span><span class="params">(String response)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mListener != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mListener.onResponse(response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>B.在A中（Request的时候）构造好了，最终postResponse的时候才会用。比如在networdDispatch这个线程中，终于从网络取到了线程，<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mDelivery.postResponse(request, response);</span><br></pre></td></tr></table></figure></p>
<p>这个mDelivery就是每个request的response的传送者~<br>mDelivery 是一个ResponseDelivery，而我们刚才提到的ExcutorDelivery是这个抽象类的实现。<br>所以mDelivery.postResponse其实是调用了ExcutorDelivery里面的postResponse.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postResponse</span><span class="params">(Request&lt;?&gt; request, Response&lt;?&gt; response, Runnable runnable)</span> </span>&#123;</span><br><span class="line">    request.markDelivered();</span><br><span class="line">    request.addMarker(<span class="string">"post-response"</span>);</span><br><span class="line">    mResponsePoster.execute(<span class="keyword">new</span> ResponseDeliveryRunnable(request, response, runnable));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而这个postResponse做了什么呢？它终于，调用了ExcutorDelivery。构造函数里面的Excutor接口实现的excute函数，刚才我们分析得知，这个excute会把传入的runnable用handler去执行里面的run（），而这个runnable其实被暗自改造了~~我们刚才刚才分析过了。</p>
<p>在cacheDispatcher这个线程的run中，得到response后，结果就是通过postResponse返回去的！这个设计真的很精妙= =！！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mDelivery.postResponse(request, response, <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mNetworkQueue.put(finalRequest);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="comment">// Not much we can do about this.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>还有就是各个xxxRequest，除了传入url外，实现了response类中的两个回调接口<br>Listener<t> 和ErrorListener，request和response的结合，一开始就想好了最后 - -很巧妙啊。（其实刚才哪一篇叙述已经讲到了）</t></p>
<p>重试机制：<br>volley的重试策略是在request构造函数里面确定的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Request</span><span class="params">(<span class="keyword">int</span> method, String url, Response.ErrorListener listener)</span> </span>&#123;</span><br><span class="line">    mMethod = method;</span><br><span class="line">    mUrl = url;</span><br><span class="line">    mIdentifier = createIdentifier(method, url);</span><br><span class="line">    mErrorListener = listener;</span><br><span class="line">    setRetryPolicy(<span class="keyword">new</span> DefaultRetryPolicy());</span><br><span class="line">    mDefaultTrafficStatsTag = findDefaultTrafficStatsTag(url);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>首先new出来的东西是一个DefaultRetryPolicy：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultRetryPolicy</span> <span class="keyword">implements</span> <span class="title">RetryPolicy</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个类有什么呢，它其实不是执行重试操作，只是更新有关重试的两个变量。</p>
<p>成员变量：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The current timeout in milliseconds. 当前超时时间 </span></span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">int</span> mCurrentTimeoutMs;  </span><br><span class="line"></span><br><span class="line">      <span class="comment">// The current retry count. 当前重试次数  </span></span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">int</span> mCurrentRetryCount;  </span><br><span class="line"></span><br><span class="line">      <span class="comment">// The maximum number of attempts. 最大重试次数 </span></span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> mMaxNumRetries;  </span><br><span class="line"></span><br><span class="line">      <span class="comment">// The backoff multiplier for for the policy. 表示每次重试之前的 timeout 该乘以的因子，每重试一次，超时时间就变化一次</span></span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">float</span> mBackoffMultiplier;  </span><br><span class="line"></span><br><span class="line">      <span class="comment">// The default socket timeout in milliseconds 默认超时时间</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_TIMEOUT_MS = <span class="number">5000</span>;  </span><br><span class="line"></span><br><span class="line">      <span class="comment">// The default number of retries  默认最大重试次数</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_MAX_RETRIES = <span class="number">1</span>;</span><br></pre></td></tr></table></figure></p>
<p>除此之外只有两个函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">更新当前请求重试次数，并且更新当前超时时间</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">retry</span><span class="params">(VolleyError error)</span> <span class="keyword">throws</span> VolleyError </span>&#123;</span><br><span class="line">	mCurrentRetryCount++;</span><br><span class="line">	mCurrentTimeoutMs += (**mCurrentTimeoutMs * mBackoffMultiplier);</span><br><span class="line">	<span class="keyword">if</span> (!hasAttemptRemaining()) &#123;</span><br><span class="line">		<span class="keyword">throw</span> error;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而以下函数是判断当前重试次数是否超过最大请求数：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">hasAttemptRemaining</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> mCurrentRetryCount &lt;= mMaxNumRetries;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>set函数里，只是设置了重试策略：mRetryPolicy = 构造的这个retryPolicy对象。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/06/Android四大组件----Activity（1）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ke Yu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coco">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/06/Android四大组件----Activity（1）/" itemprop="url">Activity(1)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-09-06T14:09:30+08:00">
                2017-09-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Android四大组件—-Activity（1）"><a href="#Android四大组件—-Activity（1）" class="headerlink" title="Android四大组件—-Activity（1）"></a>Android四大组件—-Activity（1）</h1><ul>
<li><p><a href="#Android四大组件----Activity（1）-简介">简介</a></p>
<ul>
<li><a href="#Android四大组件----Activity（1）-Activity的主要作">Activity的主要作用</a></li>
</ul>
</li>
<li><p><a href="#Android四大组件----Activity（1）-通信方式（待续）">通信方式（待续）</a></p>
</li>
<li><p><a href="#Android四大组件----Activity（1）-关联处理">关联处理</a></p>
<ul>
<li><p><a href="#Android四大组件----Activity（1）-关联起作用的两种情况">关联起作用的两种情况</a></p>
<ul>
<li><p><a href="#Android四大组件----Activity（1）-启动Activity的I">启动Activity的Intent包含FLAG_ACTIVITY_NEW_TASK</a></p>
</li>
<li><p><a href="#Android四大组件----Activity（1）-Activity的all">Activity的allowTaskReparenting属性被设置为”true”</a></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><a href="#Android四大组件----Activity（1）-加载方式">加载方式</a></p>
<ul>
<li><p><a href="#Android四大组件----Activity（1）-使用清单文件">使用清单文件</a></p>
<ul>
<li><p><a href="#Android四大组件----Activity（1）-singleTop">singleTop</a></p>
</li>
<li><p><a href="#Android四大组件----Activity（1）-singleTask">singleTask</a></p>
</li>
<li><p><a href="#Android四大组件----Activity（1）-singleInstan">singleInstance</a></p>
</li>
<li><p><a href="#Android四大组件----Activity（1）-singleTop和si">singleTop和singleTask的区别</a></p>
</li>
</ul>
</li>
<li><p><a href="#Android四大组件----Activity（1）-使用intentFlag">使用intent Flag</a></p>
<ul>
<li><p><a href="#Android四大组件----Activity（1）-FLAG_ACTIVIT">FLAG_ACTIVITY_NEW_TASK</a></p>
</li>
<li><p><a href="#Android四大组件----Activity（1）-FLAG_ACTIVIT">FLAG_ACTIVITY_SINGLE_TOP</a></p>
</li>
<li><p><a href="#Android四大组件----Activity（1）-FLAG_ACTIVIT">FLAG_ACTIVITY_CLEAR_TOP</a></p>
</li>
<li><p><a href="#Android四大组件----Activity（1）-SINGLE_TOP和C">SINGLE_TOP和CLEART_TOP的配合使用</a></p>
<ul>
<li><p><a href="#Android四大组件----Activity（1）-为什么？">为什么？</a></p>
</li>
<li><p><a href="#Android四大组件----Activity（1）-可能出现的Bug">可能出现的Bug</a></p>
</li>
</ul>
</li>
<li><p><a href="#Android四大组件----Activity（1）-NEW_TASK和CLE">NEW_TASK和CLEART_TOP的配合使用</a></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><a href="#Android四大组件----Activity（1）-Lifecycle">Lifecycle</a></p>
<ul>
<li><p><a href="#Android四大组件----Activity（1）-生命状态">生命状态</a></p>
</li>
<li><p><a href="#Android四大组件----Activity（1）-LifeTime">LifeTime</a></p>
</li>
<li><p><a href="#Android四大组件----Activity（1）-生命周期方法">生命周期方法</a></p>
</li>
</ul>
</li>
<li><p><a href="#Android四大组件----Activity（1）-状态保存与恢复">状态保存与恢复</a></p>
<ul>
<li><p><a href="#Android四大组件----Activity（1）-onSaveInstan">onSaveInstanceState()</a></p>
</li>
<li><p><a href="#Android四大组件----Activity（1）-onRestoreIns">onRestoreInstanceState()或onCreate()</a></p>
</li>
</ul>
</li>
<li><p><a href="#Android四大组件----Activity（1）-参考资料">参考资料</a></p>
</li>
</ul>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><h4 id="Activity的主要作用"><a href="#Activity的主要作用" class="headerlink" title="Activity的主要作用"></a>Activity的主要作用</h4><ul>
<li><p>显示UI</p>
</li>
<li><p>和用户进行交互，对用户的操作进行监听并响应</p>
</li>
</ul>
<h3 id="通信方式（待续）"><a href="#通信方式（待续）" class="headerlink" title="通信方式（待续）"></a>通信方式（待续）</h3><p>1.Activity之间的通信</p>
<p>2.Activity和Service之间的通信</p>
<p>3.Activity和Fragment之间的通信</p>
<h3 id="关联处理"><a href="#关联处理" class="headerlink" title="关联处理"></a>关联处理</h3><p>关联代表Activity属于哪个Task，默认情况下，同一个应用中的所有Activities属于一个Task，但是可以通过<activity>元素的taskAffinity属性修改任何给定Activity的关联任务。</activity></p>
<p>该属性值必须不同于<manifest>元素中默认的软件包名。</manifest></p>
<h4 id="关联起作用的两种情况"><a href="#关联起作用的两种情况" class="headerlink" title="关联起作用的两种情况"></a>关联起作用的两种情况</h4><h5 id="启动Activity的Intent包含FLAG-ACTIVITY-NEW-TASK"><a href="#启动Activity的Intent包含FLAG-ACTIVITY-NEW-TASK" class="headerlink" title="启动Activity的Intent包含FLAG_ACTIVITY_NEW_TASK"></a>启动Activity的Intent包含FLAG_ACTIVITY_NEW_TASK</h5><ul>
<li><p>默认情况下，存在此FLAG时，Activity通常会被放入新的Task中，但如果使用了taskAffinity将它与现有Task关联，Activity会在现有Task中启动，否则会开始新的Task（singleTask的实验证明了不会有新的Task，这里待定）。</p>
</li>
<li><p>如果使用此FLAG使得Activity开始新任务，当用户按“home”按钮离开时，必须为用户提供回到任务的方式。比如通知管理器所启动的Activity都是在别的Task中。</p>
</li>
</ul>
<h5 id="Activity的allowTaskReparenting属性被设置为”true”"><a href="#Activity的allowTaskReparenting属性被设置为”true”" class="headerlink" title="Activity的allowTaskReparenting属性被设置为”true”"></a>Activity的allowTaskReparenting属性被设置为”true”</h5><ul>
<li><p>Activity可以从它当前所在的Task移动到与其具有关联的任务。</p>
</li>
<li><p>比如一个天气预报Activity，它默认与旅行应用关联。如果不是这个应用的其他某个Activity启动了这个天气预报，之后旅行应用又启动了这个天气预报，那么天气预报Activity会被重新分配到旅行应用的Task。疑问：这样的意义何在？？</p>
</li>
</ul>
<h3 id="加载方式"><a href="#加载方式" class="headerlink" title="加载方式"></a>加载方式</h3><p>当Activity A用设置intent flag的方式定义了Activity<br>B应当如何和任务关联，而Activity B又在清单中设置了launchMode，那么Activity A的设置优先级高于B的设置。也就是Intent flag的优先级大于launchMode</p>
<h4 id="使用清单文件"><a href="#使用清单文件" class="headerlink" title="使用清单文件"></a>使用清单文件</h4><p>共有四种，主要是控制Activity的创建模式。</p>
<p><strong>standard</strong></p>
<ul>
<li><p>如果intent来自同一个应用，且Activity没指定taskAffinity，那么生成Activity的新实例放在发出启动请求的Activity所在的Task顶端。</p>
</li>
<li><p>如果intent来自其他应用，那么会生成这个Activity的新实例，并以这个Activity为根创建一个新的Task</p>
</li>
</ul>
<blockquote>
<p>  使用场景：</p>
</blockquote>
<ul>
<li><p>大多数撰写邮件或者发布社交网络状态的Activity。此时每个Activity实例服务于一个intent。比如从别的应用分享内容给微信朋友，跳到了那个选择联系人的list，这个页面很可能符合这种场景。</p>
<p>可能出现的Bug：</p>
</li>
<li><p>使用ApplicationContext去启动standard模式的Activity会出现报错<br>因为standard模式的Activity会默认进入启动它的Activity所属的任务栈中，但是非Activity类型的Context没有所谓的任务栈。（why，因为任务栈是对于Activity来说的呀，而不是Application)<br>solution：使用FLAG_ACTIVITY_NEW_TASK启动Activity，启动的时候Activity就会进入新的Task。</p>
</li>
</ul>
<h5 id="singleTop"><a href="#singleTop" class="headerlink" title="singleTop"></a>singleTop</h5><ul>
<li><p>如果intent来自同一个应用，视栈顶是否有它的实例而定。如果已经有实例在栈顶了(发起启动的和已经启动的Task中），就不产生新实例，会通过<br>onNewIntent()把intent发送给现有的实例；如果有实例但不位于栈顶，就再创建新的实例并放入栈顶(实例可能重复）</p>
</li>
<li><p>如果intent来自其他应用，那么会生成这个Activity的新实例，并以这个Activity为根创建一个新的Task。  </p>
<p>使用场景：</p>
</li>
<li><p>新闻类或者阅读类App的内容页面。在读新闻的时候，来了个该新闻APP的消息通知，点击这个通知就会打开新闻APP，由于此时这个App实例位于栈顶，那么此时就直接调用onNewintent()，无需产生新的实例</p>
</li>
<li><p>搜索功能的页面。在带有搜索功能的页面中，如果每次搜索都生成新的Activity，那么我们想回到最初搜索前的页面，就需要按很多次Back，但如果使用singleTop模式，每次搜索时，把intent发送给现有的Activity，更新搜索结果即可，只需要一次Back就可以回到搜索前的页面。</p>
</li>
</ul>
<h5 id="singleTask"><a href="#singleTask" class="headerlink" title="singleTask"></a>singleTask</h5><ul>
<li>如果intent来自同一个应用，如果栈中<strong>存在这个Activity的实例</strong>就会复用这个Activity，不管它是否位于栈顶，复用时，会将它上面的Activity全部出栈，并且将intent发送给该实例的onNewIntent()方法；如果当前栈没有这个实例，就新建一个，并且放在栈顶。（官方文档说是创建新Task并且以他为根，实验证明这种说法不完全正确）。</li>
</ul>
<blockquote>
<p>  疑问：当前栈没有实例以及别的栈也没有实例，究竟是否一样结果？是新建后放栈顶，还是以实例为根创建Task？待实验证明。</p>
</blockquote>
<blockquote>
<p>  实验：</p>
</blockquote>
<blockquote>
<p>  1）同一个应用下，两个Stack，我们的应用在Stack#1，其中已经有一个Task，<strong>没有设置taskAffinity</strong>，所有栈中都没有要找的Act。从.mainActivity跳转到另一个模式为singleTask的TestAct中，利用adb命令可以看到，Act新建后放到当前Task顶端。没有以实例为根创建新的Task。</p>
</blockquote>
<blockquote>
<p>  2）同一个应用下，两个Stack，我们的应用在Stack#1，其中已经有一个Task，<strong>设置了TestAct的taskAffinity</strong>，所有栈中都没有要找的Act。通过adb命令可以看到，在当前Stack中新建了一个Task，也就是以新建的Activity为根创建了Task。</p>
</blockquote>
<blockquote>
<p>  猜想：</p>
</blockquote>
<blockquote>
<p>  如果设置了taskAffinity，当前Task没有实例，就找它想要的Task，查找是否有与这个Activity相同taskAffinity的Task已经存在。如果不存在，创建实例时以这个Activity为根创建一个新的Task，这个新的实例就在这个Task中，以后每次调动都不会产生新的实例；如果存在Task，就再看是否有实例从而决定是复用还是新建。</p>
</blockquote>
<blockquote>
<p>  但如果没有设置taskAffinity这个属性，它默认和当前应用处于一个Task，所以直接查找发出intent的当前Task，如果找不到就直接在当前Task顶端新建实例。</p>
</blockquote>
<blockquote>
<p>  注意的是，<strong>虽然系统创建了一个新的Task，但是只要按下返回键还是会回到原来的Activity</strong>。</p>
</blockquote>
<ul>
<li><p>如果intent来自别的应用，无论哪个Task存在这个Activity的实例都会复用这个Activity，不管它是否位于栈顶，复用时，会将它上面的Activity全部出栈，并且将intent发送给该实例的onNewIntent()方法；如果系统中（当前栈和别的Task）都没有这个Activity的实例，那么就创建新实例并以它为根创建新的Task。</p>
<p>  使用场景：</p>
</li>
<li><p>浏览器的主界面。不管从多少个应用启动浏览器，只会启动主界面一次，其余情况都会走onNewIntent()，同时会清空主界面上面的其他页面。</p>
</li>
<li><p>邮件客户端的收件箱。不管从哪个应用进入收件箱，都会结束客户端中别的页面，进入到收件箱页面。</p>
</li>
</ul>
<h5 id="singleInstance"><a href="#singleInstance" class="headerlink" title="singleInstance"></a>singleInstance</h5><ul>
<li><p>和singleTask类似，不但要创建一个新的Task，而且该Task中只能有这个实例。其效果相当于多个应用共享一个应用，不管谁激活该Activity 都会进入同一个应用中。</p>
<p>  使用场景：</p>
</li>
<li><p>几乎不使用这种模式，除非是100%确定这个应用只有一个Activity。</p>
</li>
<li><p>闹铃提醒，将闹铃提醒与闹铃设置分离。此时要保证这个应用只有闹铃提醒这个Act。</p>
</li>
</ul>
<h5 id="singleTop和singleTask的区别"><a href="#singleTop和singleTask的区别" class="headerlink" title="singleTop和singleTask的区别"></a>singleTop和singleTask的区别</h5><p>当已经存在要启动的Activity时</p>
<ul>
<li><p>如果它在栈顶，那么都会把intent发送给onNewIntent()。</p>
</li>
<li><p>如果它不在栈顶，singleTop会在栈顶新建实例，而singleTask会把这个Activity上面的实例弹出，再发送intent给栈顶的这个Activity。<br><strong><em>也就是说，singleTop会造成重复的实例</em></strong>。</p>
</li>
</ul>
<h4 id="使用intent-Flag"><a href="#使用intent-Flag" class="headerlink" title="使用intent Flag"></a>使用intent Flag</h4><h5 id="FLAG-ACTIVITY-NEW-TASK"><a href="#FLAG-ACTIVITY-NEW-TASK" class="headerlink" title="FLAG_ACTIVITY_NEW_TASK"></a>FLAG_ACTIVITY_NEW_TASK</h5><p>与singleTask有相同行为。</p>
<h5 id="FLAG-ACTIVITY-SINGLE-TOP"><a href="#FLAG-ACTIVITY-SINGLE-TOP" class="headerlink" title="FLAG_ACTIVITY_SINGLE_TOP"></a>FLAG_ACTIVITY_SINGLE_TOP</h5><p>与singleTop有相同行为。</p>
<h5 id="FLAG-ACTIVITY-CLEAR-TOP"><a href="#FLAG-ACTIVITY-CLEAR-TOP" class="headerlink" title="FLAG_ACTIVITY_CLEAR_TOP"></a>FLAG_ACTIVITY_CLEAR_TOP</h5><p>如果已经有了Activity实例，那么就会销毁Task中当前Activity之上的所有Activity，然后把intent发送给已经位于Task顶端的Act实例的onNewIntent()。</p>
<h5 id="SINGLE-TOP和CLEART-TOP的配合使用"><a href="#SINGLE-TOP和CLEART-TOP的配合使用" class="headerlink" title="SINGLE_TOP和CLEART_TOP的配合使用"></a>SINGLE_TOP和CLEART_TOP的配合使用</h5><h6 id="为什么？"><a href="#为什么？" class="headerlink" title="为什么？"></a>为什么？</h6><pre><code>如果要启动的Activity为”standard&quot;：
</code></pre><ul>
<li><p>只使用CLEAR_TOP，想要启动的Activity已存在时，该实例<strong>以及</strong>它上面的Activity会被销毁，然后创建新实例(onCreate())</p>
</li>
<li><p>配合SINGLE_UP使用<strong>或者</strong>要启动的Activity为<strong>“standard”之外</strong>的模式，想要启动的Activity已存在时，该实例不会被销毁，只有它上面的实例会被销毁，然后调用onNewIntent()</p>
</li>
<li><p>详情：</p>
</li>
</ul>
<p><a href="https://stackoverflow.com/questions/31926315/why-do-people-like-to-pair-clear-top-and-single-top-in-android" target="_blank" rel="noopener">https://stackoverflow.com/questions/31926315/why-do-people-like-to-pair-clear-top-and-single-top-in-android</a><br><a href="https://developer.android.com/reference/android/content/Intent.html#FLAG_ACTIVITY_CLEAR_TOP" target="_blank" rel="noopener">https://developer.android.com/reference/android/content/Intent.html#FLAG_ACTIVITY_CLEAR_TOP</a></p>
<h6 id="可能出现的Bug"><a href="#可能出现的Bug" class="headerlink" title="可能出现的Bug"></a>可能出现的Bug</h6><p>问题：<a href="https://stackoverflow.com/questions/5489592/single-top-clear-top-seem-to-work-95-of-the-time-why-the-5" target="_blank" rel="noopener">https://stackoverflow.com/questions/5489592/single-top-clear-top-seem-to-work-95-of-the-time-why-the-5</a></p>
<p>有人回答道这涉及到并发问题，如果CLEAR_UP和SINGLE_TOP被同时读取，CLEAR_UP会调用onCreate()，SINGLE_UPC此时也没有找到Act，也调用onCreate()，造成一个Activity同时创建两次。</p>
<p>存疑：逻辑或 | ，运算优先级为从左到右，会发生同时读取两个条件的情况吗？</p>
<p>猜想：此时intent进行setFlags，不是简单的立刻进行false/true的判断，而是需要使用这两个参数，所以可能在启动过程中，对参数进行读取，然后根据参数进行相应的操作。结合对启动过程的了解，答案应该还是在ActivityStack.startActivityUncheckedLocked中。</p>
<h5 id="NEW-TASK和CLEART-TOP的配合使用"><a href="#NEW-TASK和CLEART-TOP的配合使用" class="headerlink" title="NEW_TASK和CLEART_TOP的配合使用"></a>NEW_TASK和CLEART_TOP的配合使用</h5><ul>
<li>如果在一个Task的根Act中使用这个FLAGS,可以找到当前Task中运行的Activity实例并使它在前台运行，并且清除这个根Act和需要的Activity之外的其余实例。</li>
</ul>
<h3 id="Lifecycle"><a href="#Lifecycle" class="headerlink" title="Lifecycle"></a>Lifecycle</h3><h4 id="生命状态"><a href="#生命状态" class="headerlink" title="生命状态"></a>生命状态</h4><ul>
<li><p>活动（running）状态：当Activity处于可见，位于屏幕前台，获得焦点，正在和用户进行交互时为活动状态，此时它位于任务栈的最顶端。</p>
</li>
<li><p>暂停状态：Activity半可见或者透明时（比如出现了toast、alertdialog等时），它没有焦点，无法和用户进行交互，此时活动仍是存活的，它保留着所有的状态和成员信息。系统内存资源不够时可能被杀死。</p>
</li>
<li><p>停止状态：完全不可见时为停止状态，但仍保持所有的状态和成员信息。随时可能会被系统杀死。</p>
</li>
<li><p>非活动状态：Activity处于暂停或停止状态，Activity被手动终止，或者被系统回收资源时,可以称为非活动状态。</p>
</li>
</ul>
<h4 id="LifeTime"><a href="#LifeTime" class="headerlink" title="LifeTime"></a>LifeTime</h4><ul>
<li>entiere lifetime：调用onCreate()到相应的调用onDestroy()</li>
</ul>
<ul>
<li>visible lifetime: 调用onStart()到相应的调用onStop()</li>
</ul>
<ul>
<li>foreground lifetime：调用onResume()到相应的调用onPause()</li>
</ul>
<h4 id="生命周期方法"><a href="#生命周期方法" class="headerlink" title="生命周期方法"></a><strong>生命周期方法</strong></h4><p><strong>      以下六个方法从外向内两两对应：</strong></p>
<ul>
<li><p>onCreate（）：活动第一次启动时会首先调用该方法</p>
</li>
<li><p>onStart（）：有一个参数，可能为null， 或者是onSaveInstanceState()<br>保存的状态信息。<br>启动后或者当活动从停止状态转到活动状态时会调用该方法。onStart（）是activity界面被显示出来的时候执行的，用户可见，包括有一个activity在他上面，但没有将它完全覆盖，用户可以看到部分activity但不能与它交互。</p>
</li>
<li><p>onResume（）：活动和用户进行交互时会调用该方法，当从pause状态转为活动状态时回调该方法，是当该activity与用户能进行交互时被执行，用户可以获得activity的焦点，能够与用户交互。</p>
</li>
<li><p>onPause（）：一个活动在前台运行时，别的活动需要前台运行，这时该活动会保存当前状态信息，活动变为暂停状态</p>
</li>
<li><p>onStop（）：活动不需要展示给用户时触发该方法，活动变为停止状态</p>
</li>
<li><p>onDestroy（）：活动停止时调用该方法</p>
</li>
</ul>
<ul>
<li>onRestart（）：活动从停止状态转为活动状态时调用该方法</li>
</ul>
<p>onStart()和onResume()区别：</p>
<ul>
<li><p>onStart()通常就是onStop()（也就是用户按下了home键，activity变为后台后），之后用户再切换回这个Activity就会调用onRestart()而后调用onStart()</p>
</li>
<li><p>onResume()是onPause()（通常是当前的Activity被暂停了，比如被另一个透明或者Dialog样式的Activity覆盖了），之后dialog取消，activity回到可交互状态，调用onResume()。</p>
</li>
</ul>
<h3 id="状态保存与恢复"><a href="#状态保存与恢复" class="headerlink" title="状态保存与恢复"></a>状态保存与恢复</h3><p>Activity遇到意外被关闭时，需要对一些状态如文本输入、ListView位置进行记录</p>
<h4 id="onSaveInstanceState"><a href="#onSaveInstanceState" class="headerlink" title="onSaveInstanceState()"></a>onSaveInstanceState()</h4><pre><code>1）在回调onStop()之前调用

2）与onPause()的调用顺序不一定
</code></pre><p>  3）只有当Activity可能会重建时，比如系统资源不足或者配置改变导致Activity关闭时，才会调用该函数</p>
<h4 id="onRestoreInstanceState-或onCreate"><a href="#onRestoreInstanceState-或onCreate" class="headerlink" title="onRestoreInstanceState()或onCreate()"></a>onRestoreInstanceState()或onCreate()</h4><pre><code>1）onRestoreInstanceState()在回调onStart()之后调用，此时Bundle一定不为null

2）回调onCreate()时Bundle可能为null，所以需要进行判断
</code></pre><p> 3）根据两者差异，如果需要根据Activity是第一次创建还是重建进行不同的初始化操作，可以使用onCreate()</p>
<p> 4）官方文档建议使用onRestoreInstanceState()，有利于继承这个Activity的子类决定是否使用父类的状态恢复实现</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://inthecheesefactory.com/blog/understand-android-activity-launchmode/en" target="_blank" rel="noopener">https://inthecheesefactory.com/blog/understand-android-activity-launchmode/en</a></p>
<p><a href="https://developer.android.com/reference/android/app/Activity.html" target="_blank" rel="noopener">https://developer.android.com/reference/android/app/Activity.html</a></p>
<p><a href="https://developer.android.com/guide/components/tasks-and-back-stack.html?hl=zh-cn" target="_blank" rel="noopener">https://developer.android.com/guide/components/tasks-and-back-stack.html?hl=zh-cn</a></p>
<p><a href="https://stackoverflow.com/questions/4342761/how-do-you-use-intent-flag-activity-clear-top-to-clear-the-activity-stack" target="_blank" rel="noopener">https://stackoverflow.com/questions/4342761/how-do-you-use-intent-flag-activity-clear-top-to-clear-the-activity-stack</a></p>
<p><a href="https://stackoverflow.com/questions/12683779/are-oncreate-and-onrestoreinstancestate-mutually-exclusive" target="_blank" rel="noopener">https://stackoverflow.com/questions/12683779/are-oncreate-and-onrestoreinstancestate-mutually-exclusive</a></p>
<p><a href="https://developer.android.com/reference/android/app/Activity.html#onSaveInstanceState(android.os.Bundle)" target="_blank" rel="noopener">https://developer.android.com/reference/android/app/Activity.html#onSaveInstanceState(android.os.Bundle)</a></p>
<p><a href="https://developer.android.com/reference/android/app/Activity.html#onRestoreInstanceState(android.os.Bundle)" target="_blank" rel="noopener">https://developer.android.com/reference/android/app/Activity.html#onRestoreInstanceState(android.os.Bundle)</a></p>
<p><a href="https://www.reddit.com/r/androiddev/comments/2afx13/onrestoreinstancestate_vs_oncreate/" target="_blank" rel="noopener">https://www.reddit.com/r/androiddev/comments/2afx13/onrestoreinstancestate_vs_oncreate/</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/04/List的删除/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ke Yu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coco">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/04/List的删除/" itemprop="url">List遍历要注意的坑</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-09-04T11:23:11+08:00">
                2017-09-04
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>List的删除测试：</p>
<p>主要函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">	List&lt;String&gt; myList = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">	myList.add(<span class="string">"a"</span>);</span><br><span class="line">	myList.add(<span class="string">"b"</span>);</span><br><span class="line">	myList.add(<span class="string">"c"</span>);</span><br><span class="line">	myList.add(<span class="string">"d"</span>);</span><br><span class="line">	myList.add(<span class="string">"e"</span>);</span><br><span class="line">	test1(myList,<span class="string">"d"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(List&lt;String&gt; list)</span></span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(String e : list)&#123;</span><br><span class="line">			System.out.println(e);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h3 id="首先是根据下标遍历："><a href="#首先是根据下标遍历：" class="headerlink" title="首先是根据下标遍历："></a><strong>首先是根据下标遍历：</strong></h3><h4 id="Test1："><a href="#Test1：" class="headerlink" title="Test1："></a>Test1：</h4><p>很明显，事先的size在remove发生后会改变，所以出现了溢出。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// size遍历，删除指定下标。TEST1</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">(List&lt;String&gt; list, String key)</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> size = list.size();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i)&#123;</span><br><span class="line">			String tmp = list.get(i);</span><br><span class="line">			<span class="keyword">if</span>(tmp.equals(key))&#123;</span><br><span class="line">				list.remove(key);<span class="comment">// 用list.remove(i)也是一样结果</span></span><br><span class="line">				System.out.println(<span class="string">"After removing, length is "</span> + list.size());</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		show(list);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p><img src="http://ovwunej09.bkt.clouddn.com/listR01.png" alt="result test1"></p>
<h4 id="TEST2："><a href="#TEST2：" class="headerlink" title="TEST2："></a>TEST2：</h4><p>当每个元素都不同时，可以正确删除，一开始看还以为是对的…但是当出现重复元素时，只能删除其中一个元素。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">	List&lt;String&gt; myList = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">	myList.add(<span class="string">"a"</span>);</span><br><span class="line">	myList.add(<span class="string">"b"</span>);</span><br><span class="line">	myList.add(<span class="string">"c"</span>);</span><br><span class="line">	myList.add(<span class="string">"c"</span>);</span><br><span class="line">	myList.add(<span class="string">"d"</span>);</span><br><span class="line">	myList.add(<span class="string">"e"</span>);</span><br><span class="line">	test2(myList,<span class="string">"c"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// size不固定，和i比较时再取.TEST2</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">(List&lt;String&gt; list, String key)</span></span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); ++i)&#123;</span><br><span class="line">			String tmp = list.get(i);</span><br><span class="line">			<span class="keyword">if</span>(tmp.equals(key))&#123;</span><br><span class="line">				list.remove(key);<span class="comment">// 用list.remove(i)也是一样结果</span></span><br><span class="line">				System.out.println(<span class="string">"After removing, length is "</span> + list.size());</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		show(list);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p><img src="http://ovwunej09.bkt.clouddn.com/listR03.png" alt="clipboard.png"></p>
<p>因为执行remove时，将被删除的元素之后的元素全部往前移动一位，那么原来的size-1位置就为null了，最后把size–就可以了。比如i==2出现了删除，i==3的元素和2一样，但是它去了2位置，这时就扫描不到它了。</p>
<h4 id="TEST3："><a href="#TEST3：" class="headerlink" title="TEST3："></a>TEST3：</h4><p>那么可能会想到，既然是被删除之后的元素往前面移动，那么我们可以试试从后遍历~！这样后面的元素往前移动也没有关系，因为他们已经被扫描过了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// size不固定，和i比较时再取.从后往前遍历.TEST3</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">(List&lt;String&gt; list, String key)</span></span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = list.size()-<span class="number">1</span>; i &gt;=<span class="number">0</span> ; --i)&#123;</span><br><span class="line">			String tmp = list.get(i);</span><br><span class="line">			<span class="keyword">if</span>(tmp.equals(key))&#123;</span><br><span class="line">				list.remove(key);<span class="comment">// 用list.remove(i)也是一样结果</span></span><br><span class="line">				System.out.println(<span class="string">"After removing, length is "</span> + list.size());</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		show(list);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p><img src="http://ovwunej09.bkt.clouddn.com/listR04.png" alt="result test3"></p>
<p>成功了~！！！<br>先固定size的方法，一旦发生remove肯定会导致size改变，肯定行不通，不再测试。</p>
<h3 id="for-each遍历"><a href="#for-each遍历" class="headerlink" title="for each遍历"></a><strong>for each遍历</strong></h3><h4 id="TEST4："><a href="#TEST4：" class="headerlink" title="TEST4："></a>TEST4：</h4><p>for each遍历，有相同就直接删除：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// for each.遍历CowList，删除list。TEST4</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">(List&lt;String&gt; list, String key)</span></span>&#123;</span><br><span class="line">			<span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span>(String tmp:list)&#123;</span><br><span class="line">				<span class="keyword">if</span>(tmp.equals(key))&#123;</span><br><span class="line">					System.out.println(count + <span class="string">" is current index"</span>);</span><br><span class="line">					list.remove(key);<span class="comment">// 用list.remove(i)也是一样结果</span></span><br><span class="line">					System.out.println(<span class="string">"After removing, length is "</span> + list.size());</span><br><span class="line">				&#125;</span><br><span class="line">				count++;</span><br><span class="line">			&#125;</span><br><span class="line">			show(list);</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
<p><img src="http://ovwunej09.bkt.clouddn.com/listR05.png" alt="clipboard.png"></p>
<p>这个错误，研究过modCount就能明白，迭代器发生了错误。</p>
<p>在remove的时候modCount–，但是迭代器的expectedModcount是最开始遍历前的modcount，modCount值不是期望值，就抛出了异常。</p>
<p>这个fail-fast迭代是为了保证线程安全的，put这些操作也会用到。</p>
<h4 id="TEST5："><a href="#TEST5：" class="headerlink" title="TEST5："></a>TEST5：</h4><p>那么foreach怎么修改才能成功删除呢…最开始想的时候没想出来，有的人说remove后就break也是厉害了….不管重复元素了吗?</p>
<p>看到一种方法是把List复制为COWArrayList，写时复制，也就是remove完才把结果存入COWlist…但这样实际上操作的是COWAraayList而不是原本的List，感觉也不太可取。</p>
<p><strong>但是，假设遍历COWArrayList，但是操作原本的List呢？？</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// for each.遍历CowList，删除list。TEST5</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">(List&lt;String&gt; list, String key)</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">		CopyOnWriteArrayList&lt;String&gt; cowList = <span class="keyword">new</span> CopyOnWriteArrayList&lt;String&gt;(list);</span><br><span class="line">		<span class="keyword">for</span>(String tmp:cowList)&#123;</span><br><span class="line">			<span class="keyword">if</span>(tmp.equals(key))&#123;</span><br><span class="line">				System.out.println(count + <span class="string">" is current index"</span>);</span><br><span class="line">				list.remove(key);<span class="comment">// 用list.remove(i)也是一样结果</span></span><br><span class="line">				System.out.println(<span class="string">"After removing, length is "</span> + list.size());</span><br><span class="line">			&#125;</span><br><span class="line">			count++;</span><br><span class="line">		&#125;</span><br><span class="line">		show(list);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p><strong>我有点惊呆…居然成功了- -</strong></p>
<p><img src="http://ovwunej09.bkt.clouddn.com/listR06.png" alt="clipboard.png"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/03/二分查找/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ke Yu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coco">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/03/二分查找/" itemprop="url">二分查找和一些扩展</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-09-03T15:23:18+08:00">
                2017-09-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><h4 id="1）顺序查找"><a href="#1）顺序查找" class="headerlink" title="1）顺序查找"></a>1）顺序查找</h4><p><strong>在n个元素的表上直接用key进行比较。</strong><br><strong>只适用于较短的表。</strong></p>
<ul>
<li>最好情况：1次比较</li>
<li>最坏情况：n次比较</li>
<li>平均情况：(1+2+3+…+n)/n = （n+1)/2</li>
</ul>
<h4 id="2）二分查找"><a href="#2）二分查找" class="headerlink" title="2）二分查找"></a>2）二分查找</h4><p><strong>将target与表中央的key进行比较。然后向左或向右二分此表。</strong><br><strong>适用于有序表。</strong></p>
<p>List的insert和replace操作对有序表不适用，如果想要通过List派生出有序表，要对这两个方法进行重载。<br>bottom=0,top=size-1<br>mid = (bottom+top)/2=(size-1)/2;<br>由于终止条件的不同，可以有几种二分：<br><img src="http://ovwunej09.bkt.clouddn.com/search02.jpg" alt="48151C421AD4433B84D5ADCDC78B1AC5.jpg"></p>
<h5 id="查找算法："><a href="#查找算法：" class="headerlink" title="查找算法："></a>查找算法：</h5><p><strong>①无论有没有找到target，都一直对表进行二分，直到剩下的表长为1；</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(bottom &lt; top) then 继续递归 <span class="comment">// 表中元素大于1</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(top &lt; bottom) then 不存在target </span><br><span class="line"><span class="keyword">else</span> then    <span class="comment">//top==bottom   相等判断在这个位置</span></span><br><span class="line">如果data等于target  then 找到target</span><br></pre></td></tr></table></figure>
<h5 id="递归条件："><a href="#递归条件：" class="headerlink" title="递归条件："></a>递归条件：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(data&lt;target) <span class="function">then <span class="title">return</span> <span class="params">(mid+<span class="number">1</span>,top)</span></span></span><br><span class="line"><span class="function"><span class="keyword">else</span> then <span class="title">return</span> <span class="params">(bottom,mid)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>此时表的分割如下：</li>
</ul>
<p><img src="http://ovwunej09.bkt.clouddn.com/search03.jpg" alt="D74F53DC1BCF45CB8B8C9CE2CEDD1CD7.jpg"></p>
<p>如果表中的目标出现超过一次，当中间的表长为1并且命中目标时，<strong>可以保证它是第一个出现的目标。</strong><br>每次查找终止于一个树叶，可能成功可能不成功。<br>外部路径长度：从根到树中每个树叶各遍历一次所经过的分支数的综合。</p>
<ul>
<li>查找n个元素的表：</li>
</ul>
<p><img src="http://ovwunej09.bkt.clouddn.com/search04.jpg" alt="45DBF761E7064BC2960FF114DC06699C.jpg"></p>
<p><strong>(成功查找和不成功查找的次数一样的）</strong></p>
<ul>
<li>最坏情况：lgn+1</li>
<li>平均情况：lgn</li>
</ul>
<p><strong>②进行相等识别。</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(bottom &lt;= top) then 继续递归 <span class="comment">// 表中元素大于1</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(top &lt; bottom) then 不存在target </span><br><span class="line"><span class="keyword">else</span> then    <span class="comment">//top==bottom</span></span><br><span class="line"> <span class="comment">//如果data等于target  then 找到target</span></span><br></pre></td></tr></table></figure>
<h5 id="递归条件：-1"><a href="#递归条件：-1" class="headerlink" title="递归条件："></a>递归条件：</h5><p>可加上相等判断<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(data==target) position=mid; <span class="comment">//相等判断在这里</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(data &lt; target) then <span class="keyword">return</span> (mid+<span class="number">1</span>,top)</span><br><span class="line"><span class="keyword">else</span> then <span class="keyword">return</span> (bottom,mid<span class="number">-1</span>)</span><br></pre></td></tr></table></figure></p>
<ul>
<li>此时表的分割如下：</li>
</ul>
<p><img src="http://ovwunej09.bkt.clouddn.com/search02.jpg" alt="clipboard.png"></p>
<p>如果表中的目标出现超过一次，会返回目标中的任一实例。<br>树叶都是不成功查找，所以外部路径长度就是不成功的比较次数。</p>
<p>成功查找：<br>内部路径长度：根到所有非树叶上的分支数上的和。<br>所有树叶都是不成功查找，n+1个树叶即n+1个不成功结果n+1约等于2\^h (h是树高）,<br>h约等于lg(n+1)，在此方法中，</p>
<p>每个内部定点执行2次比较，<strong>所以不成功查找的比较次数为2lg(n+1)</strong></p>
<p><strong>成功查找： (       ( (n+1)lg(n+1)-2n ) / 2 + 1     ) *2 - 1 = 2(n+1)/n *<br>lg(n+1) -3 </strong></p>
<ul>
<li>两种比较</li>
</ul>
<p><img src="http://ovwunej09.bkt.clouddn.com/search04.jpg" alt="clipboard.png"></p>
<h4 id="二分查找的应用-lower-bound"><a href="#二分查找的应用-lower-bound" class="headerlink" title="二分查找的应用(lower_bound"></a>二分查找的应用(lower_bound</h4><p>第一个大于等于target和upper_bound第一个大于target):<br>1)方法①得到的就是lower_bound那个数。<br><strong>但注意pos的位置：右序列中记录第一个数位置（bottom)</strong><br><strong>左序列中记录最后一个数位置（top)</strong></p>
<h4 id="递归条件：-2"><a href="#递归条件：-2" class="headerlink" title="递归条件："></a>递归条件：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(data &lt; target) <span class="function">then <span class="title">return</span> <span class="params">(mid+<span class="number">1</span>,top)</span></span></span><br><span class="line"><span class="function"><span class="keyword">else</span> then <span class="title">return</span> <span class="params">(bottom,mid)</span></span></span><br></pre></td></tr></table></figure>
<p><strong>2)方法①中递归条件做一点修改：</strong></p>
<h4 id="递归条件：-3"><a href="#递归条件：-3" class="headerlink" title="递归条件："></a>递归条件：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(data &gt; target) <span class="function">then <span class="title">return</span> <span class="params">(bottom, mid)</span></span></span><br><span class="line"><span class="function"><span class="keyword">else</span> then <span class="title">return</span> <span class="params">(mid+<span class="number">1</span>, top)</span></span></span><br><span class="line"><span class="function"><span class="comment">// pos的位置和1）中一样</span></span></span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/18/okhttp3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ke Yu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coco">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/18/okhttp3/" itemprop="url">okhttp3源码解析(1)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-08-18T23:13:25+08:00">
                2017-08-18
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>okhttp是<strong>高性能的http库</strong>，支持同步、异步，而且<strong>实现了spdy、http2、websocket协议</strong>，api很简洁易用，和volley一样实现了http协议的缓存。picasso就是利用okhttp的缓存机制实现其文件缓存，实现的很优雅，很<strong>正确，</strong>反例就是UIL（universal image loader），自己做的文件缓存，而且不遵守http缓存机制。</p>
<h4 id="协议介绍"><a href="#协议介绍" class="headerlink" title="协议介绍"></a>协议介绍</h4><h5 id="SPDY"><a href="#SPDY" class="headerlink" title="SPDY"></a>SPDY</h5><p>用以最小化网络延迟，提升网络速度，优化用户的网络使用体验。是对HTTP协议的增强。<br>a.复用连接，可在一个TCP连接上传送多个资源。应对了TCP慢启动的特性。降低了延迟的同时提高了宽带利用率。<br>b.请求分优先级，为了避免关键请求被阻塞，可以设置优先级，重要的资源优先传送。<br>c.HTTP头部数据也被压缩，省流量。<br>d.服务器端可主动连接客户端来推送资源（Server Push）。<br>e.基于HTTPS的加密协议传输</p>
<p><strong>HTTP2.0 支持明文HTTP传输，SPDY强制使用HTTPS协议。</strong><br><strong>HTTP2.0消息头的压缩算法采用HPACK，而非SPDY采用的DEFLATE</strong></p>
<h5 id="HTTP2-0"><a href="#HTTP2-0" class="headerlink" title="HTTP2.0"></a>HTTP2.0</h5><p>a.新的二进制格式，只使用0和1，增加了代码的健壮性。文本协议的表现形式有很多，所以要考虑很多使用场景。<br>b.复用连接<br>c.header压缩<br>d.服务端推送</p>
<h5 id="Websocket"><a href="#Websocket" class="headerlink" title="Websocket"></a>Websocket</h5><p>Websocket借用了HTTP的协议来完成一部分握手，<br>a.通讯过程建立在一次连接上，只需要一次HTTP握手，避免了HTTP的非状态性。连接建立后，双方都可以发送/响应消息，不需要像HTTP那样等待响应。<br>b.服务器有消息时就主动发送信息给客户端</p>
<h4 id="源码解读"><a href="#源码解读" class="headerlink" title="源码解读"></a>源码解读</h4><p>第一步<br>client.newCall(request).execute() ，链式调用，第一个调用返回了一个realCall对象，然后realCall实例调用属于它的方法execute()—-&gt;BEGIN</p>
<p>A.而 dispatcher的executed(RealCall call)其实是：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">executed</span><span class="params">(RealCall call)</span> </span>&#123;</span><br><span class="line">	runningSyncCalls.add(call);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>runningSyncCalls是一个deque,它把这个call加入了队列。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Running synchronous calls. Includes canceled calls that haven't finished yet. */</span></span><br><span class="line"><span class="comment">// 执行同步调用的队列，包括取消的但还没有执行的call</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Deque&lt;RealCall&gt; runningSyncCalls = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br></pre></td></tr></table></figure></p>
<h5 id="①RealCall-java"><a href="#①RealCall-java" class="headerlink" title="①RealCall.java"></a><strong>①RealCall.java</strong></h5><p>实现了Call的接口。<br>1）call是一次准备执行的请求，realCall是一次请求和一次响应的paris，不能执行两次。<br>2）Response#body可以获得响应体，为了避免内存泄漏需要close这个reseponse<br>3）传输层成功（收到响应码，响应头，响应体），不代表应用层成功。依然可能有404,或者500这些坑爹的响应码。<br>4）cancellation, a connectivity problem or timeout会造成IOE的抛出，<br>5）请求已经执行时，抛出IllegalStateException</p>
<p>BEGIN.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Response <span class="title">execute</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	<span class="comment">//做的最重要的事情是：</span></span></span><br><span class="line"><span class="function">	<span class="keyword">try</span> </span>&#123;</span><br><span class="line">		client.dispatcher().executed(<span class="keyword">this</span>); --&gt;A</span><br><span class="line">		Response result = getResponseWithInterceptorChain(); --&gt;B</span><br><span class="line">		<span class="keyword">if</span> (result == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Canceled"</span>);</span><br><span class="line">			<span class="keyword">return</span> result;</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			client.dispatcher().finished(**<span class="keyword">this</span>**);</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure></p>
<p>B.getResponseWithInterceptorChain();在Recall的这个函数中，主要是添加了一系列拦截器到一个链表interceptors中，添加过后，初始化RealInterceptorChain，执行RealInterceptorChain的proceed方法：</p>
<p>这个构造函数，传入的streamAllocation,httpCode,conn都是null<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Interceptor.Chain chain = <span class="keyword">new</span> RealInterceptorChain(</span><br><span class="line">	interceptors, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="number">0</span>, originalRequest);</span><br><span class="line">		<span class="keyword">return</span> chain.proceed(originalRequest); ---&gt;C</span><br></pre></td></tr></table></figure></p>
<h5 id="②Interceptor接口中还有Chain接口"><a href="#②Interceptor接口中还有Chain接口" class="headerlink" title="②Interceptor接口中还有Chain接口"></a>②Interceptor接口中还有Chain接口</h5><p>Chain接口由http/<strong>RealInterceptorChain.java</strong>来实现（找半天…）</p>
<p><strong>C.两个proceed函数，可以只传request。最终归于以下这个函数</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Response <span class="title">proceed</span><span class="params">(Request request, StreamAllocation streamAllocation,HttpCodec httpCodec,RealConnection connection)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">/*</span></span></span><br><span class="line"><span class="function"><span class="comment">在这里面，各种判断流是否只调用了一次proceed，等等（其实没看懂..)</span></span></span><br><span class="line"><span class="function"><span class="comment">多次判断了this.httpCodec != null，只有ConnectInterceptor执行完后就不为null了,所以这是对connectInterceptor之后的拦截器进行了判断。在ConnectInterceptor之后的拦截器必须满足：request的url要一致，interceptor必须执行一次proceed()。这样子做是为了保证递推的正常运作。该函数里面的calls++,由于proceed（）是interceptor的intercept里面调用的，所以对于每个interceptor其实calls不能大于1。*/</span></span></span><br><span class="line"><span class="function"><span class="comment">// 最重要的是：</span></span></span><br><span class="line"><span class="function"><span class="comment">// Call the next interceptor in the chain.</span></span></span><br><span class="line"><span class="function"><span class="comment">// 创建一个新的拦截链</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">RealInterceptorChain next </span>= <span class="keyword">new</span> RealInterceptorChain(</span><br><span class="line">interceptors, streamAllocation, httpCodec, connection, index + <span class="number">1</span>, request);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从list中取出第index个拦截器</span></span><br><span class="line"><span class="comment">// 执行这个连接器的intercept方法。</span></span><br><span class="line">Interceptor interceptor = interceptors.get(index);</span><br><span class="line">Response response = interceptor.intercept(next); ---&gt;D</span><br></pre></td></tr></table></figure></p>
<p>由于拦截器有多种，所以根据不同的拦截器，会调用不同的intercept方法。</p>
<h5 id="③RealConnection-JAVA"><a href="#③RealConnection-JAVA" class="headerlink" title="③RealConnection.JAVA"></a><strong>③RealConnection.JAVA</strong></h5><p>继承了Http2Connection.Listener，实现了Connection接口.<br>客户端和服务端之间的连接抽象为了realConnection，为了管理这些连接的复用设计了connectionPool,共享address的请求可以复用连接。<br>这个类管理一次连接，在里面用socket进行连接处理，以及handshake处理握手。<br>其实是真正的建立socket连接的地方。</p>
<p><strong>M.</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEligible</span><span class="params">(Address address, Route route)</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure></p>
<p>该函数主要是判断这个链接是否能匹配这个address以及这个route。要经过三次判断：</p>
<ul>
<li>一是这个链接是否接受新的流或者它接受的流的size是不是满了；</li>
<li>二是调用Internal.instance.equalsNonHost比较路线的address和传入的address除了host部分是否相同；</li>
<li>三是只调用address.url().host().equals(this.route().address().url().host()看主机名是否匹配…</li>
</ul>
<p><strong>有点奇怪= =为什么二和三不一起比较呢？？迷…</strong></p>
<p><strong>N</strong>.<br>public void connect(…）{}<strong>中主要是根据路由是否需要隧道而判断调用connectTunnel(）还是connectSocket()；</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (route.requiresTunnel()) &#123;</span><br><span class="line">	connectTunnel(connectTimeout, readTimeout, writeTimeout);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">*<span class="comment">//否则直接使用socket连接*</span></span><br><span class="line">	connectSocket(connectTimeout, readTimeout);</span><br><span class="line">&#125;</span><br><span class="line">establishProtocol(connectionSpecSelector);</span><br></pre></td></tr></table></figure>
<p>//通过代理服务器，来做https请求的连接(http1.1的https以及http2)需要建立隧道连接，而其它的连接则不需要建立隧道连接。假设不需要隧道链接，直接使用socket链接：<br>对于private void connectSocket(int connectTimeout, int readTimeout) throws IOException {}</p>
<ul>
<li>首先根据路由取得代理和的address，然后根据代理类型使用工厂创建无参数的socket或者直接用new创建有代理的socket,再用这个socket进行connect：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Platform.get().connectSocket(rawSocket, route.socketAddress(),</span><br><span class="line">connectTimeout);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>其中Platform.get()是用于判断平台是在Android 还是 OpenJDK 9+.还是 OpenJDK 7 or OpenJDK 8 等等。这里我们去Android的平台调用 —&gt;O</p>
<p>服务端的信息存储在路由的socketAdress中。然后用okio封装rawsocket的输入和输出流。<br>socket连接结束后，调用establishProtocol(connectionSpecSelector); —&gt;P</p>
<p>P.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">establishProtocol</span><span class="params">(ConnectionSpecSelector</span></span></span><br><span class="line"><span class="function"><span class="params">connectionSpecSelector)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个函数主要是判断使用哪种协议，主要有三种：</p>
<ul>
<li>一是如果route.address().sslSocketFactory() == null<br>那么就是不需要HTTPS，使用的是HTTP协议，直接用HTTP1.1，socket直接用rassocket，返回。</li>
<li>一里面不返回，自然是要使用HTTPS协议，那么调用connectTls(connectionSpecSelector);—&gt;Q</li>
<li>三是判断if (protocol == Protocol.HTTP_2) ，因为二的调用导致了protocol的赋值.</li>
</ul>
<p>总之如果if满足的话，就创建了一个http2Connection，并且执行了http2Connection.start()，去到http2Connection这个类里面，涉及了一些handler,runnable的操作，开启了connection。</p>
<p>Q.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">connectTls</span><span class="params">(ConnectionSpecSelector connectionSpecSelector)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个函数比较长就不详细看了…大概就是用SSLSocketFactory创建了sslSocket然后选择了密码版本，TLS版本，配置了address的主机和协议，然后进行了握手，认证，最后用okio封装了sslSocket的输入和输出流。</p>
<p>在封装前还做了这样一件事：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Success! Save the handshake and the ALPN protocol.</span></span><br><span class="line"></span><br><span class="line">String maybeProtocol = connectionSpec.supportsTlsExtensions()</span><br><span class="line">? Platform.get().getSelectedProtocol(sslSocket) : <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">// 封装了后,</span></span><br><span class="line">protocol = maybeProtocol != <span class="keyword">null</span> ? Protocol.get(maybeProtocol)</span><br><span class="line">: Protocol.HTTP_1_1;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 总之就是maybeProtocol似乎影响了protocol的选择= =唉不管了,比较涉及socket方面的内容.</span></span><br></pre></td></tr></table></figure>
<h5 id="④StreamAllocation-JAVA"><a href="#④StreamAllocation-JAVA" class="headerlink" title="④StreamAllocation.JAVA"></a><strong>④StreamAllocation.JAVA</strong></h5><p><strong>HTTP连接前需要进行socket握手，根据域名或代理确定socket的ip和端口。主要由这个类完成。</strong><br>使用了类似于<strong>引用计数的方式跟踪Socket流的调用</strong>，这里的计数对象是StreamAllocation，它被反复执行aquire与release操作，这两个函数其实是在改变RealConnection中的List&gt;<br>的大小。</p>
<p><strong>E.</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> HttpCodec <span class="title">newStream</span><span class="params">(OkHttpClient client, **<span class="keyword">boolean</span>**</span></span></span><br><span class="line"><span class="function"><span class="params">doExtensiveHealthChecks)</span></span></span><br><span class="line"><span class="function">该函数根据client设置的连接超时、读写超时、失败是否重试，通过调用findHealthyConnection函数真正的建立一个RealConnection连接，又通过这个连接创建一个HttpCodec：</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">RealConnection resultConnection </span>= findHealthyConnection(connectTimeout,readTimeout,writeTimeout, connectionRetryEnabled, doExtensiveHealthChecks);---&gt;F</span><br><span class="line">，F主要是查找可用连接，一系列的步骤都有分析(F~Q都是），找到可用的连接后执行下一句，用这个链接创建HttpCodeC</span><br><span class="line"></span><br><span class="line">HttpCodec resultCodec = resultConnection.newCodec(client, <span class="keyword">this</span>); ---&gt;R</span><br><span class="line"></span><br><span class="line">得到httpCodec之后，终于可以把结果返回给conn拦截器的入口了，即它的intercept函数里面了...</span><br></pre></td></tr></table></figure></p>
<p>R.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> HttpCodec <span class="title">newCodec</span><span class="params">(）&#123;&#125;</span></span></span><br></pre></td></tr></table></figure></p>
<p>这个函数比较简单，就是http2Con != NULL,就建立http2codec，否则就设置好各种超时限制建立http1codec,就是调用构造函数。不再详解。</p>
<p>F.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">该函数中查找健康连接，如果是全新连接可以直接返回，否则还要对候选的连接进行健康检查。如果检查结果不健康就调用noNewStream和continue结束这次循环操作，进入下个循环。</span></span><br><span class="line"><span class="comment">   * Finds a connection and returns it if it is healthy. If it is unhealthy the process is repeated</span></span><br><span class="line"><span class="comment">   * until a healthy connection is found.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> RealConnection <span class="title">findHealthyConnection</span><span class="params">(<span class="keyword">int</span> connectTimeout, <span class="keyword">int</span> readTimeout,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">int</span> writeTimeout, <span class="keyword">boolean</span> connectionRetryEnabled, <span class="keyword">boolean</span> doExtensiveHealthChecks)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">	  <span class="comment">//找到候选连接</span></span><br><span class="line">      RealConnection candidate = findConnection(connectTimeout, readTimeout, writeTimeout,</span><br><span class="line">          connectionRetryEnabled);---&gt;G</span><br><span class="line"></span><br><span class="line">      <span class="comment">// If this is a brand new connection, we can skip the extensive health checks.</span></span><br><span class="line">      <span class="keyword">synchronized</span> (connectionPool) &#123;</span><br><span class="line">        <span class="keyword">if</span> (candidate.successCount == <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> candidate;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Do a (potentially slow) check to confirm that the pooled connection is still good. If it</span></span><br><span class="line">      <span class="comment">// isn't, take it out of the pool and start again.</span></span><br><span class="line">	  <span class="comment">// 不是全新连接，继续检查：</span></span><br><span class="line">      <span class="keyword">if</span> (!candidate.isHealthy(doExtensiveHealthChecks)) &#123;</span><br><span class="line">        noNewStreams();</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> candidate;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>G.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> RealConnection <span class="title">findConnection</span><span class="params">(<span class="keyword">int</span> connectTimeout, <span class="keyword">int</span> readTimeout, <span class="keyword">int</span> writeTimeout,<span class="keyword">boolean</span> connectionRetryEnabled)</span></span></span><br></pre></td></tr></table></figure></p>
<p>返回一个用于流执行底层IO的连接，优先复用已经创建的连接，没有可复用的就创建一个。</p>
<p>首先是锁住连接池，防止别的线程加入和移出连接，然后尝试上次分配的连接是否可用，行的话就返回给调用者。不行的话又通过Internal.instance.get()从连接池中取得连接，行的话就返回。如果还是不行的话，选择一个路由。连接池块结束。</p>
<p>如果路由为空，那么selectedRoute = routeSelector.next(); —&gt;H<br>创建新的路由(HI的内容）.<br>I结束后出创建了新的路由，回到这里。再次锁住连接池，并且再次：<br>Internal.instance.get(connectionPool, address, this, selectedRoute);—&gt; J<br>这个函数其实调用了pool的get，然后pool根据address选择链接，如果找到合适的连接，就使用acquire获取这个conn对象。</p>
<p>然后结束这个同步块，进行TCP+TLS的握手，真正开始建立连接:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">result.connect(connectTimeout, readTimeout,</span><br><span class="line">writeTimeout,connectionRetryEnabled);---&gt;N</span><br><span class="line">routeDatabase().connected(result.route());</span><br></pre></td></tr></table></figure></p>
<p>L.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(RealConnection connection)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>在这个函数中，<br>connection.allocations.add(new StreamAllocationReference(this,<br>callStackTrace));</p>
<p><strong>把当前SA对象的引用保存到了RealConn的allocation里面，主要是为了追踪RealConn;</strong></p>
<p>这样看来，同一个连接RealConnection似乎可以同时为多个HTTP请求服务，但实际上，多个HTTP/1.1请求是不能在一个连接上交叉处理的。</p>
<p>这就是要看connection.allocationLimit的更新设置，当使用HTTP1.1的请求时，这个值就一直为1，当然了，如果是2.0协议，自然可以将这个值设置大于1，实现HTTP2.0的多路复用。</p>
<h5 id="⑤各种拦截器"><a href="#⑤各种拦截器" class="headerlink" title="⑤各种拦截器"></a><strong>⑤各种拦截器</strong></h5><p><strong>T.CacheInterceptor</strong></p>
<p>在构造okHTTPclient时，可以设置cache对象，设置缓存的目录和大小。<br>如果不想用它的缓存策略，可以实现internalCache接口实现自定义缓存。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br></pre></td></tr></table></figure>
<p>1）首先判断用户是否设置了cache，如果有的话，就调用cache.get(chain.request())尝试获取这个request对应的response。</p>
<p><strong>下面这段话是哪儿来的？？</strong><br><strong>就从cache里面获取cacheDandiate:</strong><br><strong>cacheCandiate就是上次与服务器交互缓存的Response，可能为null，它目前是一个可以读取缓存header的response：</strong></p>
<p>Response cacheCandidate = cache != null<br>? cache.get(chain.request()) —-&gt;1A (1B,1C都是1A中引发的）: null;</p>
<p>2）然后缓存策略对当前信息进行一点加工：<br>CacheStrategy strategy = new CacheStrategy.Factory(now, chain.request(), cacheCandidate).get(); —-&gt; U// 参数为当前时间、当前请求、当前缓存响应。</p>
<p>3）如果cache不为空，那么调用cache.trackResponse(strategy);</p>
<p>4）如果有cache的候选，但是stragey返回的响应cacheResponse为空，说明这个cache候选用不了，关闭它，closeQuietly(cacheCandidate.body());</p>
<p>5）策略加工后输出的newtworkRequest（进行网络请求）和cacheResponse（可以用的缓存）有以下几种情况：</p>
<p>5.1）如果不能使用newtworkRequest并且stragey返回的响应cacheResponse为空，那么返<strong>回504的response。表明不进行网络请求，且缓存不存在或者过期。</strong></p>
<p>5.2）如果只是不需要使用networkRequest，那么把strategy返回的响应cacheResponse给return就行了。<strong>缓存可以用，而且不用进行网络请求。</strong></p>
<p>再下来当然就是可以用network了，</p>
<p>networkResponse = chain.proceed(networkRequest); 处理当前请求。</p>
<p>5.3）如果cacheResponse不为空，那么看network返回的响应，如果响应码是HTTP_NOT_MODIFIED（没有更新），那么直接返回cache的响应。<strong>这是因为requst的头部中含有ETag/Last-Modified标签，需要在条件请求下使用，虽然有了缓存，但还是需要访问网络。</strong></p>
<p>4）没有返回cache的响应，自然要返回network的响应了。<strong>这是因为缓存不存在或者过期了。</strong></p>
<p>然后或许要把这个请求的network的响应保存到cache中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (HttpHeaders.hasBody(response)) &#123;</span><br><span class="line">	CacheRequest cacheRequest = maybeCache(response, networkResponse.request(),</span><br><span class="line">	cache);----&gt;V</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//一圈下来终于得到了cacheRequest，终于可以把这个response写到这个cacherequest中了。</span></span><br><span class="line">	response = cacheWritingResponse(cacheRequest, response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后返回response，这个拦截器的intercept就执行结束了。</p>
<p>人家关于缓存策略的总结（记得找参考的地址贴上来…)：<br><strong>Okhttp的缓存是自动完成的，完全由服务器Header决定的，自己没有必要进行控制。</strong>网上热传的文章在Interceptor中手工添加缓存代码控制（比如服务器不支持的时候，重写cacheInterceptor，把它加到networkInterceptor中），它固然有用，但是属于Hack式的利用，违反了RFC文档标准，不建议使用，OkHttp的官方缓存控制在注释中。如果读者的需求是对象持久化，建议用文件储存或者数据库即可（比如realm）。</p>
<p><strong>1A:</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Response <span class="title">get</span><span class="params">(Request request)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>cache中的函数，首先根据url得到key，然后看是否能从diskcache中取到snapshot，如果取到：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">entry = <span class="keyword">new</span> Entry(snapshot.getSource(ENTRY_METADATA));</span><br><span class="line">---&gt;括号中<span class="number">1</span>B,得到[<span class="number">0</span>]处的非缓冲流，并且构造一个Entry。Entry是cache中的静态常量类！！<span class="keyword">new</span> Entry--&gt;<span class="number">1</span>C</span><br></pre></td></tr></table></figure></p>
<p>cache类中一个内部类Entry。构造出了entry，也就是确定了响应信息的各种变量，再调用如下函数,也就是得到entry后：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Response response = entry.response(snapshot);</span><br><span class="line">---&gt;1D</span><br><span class="line">//这个函数也是cache的内部类Entry的.所以是上一句，把各种信息构造成了Entry（entry的各变量被赋值），而这一步就吧entry的信息取出来构造成了response。。看起来很多余啊。。。。。。但感觉是为了把snapshot作为变量也传进去..</span><br></pre></td></tr></table></figure></p>
<p><strong>V.</strong><br>发现这个函数现在版本没有了，待更新。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> CacheRequest <span class="title">maybeCache</span><span class="params">(Response userResponse, Request</span></span></span><br><span class="line"><span class="function"><span class="params">networkRequest,InternalCache responseCache)</span></span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//该函数中，如果这个响应不能保存在这个request的cache中（isCacheable返回假）:</span></span><br><span class="line"><span class="keyword">if</span> (!CacheStrategy.isCacheable(userResponse, networkRequest)) &#123;</span><br><span class="line">那么判断这个request是否禁止cache（put中有详细禁止的判断，有五种方法禁止），是的话，就从cache中把这个请求remove掉：</span><br><span class="line">	<span class="keyword">if</span> (HttpMethod.invalidatesCache(networkRequest.method())) &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			responseCache.remove(networkRequest);</span><br><span class="line">只进入第一个<span class="keyword">if</span>就返回<span class="keyword">null</span>。</span><br><span class="line">否则就<span class="keyword">return</span> responseCache.put(userResponse);---&gt; W</span><br></pre></td></tr></table></figure>
<p><strong>D.connection拦截器：</strong></p>
<p>httpCodec 和 realconnection的建立都是在这个拦截器中。通过sA的newStream中的findHealthyConn找到了符合目标服务器的realConn，然后利用这个realConn创建了httpcodec。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">	RealInterceptorChain realChain = (RealInterceptorChain) chain;</span><br><span class="line">	<span class="comment">// 获得这个链的request和stream</span></span><br><span class="line">	Request request = realChain.request();</span><br><span class="line">	StreamAllocation streamAllocation = realChain.streamAllocation();</span><br><span class="line">	<span class="comment">// We need the network to satisfy this request. Possibly for validating a conditional GET.</span></span><br><span class="line">	<span class="keyword">boolean</span> doExtensiveHealthChecks = !request.method().equals(<span class="string">"GET"</span>);</span><br><span class="line">	<span class="comment">// 用stream建立一个httpcode,完成建立工作</span></span><br><span class="line">	HttpCodec httpCodec = streamAllocation.newStream(client,</span><br><span class="line">	doExtensiveHealthChecks); ---&gt;E 。 R执行完了之后终于回来了。</span><br><span class="line">	RealConnection connection = streamAllocation.connection();<span class="comment">//由于E-R的过程中，streamAllocation保存了connection，所以这个函数其实是return了这个sA对象保存的realConn。</span></span><br><span class="line">	<span class="keyword">return</span> realChain.proceed(request, streamAllocation, httpCodec, connection);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//然后继续调用proceed，proceed中当然是应该执行callandserver这个拦截器了。---&gt;S</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>目前ABCD的执行过程：在realcall的</strong>getResponseWithInterceptorChain()中，创建一个只含有拦截器链表和origirequest的chain,该chain执行proceed（requsest），在其中创建第index+1个拦截链next（其实就是去执行第index+1个拦截器），interact(next）执行当前index的拦截器的该方法，要把next这个链作为proceed的参数传下去，因为intercept中要继续调用proceed。</p>
<p>E到R整个过程都是这句话带来的：<br>HttpCodec httpCodec = streamAllocation.newStream(client,<br>doExtensiveHealthChecks);</p>
<p>主要就是创建了一个连接，并且记录了httpcodec。<br><strong>HttpCodec 则是利用 Okio 实现具体的数据 IO 操作。</strong></p>
<p>按照顺序，connect拦截器做完工作之后就是CallServerInterceptor。</p>
<p><strong>S.CallServerInterceptor</strong></p>
<p><strong>照样只有一个函数，居然那么长：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">	HttpCodec httpCodec = ((RealInterceptorChain) chain).httpStream();</span><br><span class="line">	StreamAllocation streamAllocation = ((RealInterceptorChain)</span><br><span class="line">	chain).streamAllocation();</span><br><span class="line">	Request request = chain.request();</span><br><span class="line">	<span class="keyword">long</span> sentRequestMillis = System.currentTimeMillis();</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//发送http头部信息</span></span><br><span class="line">	httpCodec.writeRequestHeaders(request);</span><br><span class="line">	Response.Builder responseBuilder = <span class="keyword">null</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//如果http方法允许有请求body并且请求body不为null</span></span><br><span class="line">	<span class="keyword">if</span> (HttpMethod.permitsRequestBody(request.method()) &amp;&amp; request.body() !=</span><br><span class="line">	<span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="comment">// If there's a "Expect: 100-continue" header on the request, wait for a</span></span><br><span class="line">		<span class="string">"HTTP/1.1 100</span></span><br><span class="line"><span class="string">		// Continue"</span> response before transmitting the request body. If we don<span class="string">'t get</span></span><br><span class="line"><span class="string">		that, return what</span></span><br><span class="line"><span class="string">		// we did get (such as a 4xx response) without ever transmitting the request</span></span><br><span class="line"><span class="string">		body.</span></span><br><span class="line"><span class="string">		//等待截断body前得到的服务器同意100 continue的response，如果没有得到这个回应，返回我们实际得到的响应</span></span><br><span class="line"><span class="string">		if ("100-continue".equalsIgnoreCase(request.header("Expect"))) &#123;</span></span><br><span class="line"><span class="string">			httpCodec.flushRequest();</span></span><br><span class="line"><span class="string">			// 由于传入了true，如果statusLine.code == HTTP_CONTINUE，那么就会返回null</span></span><br><span class="line"><span class="string">			responseBuilder = httpCodec.readResponseHeaders(true);</span></span><br><span class="line"><span class="string">		&#125;</span></span><br><span class="line"><span class="string">		// Write the request body, unless an "Expect: 100-continue" expectation</span></span><br><span class="line"><span class="string">failed.</span></span><br><span class="line"><span class="string">		//是否运行当前方法带body，通过okio把请求body写入到</span></span><br><span class="line"><span class="string">		if (responseBuilder == null) &#123;</span></span><br><span class="line"><span class="string">			Sink requestBodyOut = httpCodec.createRequestBody(request, request.body().contentLength());</span></span><br><span class="line"><span class="string">			BufferedSink bufferedRequestBody = Okio.buffer(requestBodyOut);</span></span><br><span class="line"><span class="string">			request.body().writeTo(bufferedRequestBody); //这个函数，在rb这个类的writeTo函数中，把body的内容写到了这个缓冲池中</span></span><br><span class="line"><span class="string">			bufferedRequestBody.close();</span></span><br><span class="line"><span class="string">		&#125;</span></span><br><span class="line"><span class="string">	&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	//刷新。</span></span><br><span class="line"><span class="string">	httpCodec.finishRequest();</span></span><br><span class="line"><span class="string">	//再读取一遍响应头</span></span><br><span class="line"><span class="string">	if (responseBuilder == null) &#123;</span></span><br><span class="line"><span class="string">		responseBuilder = httpCodec.readResponseHeaders(**false**);</span></span><br><span class="line"><span class="string">	&#125;</span></span><br><span class="line"><span class="string">	</span></span><br><span class="line"><span class="string">	// 读取响应头设置response</span></span><br><span class="line"><span class="string">	Response response = responseBuilder</span></span><br><span class="line"><span class="string">	.request(request)</span></span><br><span class="line"><span class="string">	.handshake(streamAllocation.connection().handshake())</span></span><br><span class="line"><span class="string">	.sentRequestAtMillis(sentRequestMillis)</span></span><br><span class="line"><span class="string">	.receivedResponseAtMillis(System.currentTimeMillis())</span></span><br><span class="line"><span class="string">	.build();</span></span><br><span class="line"><span class="string">	int code = response.code();</span></span><br><span class="line"><span class="string">	if (forWebSocket &amp;&amp; code == 101) &#123;</span></span><br><span class="line"><span class="string">	// Connection is upgrading, but we need to ensure interceptors see a non-null response body.</span></span><br><span class="line"><span class="string">		response = response.newBuilder()</span></span><br><span class="line"><span class="string">			.body(Util.EMPTY_RESPONSE)</span></span><br><span class="line"><span class="string">			.build();</span></span><br><span class="line"><span class="string">	&#125; else &#123;</span></span><br><span class="line"><span class="string">	//在有响应头的情况下读取响应body</span></span><br><span class="line"><span class="string">	response = response.newBuilder()</span></span><br><span class="line"><span class="string">			.body(httpCodec.openResponseBody(response))// 提供具体 HTTP 协议版本的响应 body</span></span><br><span class="line"><span class="string">			.build();</span></span><br><span class="line"><span class="string">	&#125;</span></span><br><span class="line"><span class="string">	if("close".equalsIgnoreCase(response.request().header("Connection")) || "close".equalsIgnoreCase(response.header("Connection"))) &#123;</span></span><br><span class="line"><span class="string">		streamAllocation.noNewStreams();</span></span><br><span class="line"><span class="string">	&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	if ((code == 204 || code == 205) &amp;&amp; response.body().contentLength() &gt; 0) &#123;</span></span><br><span class="line"><span class="string">		throw new ProtocolException(</span></span><br><span class="line"><span class="string">			"HTTP " + code + " had non-zero Content-Length: " +</span></span><br><span class="line"><span class="string">			response.body().contentLength());</span></span><br><span class="line"><span class="string">	&#125;</span></span><br><span class="line"><span class="string">	return response;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>关于except:100-continue:<br>在使用curl做POST的时候, 当要POST的数据大于1024字节的时候,<br>curl并不会直接就发起POST请求, 而是会分为俩步,；<br>　　流程如下：<br>　　1. 发送一个请求, 包含一个Expect:100-continue, 询问Server使用愿意接受数据<br>　　2. 接收到Server返回的100-continue应答以后, 才把数据POST给Server</p>
<p>使用100（不中断，继续）状态码的目的是为了在客户端发出请求体之前，让服务器根据客户端发出的请求信息（根据请求的头信息）来决定是否愿意接受来自客户端的包含了请求内容的请求；</p>
<h5 id="⑥SelectorRoute-JAVA"><a href="#⑥SelectorRoute-JAVA" class="headerlink" title="⑥SelectorRoute.JAVA"></a><strong>⑥SelectorRoute.JAVA</strong></h5><p><strong>H</strong><br>这个函数好像也改过了…待更新<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Route <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">该函数中，首先三个<span class="keyword">if</span>嵌套。顺序为：</span><br><span class="line">判断是否有socket地址--》 判断是否有代理---》判断是否有route--》 抛出异常</span><br><span class="line">一直是not状态。如果是yes状态跳到如下：</span><br><span class="line">确定下一个socket地址 </span><br><span class="line">lastProxy = nextProxy(); </span><br><span class="line"><span class="keyword">return</span> nextPostponed();</span><br><span class="line"></span><br><span class="line"><span class="comment">// IP地址，代理，socket地址都找到后，建立新的路由</span></span><br><span class="line">Route route = <span class="keyword">new</span> Route(address, lastProxy, lastInetSocketAddress);--&gt;I</span><br></pre></td></tr></table></figure></p>
<h5 id="⑦Route-JAVA"><a href="#⑦Route-JAVA" class="headerlink" title="⑦Route.JAVA"></a><strong>⑦Route.JAVA</strong></h5><p>I.构造函数主要就是把参数address,proxy,socketaddress赋值给这个类的成员变量。</p>
<p><strong>⑧okHttpClient.JAVA</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">**J.**</span><br><span class="line">Internal.instance = <span class="keyword">new</span> Internal() &#123;....&#125; </span><br><span class="line">是这个类中的一个<span class="keyword">static</span>代码块。它的get函数其实是调用了连接池的get：</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> RealConnection <span class="title">get</span><span class="params">(ConnectionPool pool, Address address,StreamAllocation streamAllocation, Route route)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> pool.get(address, streamAllocation, route); --&gt; K</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="⑨ConnectionPool-JAVA"><a href="#⑨ConnectionPool-JAVA" class="headerlink" title="⑨ConnectionPool.JAVA"></a><strong>⑨ConnectionPool.JAVA</strong></h5><p><strong>主要用来管理realConnection。</strong></p>
<p><strong>K.</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">RealConnection <span class="title">get</span><span class="params">(Address address, StreamAllocation streamAllocation,</span></span></span><br><span class="line"><span class="function"><span class="params">Route route)</span>；</span></span><br><span class="line"><span class="function">	<span class="comment">//这个函数遍历了所有连接，查找是否有address可复用的连接：</span></span></span><br><span class="line"><span class="function">	<span class="title">for</span> <span class="params">(RealConnection connection : connections)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//如果找到了，就把这个链接交给sA复用</span></span><br><span class="line">	<span class="keyword">if</span> (connection.isEligible(address, route)) &#123; ----&gt;M</span><br><span class="line">		streamAllocation.acquire(connection); ---&gt; L</span><br><span class="line">		<span class="keyword">return</span> connection;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="⑩AndroidPlatform-JAVA"><a href="#⑩AndroidPlatform-JAVA" class="headerlink" title="⑩AndroidPlatform.JAVA"></a><strong>⑩AndroidPlatform.JAVA</strong></h5><p><strong>O</strong>.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connectSocket</span><span class="params">(Socket socket, InetSocketAddress address, <span class="keyword">int</span> connectTimeout)</span></span></span><br></pre></td></tr></table></figure></p>
<p>该函数中调用了socket.connect(address,connectTimeout);成功与服务器建立连接，并且设置了链接的超时时间。address就是InetSocketAddress，包含了服务器的主机地址和端口号。</p>
<h5 id="⑪CacheStrategy-java"><a href="#⑪CacheStrategy-java" class="headerlink" title="⑪CacheStrategy.java"></a><strong>⑪CacheStrategy.java</strong></h5><p>1)private Date expires;<br>缓存的响应的到期时间，如果到期了，就需要网络连接.如果maxAge也设置了，以maxAge优先。</p>
<p>2)private String etag;<br>对资源文件的一种摘要，客户端不需要了解实现的细节，第一次请求时，服务器返回：</p>
<p>ETag: “5694c7ef-24dc”<br>客户端再次请求时，发送 If-None-Match:”5694c7ef-24dc”<br>交给服务器判断是否使用缓存。</p>
<p><strong>U</strong>.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Factory</span><span class="params">(<span class="keyword">long</span> nowMillis, Request request, Response</span></span></span><br><span class="line"><span class="function"><span class="params">cacheResponse)</span></span></span><br><span class="line"><span class="function"><span class="comment">//设置这个策略的各个成员变量。</span></span></span><br><span class="line"><span class="function"><span class="comment">//然后构造之后是一个链式调用，调用了get():</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CacheStrategy <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	CacheStrategy candidate = getCandidate();</span><br><span class="line">	<span class="keyword">if</span> (candidate.networkRequest != <span class="keyword">null</span> &amp;&amp; request.cacheControl().onlyIfCached()) &#123;</span><br><span class="line">		<span class="comment">// We're forbidden from using the network and the cache is insufficient.</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> CacheStrategy(<span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> candidate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>getCandidate();也是这个类里面的，太长了。大概就是根据构造函数里面的成员变量，选定了conditionalRequest和cacheResponse，然后new了新的cacheStragy给返回了。<br>选的这个过程大概就是策略了= =</p>
<p>#####<strong>⑫Cache.JAVA</strong></p>
<p>(实现了internalCache接口， okhttp里面自带的cache）</p>
<p><strong>W.</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">CacheRequest <span class="title">put</span><span class="params">(Response response)</span> </span>&#123;&#125;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	一是httpmethod的invalidatesCache判断该请求是否不能缓存（五个），不能的话当然从cache中把这个request删掉，然后返回null。五个不支持缓存的：</span></span><br><span class="line"><span class="comment">	post;put;patch;delete;move</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	二是判断是不是GET方法，不是的话也返回NULL。</span></span><br><span class="line"><span class="comment">	虽然结果一样，但写清楚情况是非常必要的！！</span></span><br><span class="line"><span class="comment">	官方给的解释是缓存get方法得到的Response效率高，其它方法的Response缓存效率低。通常通过get方法获取到的数据都是固定不变的的，因此缓存效率自然就高了。其它方法会根据请求报文参数的不同得到不同的Response，因此缓存效率自然而然就低了。</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	三是if(HttpHeaders.hasVaryAll(response))判断是否有通配符“*”，有的话也直接返回null。</span></span><br><span class="line"><span class="comment">	接着用response构造一个entry。</span></span><br><span class="line"><span class="comment">	然后构造一个diskLruCache的editor对象：</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line"></span><br><span class="line">	Entry entry = <span class="keyword">new</span> Entry(response);</span><br><span class="line">	DiskLruCache.Editor editor = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		editor = cache.edit(key(response.request().url()));</span><br><span class="line">		<span class="keyword">if</span> (editor == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	entry.writeTo(editor);</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> CacheRequestImpl(editor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>edit方法得到了一个sink对象<br>接着用entry.writeTo(editor);把entry中的数据写到这个缓冲池editor里面。<br>最后：<br>return new CacheRequestImpl(editor); —&gt; X</p>
<p>CacheRequestImpl.JAVA<br>CacheRequestImpl是这个类中的一个实现了CacheRequest接口的常量类，主要是四个成员变量：<br>private final DiskLruCache.Editor editor;<br>private Sink cacheOut;<br>private Sink body;<br>boolean done;</p>
<p>X.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在这个构造函数中，this.cacheOut = editor.newSink(ENTRY_BODY); 这一句 ，</span></span><br><span class="line">把editor中保存的sink对象取出赋值给了crI的成员变量。构造函数最后一定要调用editor.commit();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CacheRequestImpl</span><span class="params">(<span class="keyword">final</span> DiskLruCache.Editor editor)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.editor = editor;</span><br><span class="line">	<span class="keyword">this</span>.cacheOut = editor.newSink(ENTRY_BODY);---&gt;Y <span class="comment">//ENTRY_BODY的值是1</span></span><br><span class="line">	<span class="keyword">this</span>.body = <span class="keyword">new</span> ForwardingSink(cacheOut) &#123;</span><br><span class="line">	<span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		<span class="keyword">synchronized</span> (Cache.<span class="keyword">this</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (done) &#123;</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			done = <span class="keyword">true</span>;</span><br><span class="line">			writeSuccessCount++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">super</span>.close();</span><br><span class="line">		editor.commit();</span><br><span class="line">	&#125;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>Class Entry:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>两种构造方式：<br>一是从Source in这个流得到信息进行处理，一是从response得到数据，直接赋值变量。</p>
<p><strong>1C.</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*Reads an entry from an input stream.*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Entry</span><span class="params">(Source in)</span> <span class="keyword">throws</span> IOException </span>&#123;&#125;</span><br><span class="line">其实就是处理响应头，一般entry有两种形式：HTTP或者HTTPS</span><br><span class="line">首先根据in得到BufferedSource source:</span><br><span class="line">BufferedSource source = Okio.buffer(in);</span><br><span class="line">然后根据source,得到响应头需要的信息：</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Entry</span><span class="params">(Source in)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		BufferedSource source = Okio.buffer(in);</span><br><span class="line">		url = source.readUtf8LineStrict();</span><br><span class="line">		requestMethod = source.readUtf8LineStrict();</span><br><span class="line">		Headers.Builder varyHeadersBuilder = <span class="keyword">new</span> Headers.Builder();</span><br><span class="line">		<span class="keyword">int</span> varyRequestHeaderLineCount = readInt(source);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; varyRequestHeaderLineCount; i++) &#123;</span><br><span class="line">			varyHeadersBuilder.addLenient(source.readUtf8LineStrict());</span><br><span class="line">		&#125;</span><br><span class="line">		varyHeaders = varyHeadersBuilder.build();</span><br><span class="line">		StatusLine statusLine = StatusLine.parse(source.readUtf8LineStrict());</span><br><span class="line">		protocol = statusLine.protocol;</span><br><span class="line">		code = statusLine.code;</span><br><span class="line">		message = statusLine.message;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// Builder模式哦~~</span></span><br><span class="line">		Headers.Builder responseHeadersBuilder = <span class="keyword">new</span> Headers.Builder();</span><br><span class="line">		<span class="keyword">int</span> responseHeaderLineCount = readInt(source);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; responseHeaderLineCount; i++) &#123;</span><br><span class="line">			responseHeadersBuilder.addLenient(source.readUtf8LineStrict());</span><br><span class="line">		&#125;</span><br><span class="line">		String sendRequestMillisString = responseHeadersBuilder.get(SENT_MILLIS);</span><br><span class="line">		String receivedResponseMillisString = responseHeadersBuilder.get(RECEIVED_MILLIS);</span><br><span class="line">		responseHeadersBuilder.removeAll(SENT_MILLIS);</span><br><span class="line">		responseHeadersBuilder.removeAll(RECEIVED_MILLIS);</span><br><span class="line">		sentRequestMillis = sendRequestMillisString != <span class="keyword">null</span> ? Long.parseLong(sendRequestMillisString) : <span class="number">0L</span>;</span><br><span class="line">		receivedResponseMillis = receivedResponseMillisString != <span class="keyword">null</span> ?Long.parseLong(receivedResponseMillisString) : <span class="number">0L</span>;</span><br><span class="line">		responseHeaders = responseHeadersBuilder.build();</span><br><span class="line">		<span class="keyword">if</span> (isHttps()) &#123;</span><br><span class="line">			String blank = source.readUtf8LineStrict();</span><br><span class="line">			<span class="keyword">if</span> (blank.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"expected \"\" but was \""</span> + blank +<span class="string">"\""</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			String cipherSuiteString = source.readUtf8LineStrict();</span><br><span class="line">			CipherSuite cipherSuite = CipherSuite.forJavaNam(cipherSuiteString);</span><br><span class="line">			List&lt;Certificate&gt; peerCertificates = readCertificateList(source);</span><br><span class="line">			List&lt;Certificate&gt; localCertificates = readCertificateList(source);</span><br><span class="line">			TlsVersion tlsVersion = !source.exhausted() ? TlsVersion.forJavaName(source.readUtf8LineStrict()) : <span class="keyword">null</span>;</span><br><span class="line">			handshake = Handshake.get(tlsVersion, cipherSuite, peerCertificates,localCertificates);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			handshake = <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;<span class="keyword">finally</span> &#123; <span class="comment">// 对应开始的try</span></span><br><span class="line">		in.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>二是这种构造方法，response这种很好理解：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Entry</span><span class="params">(Response response)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.url = response.request().url().toString();</span><br><span class="line">	<span class="keyword">this</span>.varyHeaders = HttpHeaders.varyHeaders(response);</span><br><span class="line">	<span class="keyword">this</span>.requestMethod = response.request().method();</span><br><span class="line">	<span class="keyword">this</span>.protocol = response.protocol();</span><br><span class="line">	<span class="keyword">this</span>.code = response.code();</span><br><span class="line">	<span class="keyword">this</span>.message = response.message();</span><br><span class="line">	<span class="keyword">this</span>.responseHeaders = response.headers();</span><br><span class="line">	<span class="keyword">this</span>.handshake = response.handshake();</span><br><span class="line">	<span class="keyword">this</span>.sentRequestMillis = response.sentRequestAtMillis();</span><br><span class="line">	<span class="keyword">this</span>.receivedResponseMillis = response.receivedResponseAtMillis();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>服气了= =先调用entry的构造方法构造了entry，又用entry反过来调用这个builder方法来构造response。response除了包括响应信息(Response的内容）外，还有对应的request。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Response <span class="title">response</span><span class="params">(DiskLruCache.Snapshot snapshot)</span> </span>&#123;</span><br><span class="line">	String contentType = responseHeaders.get(<span class="string">"Content-Type"</span>);</span><br><span class="line">	String contentLength = responseHeaders.get(<span class="string">"Content-Length"</span>);</span><br><span class="line"></span><br><span class="line">	Request cacheRequest = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">	.url(url)</span><br><span class="line">	.method(requestMethod, <span class="keyword">null</span>)</span><br><span class="line">	.headers(varyHeaders)</span><br><span class="line">	.build();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> Response.Builder()</span><br><span class="line">	.request(cacheRequest)</span><br><span class="line">	.protocol(protocol)</span><br><span class="line">	.code(code)	</span><br><span class="line">	.message(message)</span><br><span class="line">	.headers(responseHeaders)</span><br><span class="line">	.body(<span class="keyword">new</span> CacheResponseBody(snapshot, contentType, contentLength))</span><br><span class="line">	.handshake(handshake)	</span><br><span class="line">	.sentRequestAtMillis(sentRequestMillis)</span><br><span class="line">	.receivedResponseAtMillis(receivedResponseMillis)</span><br><span class="line">	.build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="⑬DiskLRUcache"><a href="#⑬DiskLRUcache" class="headerlink" title="⑬DiskLRUcache"></a><strong>⑬DiskLRUcache</strong></h5><p><strong>Y</strong>.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Sink <span class="title">newSink</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>把File dirtyFile = entry.dirtyFiles[index];这个文件，写入到 a new unbuffered<br>output stream</p>
<p><strong>1B.</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Returns the unbuffered stream with the value for &#123;\@code index&#125;. */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Source <span class="title">getSource</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> sources[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.jpg"
                alt="Ke Yu" />
            
              <p class="site-author-name" itemprop="name">Ke Yu</p>
              <p class="site-description motion-element" itemprop="description">Keep moving. Don't settle.</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">39</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">7</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">47</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Ke Yu</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
