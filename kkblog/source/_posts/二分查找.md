---
title: 二分查找和一些扩展
date: 2017-09-03 15:23:18
tags: [二分查找,上界,下界]
categories: [算法]
---

### 查找

#### 1）顺序查找

**在n个元素的表上直接用key进行比较。**
**只适用于较短的表。**

* 最好情况：1次比较
* 最坏情况：n次比较
* 平均情况：(1+2+3+...+n)/n = （n+1)/2

#### 2）二分查找
**将target与表中央的key进行比较。然后向左或向右二分此表。**
**适用于有序表。**

List的insert和replace操作对有序表不适用，如果想要通过List派生出有序表，要对这两个方法进行重载。
bottom=0,top=size-1
mid = (bottom+top)/2=(size-1)/2;
由于终止条件的不同，可以有几种二分：
![48151C421AD4433B84D5ADCDC78B1AC5.jpg](http://ovwunej09.bkt.clouddn.com/search02.jpg)

##### 查找算法：

**①无论有没有找到target，都一直对表进行二分，直到剩下的表长为1；**

```c++
if(bottom < top) then 继续递归 // 表中元素大于1
else if(top < bottom) then 不存在target 
else then    //top==bottom   相等判断在这个位置
如果data等于target  then 找到target
```

##### 递归条件：

``` c++
if(data<target) then return (mid+1,top)
else then return (bottom,mid)
```

* 此时表的分割如下：

![D74F53DC1BCF45CB8B8C9CE2CEDD1CD7.jpg](http://ovwunej09.bkt.clouddn.com/search03.jpg)

如果表中的目标出现超过一次，当中间的表长为1并且命中目标时，**可以保证它是第一个出现的目标。**
每次查找终止于一个树叶，可能成功可能不成功。
外部路径长度：从根到树中每个树叶各遍历一次所经过的分支数的综合。


* 查找n个元素的表：

![45DBF761E7064BC2960FF114DC06699C.jpg](http://ovwunej09.bkt.clouddn.com/search04.jpg)

**(成功查找和不成功查找的次数一样的）**

* 最坏情况：lgn+1
* 平均情况：lgn

**②进行相等识别。**

``` c++
if(bottom <= top) then 继续递归 // 表中元素大于1
else if(top < bottom) then 不存在target 
else then    //top==bottom
 //如果data等于target  then 找到target 
```


##### 递归条件：
可加上相等判断
```c++
if(data==target) position=mid; //相等判断在这里
else if(data < target) then return (mid+1,top)
else then return (bottom,mid-1)
```

* 此时表的分割如下：

![clipboard.png](http://ovwunej09.bkt.clouddn.com/search02.jpg)

如果表中的目标出现超过一次，会返回目标中的任一实例。
树叶都是不成功查找，所以外部路径长度就是不成功的比较次数。

成功查找：
内部路径长度：根到所有非树叶上的分支数上的和。
所有树叶都是不成功查找，n+1个树叶即n+1个不成功结果n+1约等于2\^h (h是树高）,
h约等于lg(n+1)，在此方法中，

每个内部定点执行2次比较，**所以不成功查找的比较次数为2lg(n+1)**

**成功查找： (       ( (n+1)lg(n+1)-2n ) / 2 + 1     ) \*2 - 1 = 2(n+1)/n \*
lg(n+1) -3 **

* 两种比较

![clipboard.png](http://ovwunej09.bkt.clouddn.com/search04.jpg)

#### 二分查找的应用(lower_bound
第一个大于等于target和upper_bound第一个大于target):
1)方法①得到的就是lower_bound那个数。
**但注意pos的位置：右序列中记录第一个数位置（bottom)**
**左序列中记录最后一个数位置（top)**

#### 递归条件：

``` c++
if(data < target) then return (mid+1,top)
else then return (bottom,mid)
```

**2)方法①中递归条件做一点修改：**

#### 递归条件：
``` c++
if(data > target) then return (bottom, mid)
else then return (mid+1, top)
// pos的位置和1）中一样
```