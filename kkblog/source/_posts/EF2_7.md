---
title: Effective Java 读书笔记（2.5）
date: 2017-07-06 22:23:42
tags: [Effective java, java, 读书笔记]
categories: [Java]
---

第二章 创建和销毁对象

**第七条 避免使用终结（finalizer）方法**

### **终结方法的缺点**

* ①**不能保证会被及时地执行，升职不能保证它会执行。**从一个对象不可达开始，到它的终结方法被执行，所花费的这段时间是任意长的。

	比如，用终结方法来关闭已经打开的文件是不对的，因为打开文件的描述符是一种有限的资源。由于JVM会延迟执行终结方法，所以大量的文件会保留在打开的状态，当一个程序再不能打开文件的时候，可能会运行失败。

	**及时执行终结方法是垃圾回收算法的一个主要功能，这种算法在不同的JVM实现中会大相径庭。**

	在一些情况下，为类提供终结方法，可能会随意地延迟其实例的回收过程。

	**结论：不应该依赖终结方法来更新重要的持久状态。比如依赖终结方法释放共享资源（比如数据库）上的永久锁。**

	System.gc和System.runFinalization增加了终结方法被执行的机会，但不保证终结方法一定会被执行。唯一保证终结方法执行的方法是：System.runFinalizersOnExit和它臭名昭著的孪生兄弟：Runtime.runFinalizersOnExit.
	这两个方法都被废弃了。

* ②如果未被捕获的异常在终结过程中被抛出，那么这种异常会被忽略，并且该对象的终结过程也会被终止。这会使对象处于破坏的状态，如果有另一个线程企图使用这种被破坏的对象，会产生意想不到的结果。**发生在终结方法中的异常不会打印出stack
trace.**

* **③使用终结方法会有严重的性能损失。**

	**如果类对象的资源（文件或者线程等）需要终止的话，怎么做才能不用编写终结方法呢？**

	**提供显式的终止方法。**
	并要求该类的客户端在每个实例不再有用的时候调用这个方法。但是，**实例必须记录下自己是否已经被终止了，需要在一个私域中记录下“该对象不再有效”，如果这些方法是在对象已经终止之后被调用，其他的方法就必须检查这个域，如果检查到这个域已经不再有效，就会抛出异常。**
	
	使用显式调用的终止方法的几个例子：
	a.InputStream；
	b.OutputStream
	c.java.sql.Connection 上的close方法
	d.java.util.Timer的cancel方法
	
	用法：
	
	![clipboard.png](http://ovwunej09.bkt.clouddn.com/EF71.png)
	
	在finally中显式地调用终止方法，即使try中有异常抛出，也会执行finally中的方法。
	
### 终结方法的优点

* ①当对象的所有者**忘记调用显式的终止方法时，终结方法可以充当“安全网”**，虽然这个方法不会及时被调用，但如果客户端无法通过调用显式的终止方法来正常结束操作，那么迟一点释放资源总比不释放资源好。如果**终结方法发现资源还未终止，则应该在日志中记录一条警告。这表示客户端中有bug。**

	刚才列举的显示调用终止方法的四个类，都有终结方法。终止方法未被调用的时候，终结方法会充当安全网。

* ②与对象的本地对等体（native peer）有关。本地对等体是一个本地对象（native object），
普通方法通过本地方法（native method）委托给一个本地对象，因为本地对等体不是一个普通对象，所以垃圾回收器不会知道它。它的JAVA对等体被回收的时候，它不会被回收。如果本地对等体拥有必须被及时终止的资源，那么该类就应该具有一个显式的终止方法。**终止方法应该完成所有必要的工作以便释放关键的资源。**

	**终止方法可以是本地方法，或者它也可以调用本地方法。**

	“终结方法链”并不会被自动执行。如果类有终结方法，并且子类覆盖了终结方法，子类的终结方法就必须手工调用超类的终结方法。**可以在try块中终结子类，并在相应的finally块中调用超类的终结方法。
这样即使子类的终结过程抛出异常，超类的终结方法也会执行。反之亦然。**

	**如果子类覆盖了超类的终结方法，但忘记手工调用超类supe的终结方法，怎么避免这种粗心或者恶意？？**

	**为每个要被终结的对象（外围实例Foo）创建一个附加的对象，把终结方法放到匿名类中，这个匿名类（下图的finalizerGuardian）的作用就是终结它的外围实例。这个匿名类的单个实例被称为终结方法守卫者（finallzer guardian）**

	![clipboard.png](http://ovwunej09.bkt.clouddn.com/EF72.png)

	外围类的每个实例都会创建这样一个守卫者，**外围实例在它的私有实例域中保存着一个对其终结方法守卫者的唯一引用**，所以终结方法守卫者和外围实例可以同时启动终结过程。

	**守卫者被终结的时候，它执行外围实例所期望的终结行为**，就好像它的终结方法是外围对象上的一个方法一样。

	这个例子中的Foo没有终结方法，它的子类所以是否调用super.finalize并不重要。

	**但是对于带有finalize的非final公有类，都应该考虑使用守卫者的这种方法以确保子类不调用super.finalize时也能执行终结方法。**

	所以，只有需要以上两种用途的时候，需要使用终结方法，其他时候，最好都不要使用。
