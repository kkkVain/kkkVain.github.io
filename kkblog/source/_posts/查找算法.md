---
title: 常见查找算法总结
date: 2017-09-11 19:31:14
tags: [静态查找, 动态查找, 二分查找, 平衡二叉树, B树]
categories: [算法]
---

### 一、静态查找

#### 1）顺序查找：**时间复杂度O（N）**

**平均查找长度：(n+1）/2  **
**优点：对表的结构没有要求**

#### 2）二分查找：**期望时间复杂度O（logN）这是一定的！**

**平均查找长度：log(N+1)-1**
**成功查找为log(N）+1**
**不成功查找为log(N）+1**

如果需要添加或者删除一个数据，整个结构都要重建，代价太大。
优点：时间性能比顺序查找好，效率较高
缺点：只适用于顺序存储结构

扩展：

**插值查找**， 不从1/2处断开，而是从1/3,1/4等等地方分开。
时间复杂度为O（log(logN))
**适合于关键字分布又均匀的表。** 如果分布不均匀，那么不适合用插值查找。
mid=(low+high)/2, 即mid=low+1/2\*(high-low);
通过类比，我们可以将查找的点改进为如下：
mid=low+**(key-a[low])/(a[high]-a[low])**\*(high-low)，
斐波那契查找，按黄金比例进行分割。

#### 3）分块查找

也称索引顺序查找。是1）和2）的改进。
把线性表分为若干块；块内无序；块间有序
建立一个索引表，存储**每块内的最大值和这块的起始地址**。

**时间复杂度为O（N）~ O（logN）**
**平均查找长度：(n/s+s)/2+1 ( s是每块的元素个数）**
**优点：顺序存储和链式存储都适用；查找效率高**
**缺点：需要将表分块排序，并且需要为索引表增加存储空间**

![conclusion](http://ovwunej09.bkt.clouddn.com/search01.png)

### 二、动态查找

#### 3）二叉查找树：便于插入和删除，解决了2）的问题

树可能退化为线性结构，**此时是最坏情况，O（N）**
**最好情况是O（logN）**

#### 4）平衡二叉树(AVL,其实是平衡二叉查找树）

不会出现3的最坏情况。
**时间复杂度是O（logN） **
插入、删除时需要做左旋和右旋等操作。

平衡二叉树又被称为AVL树（有别于AVL算法），且具有以下性质：**它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。**

#### 复杂度分析

(1) 查找代价：

AVL是严格平衡的BST（平衡因子不超过1）。那么查找过程与BST一样，只是AVL不会出现最差情况的BST(单支树)。因此**查找效率最好，最坏情况都是O(logN)数量级的。**

(2) 插入代价：

AVL必须要保证严格平衡**(\|bf\|\<=1)**，那么每一次插入数据使得AVL中某些结点的平衡因子超过1就必须进行旋转操作。事实上，AVL的每一次插入结点操作最多只需要旋转1次(单旋转或双旋转)。**因此，总体上插入操作的代价仍然在O(logN)级别上**(插入结点需要首先查找插入的位置)。

(3) 删除代价：

AVL删除结点的算法可以参见BST的删除结点，但是**删除之后必须检查从删除结点开始到根结点路径上的所有结点的平衡因子。因此删除的代价稍微要大一些。每一次删除操作最多需要O(logN)次旋转。因此，删除操作的时间复杂度为O(logN)+O(logN)=O(2logN)**

缺点：
* 为了保持平衡性，动态插入和删除的代价过高；
* 二叉查找树的查找代价都与树高有关，所以需要减小树高。

#### 5）红黑树：并不完全平衡

根节点为黑色；所有叶子节点是黑色；每个红色节点的两个子节点是黑色；
**时间复杂度：O（logN)进行搜索、插入、删除。**

##### 复杂度分析

**(1) 查找代价：**

**由于红黑树的性质(最长路径长度不超过最短路径长度的2倍)，可以说明红黑树虽然不像AVL一样是严格平衡的，但平衡性能还是要比BST要好。其查找代价基本维持在O(logN)左右，但在最差情况下(最长路径是最短路径的2倍少1)，比AVL要略逊色一点。**

**(2) 插入代价：**

**RBT插入结点时，需要旋转操作和变色操作。但由于只需要保证RBT基本平衡就可以了。因此插入结点最多只需要2次旋转，这一点和AVL的插入操作一样。虽然变色操作需要O(logN)，但是变色操作十分简单，代价很小。**

**(3) 删除代价：**

**RBT的删除操作代价要比AVL要好的多，删除一个结点最多只需要3次旋转操作。**

#### 6）多路查找树（B\~,B+)

一个节点上拥有多于2个节点的二叉查找树。
B（B-）树：待插入结构图

##### 复杂度分析

(1) 查找代价：

B-Tree作为一个平衡多路查找树(m-叉)。B树的查找分成两种：一种是从一个结点查找另一结点的地址的时候，需要定位磁盘地址(查找地址)，查找代价极高。另一种是将结点中的有序关键字序列放入内存，进行优化查找(可以用折半)，相比查找代价极低。而**B树的高度很小，因此在这一背景下，B树比任何二叉结构查找树的效率都要高很多。而且B+树作为B树的变种，其查找效率更高。**

(2)插入代价：

**B-Tree的插入会发生结点的分裂操作。当插入操作引起了s个节点的分裂时，磁盘访问的次数为h(读取搜索路径上的节点)＋2s(回写两个分裂出的新节点)＋1（回写新的根节点或插入后没有导致分裂的节点）。因此，所需要的磁盘访问次数是h+2s+1，最多可达到3h+1。因此插入的代价是很大的。**

(3)删除代价：

**B-Tree的删除会发生结点合并操作。最坏情况下磁盘访问次数是3h＝（找到包含被删除元素需要h次读访问）+（获取第2至h层的最相邻兄弟需要h-1次读访问）+（在第3至h层的合并需要h-2次写访问）+（对修改过的根节点和第2层的两个节点进行3次写访问）。**

B+：待插入结构图

应用场景：
来自知乎https://www.zhihu.com/question/30527705/answer/52750388：
AVL是一种高度平衡的二叉树，所以通常的结果是，维护这种高度平衡所付出的代价比从中获得的效率收益还大，故而实际的应用不多，更多的地方是用追求局部而不是非常严格整体平衡的红黑树。当然，如果场景中对插入删除不频繁，只是对查找特别有要求，AVL还是优于红黑的。
红黑树的应用就很多了，除了上面同学提到的STL，还有
-   著名的linux进程调度[Completely Fair
    Scheduler](https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Completely_Fair_Scheduler),用红黑树管理进程控制块
-   epoll在内核中的实现，用红黑树管理事件块
-   nginx中，用红黑树管理timer等
-   Java的TreeMap实现
B和B+主要用在文件系统以及数据库中做索引等，比如Mysql：[B-Tree Index in
MySql](https://link.zhihu.com/?target=https%3A//guptavikas.wordpress.com/2012/12/17/b-tree-index-in-mysql/)

trie树的一个典型应用是前缀匹配，比如下面这个很常见的场景，在我们输入时，搜索引擎会给予提示

#### 7）哈希

查找复杂度**为O（1）**，可以通过变换哈希函数在空间和时间上做出权衡。

![clipboard.png](media/20d9923d23ee1ed7437cb641fa9dd379.png)

平均查找长度：**等概率**下一次查找**所有元素**的比较次数。
二分查找，查找成功的最大次数为：logN（取下限），logN（取下限）+1。


#### 相关题目（基础知识应用）

1.长度为12的无重复有序表，查找成功的平均比较次数为：37/12
把1到12的查找次数都算出来相加除以12（这方法太傻
注意：查找1的次数为3,2的次数为2，所以二分法用的是法1， 不是法2
画二叉树来计算：

            6

      3             9

   2    5     7         11

1     4          8   10  12

1\*1+2\*2+4\*3+5\*4=37

2.但是找77 ，34,99 这三个数的时候又是用法二...

3.顺序查找都是将target与元素逐一比较，所以无论表是有序还是无序，查找长度都是n

4.设有关键字n=2\^h-1，
构成二叉排序树......，概率相等，查找成功的ASL最大是n：错。
注意读题！ASL是平均查找长度，最坏为线性查找（n+1)/2,
时间复杂度为O（n），注意n和O（n）是不同的！！

5.找82的那个数，比较4次，用的方法2...

6.从n个数中找最大的两个数理论上需要几次比较：
找最大的：n-1    找第二大的：logn-1
一共n+logn-2

7.顺序查找中，有序表和无序表的查找失败的平均查找长度不同：
对于有序表，如果找不到，可以直接退出
对于无序表，要全部遍历完才可以确定查找失败。

8.既希望较快的查找又便于**线性表**动态变化的查找方法是：**索引顺序查找。**

**不是哈希！如果哈希的存储不是链式，一般情况随着关键字的增多，冲突频繁发生，查找性能会下降，并且利于动态变化。**

9.**n个顶点的树一定有n-1条边**，所以如果n个顶点m条边的全连通图需要去掉m-(n-1)条边
