---
title: Effective Java 读书笔记（3.8）
date: 2017-07-07 22:43:32
tags: [Effective java, java, 读书笔记]
categories: [Java]
---

第三章 对于所有对象都通用的方法

Object类的所有非final方法（equals，hashcode，toString，clone和finalize）都有明确的通用约定，因为这些方法是被设计成要被覆盖的，所以覆盖时需要遵循这些通用的约定。否则依赖这些约定的类（hashset,hashmap）等，就无法正常工作。

这一章主要是讨论何时以及如何覆盖这些非final的Object方法

**第8条 覆盖equals时请遵守通用约定**

### 何时应该覆盖Object.equals？

* ①类具有自己特有的“逻辑相等”概念（**不是对象等同**），并且超类没有符号equals以实现期望的行为。
“值类”一般就属于这种，也就是仅仅表示值的类，比如Integer或者Date。
我们在使用equals方法时，希望知道他们逻辑上是否相等，而不是想知道他们是否指向同一个对象。

要满足这种期望，不但要重写equals方法，还要使这个类的实例可以被map或者set用作key。

但是有一些“值类”不需要覆盖equals方法：比如用实例受控（第一条）来确保“每个值至多只存在一个对象”的类。枚举类型就属于这种类。对于这种类，逻辑相同和对象等同是一回事，所以Object的equals方法等同于逻辑意义上的equals方法。

覆盖equals方法时候，要遵守以下通用约定：
1）自反性。对于任何非null的引用值x，x.equals(x)必须返回true
2）对称性。对于任何非null的引用值x和y，x.equals(y)是等价的y.equals(x）

以下代码可能会违反这个特性：

![clipboard.png](http://ovwunej09.bkt.clouddn.com/EF81.png)

这个比较是不区分大小写的，并且试图完成与普通String的互操作，但是

对于：

![clipboard.png](http://ovwunej09.bkt.clouddn.com/EF82.png)

cis.equasl(s)会返回true，s.equals(cis)却会返回false，因为String的equal是区分大小写的

要想保持特性需要重构这个方法：

![clipboard.png](http://ovwunej09.bkt.clouddn.com/EF83.png)

**感觉这个代码不对啊,,,, 如果是CIS了... 就不用转换了。但为什么还是&&？**

**这时，针对是同一个类的不同实例之间的比较，不再是不同类的不同实例的比较了。**

3）传递性。对于任何非null的引用值x,y和z，如果x.equals(y)并且y.equals(z)那么y.equals(z)

![clipboard.png](http://ovwunej09.bkt.clouddn.com/EF84.png)

如果打算扩展这个类，增加颜色信息：

![clipboard.png](http://ovwunej09.bkt.clouddn.com/EF85.png)

很明显，如果不重写equals，那么作equals操作时，颜色信息就会被忽略掉。

如果这样重写：

![clipboard.png](http://ovwunej09.bkt.clouddn.com/EF86.png)

如果O只是一个普通Point，那么需要忽略颜色进行比较。

**问题：为什么不用super.equals(o)而用o.equals(this);**
如果O是一个有色Point，那么调用父类的equals比较位置，并且比较颜色。
由于进行A.equals(B)时，调用了子类的equals，说明A是有色Point，那么构造它肯定会首先构造父类（super(x,y)），所以在调用equals时，super.equals(o)意味着用A构造的父类对象和O进行位置的比较，再单独比较颜色。
但是假设：

![clipboard.png](http://ovwunej09.bkt.clouddn.com/EF87.png)

那么p.equals(cp)，直接调用了普通Point的equals。首先cp instanceof
Point是真，那么就接着判断位置，相同的，所以返回true；

cp.equals(p)，调用的是有色Point的equals。首先p instanceof
ColorPoint是假，所以返回false。

**这样就丧失了对称性！**

**所以需要进行修改：**

![clipboard.png](http://ovwunej09.bkt.clouddn.com/EF88.png)

先判断是不是Point，如果是的话，判断是不是colorPoint，不是的话说明它仅仅是普通点，那么调用o.equals(this),这样的话调用的就是父类的equal了。

否则当然就是有色点，先调用父类的equals，再比较color。

**这样虽然保留了对称性，但是丧失了传递性！**

![clipboard.png](http://ovwunej09.bkt.clouddn.com/EF89.png)

p1.equals(p2)返回true,p2.equals(p3)也返回true，但是p1.equals(p3)却不能返回true。

**这是面向对象中关于等价关系的一个基本问题，我们无法在扩展可实例化的类的同时，既增加新的值组件，同时又保留equals约定。**

**如果使用getClass()代替instanceof测试，可以扩展可实例化的类和增加新的值组件，同时保留equals约定。**

![clipboard.png](http://ovwunej09.bkt.clouddn.com/EF810.png)

但是**这违反了里氏替换原则。**此时只有当对象具有相同的实现时，才能使对象等同。这样不算糟糕，但是the
consequences are unacceptable

**为什么说违反了里氏替换原则？？**

**假设有一个方法，用来检验某个整值点是否处在单位圆中：**

![clipboard.png](http://ovwunej09.bkt.clouddn.com/EF811.png)

加入我们扩展point但是不增加值组件，只是让构造器记录创建了多少个实例：

![clipboard.png](http://ovwunej09.bkt.clouddn.com/EF812.png)

里氏替换原则表示：一个类型的任何重要属性也将适用于它的子类型。所以为该类型编写的任何方法，在它的子类型上也应该同样运行得很好。

但是如果我们使用getClass的equals方法，那么我们把CounterPoint实例传入，onUnitCircle方法都会返回false。

也就是说，我们很难找到一个很好的办法，既扩展不可实例化的类，又增加值组件。

有一种方法可以作为权宜之计：复合由于继承。（有点像适配器.....）

比如我们不让ColorPoint扩展Point，而是在ColorPoint中加入一个私有的Point域，以及一个共有的view方法。

![clipboard.png](http://ovwunej09.bkt.clouddn.com/EF813.png)

4）一致性。对于任何非null的引用值x,y，只要equals操作用到的object的信息没有修改，那么对于多次调用，会一致返回true或者false.
如果x.equals(y)并且y.equals(z)那么y.equals(z)

可变对象在不同的时候可以与不同的对象相等，不可变对象则不会这样。

在写类的时候，就应该考虑是否应该不可变。如果是的话，那么要保持这样的限制条件：**相等的对象永远相等，不相等的对象永远不相等。**

但是无论类是否可变，都不要使equals方法依赖于不可靠的资源比如java.net.URL的equals方法依赖于对URL中主机IP地址的比较。
很明显主机名转变为的IP地址具有不稳定性。

5）非空性。对于任何非null的引用值x，x.equals(null)一定返回false。

一些类在equals中首先使用:

![clipboard.png](http://ovwunej09.bkt.clouddn.com/EF814.png)

其实没什么必要。通常来说是直接使用instanceof判断类型。

![clipboard.png](http://ovwunej09.bkt.clouddn.com/EF815.png)

如果漏掉了这一步的类型检查，并且传递给equals方法的参数又是错误的类型，那么equals方法会抛出ClassCastException异常。

所以综合以上要求，实现高质量equals方法的技巧：

**①使用“==”检查“参数是否为这个对象的引用”**，如果返回真，那么equals也可以返回true。特别是equals操作比较昂贵时，可以使用这种方法提高性能。

**②使用instanceof操作符检查“参数是否为正确的类型”**。如果返回假，那么equals直接防护假。

如果类实现的接口改进了equals约定，允许在实现了该接口的类之间进行比较，那么

**③把参数转换成正确的类型。**由于进行了第②步，所以这步一定会成功。

**④对于该类中的每个“关键”域，检查参数中的域是否与该对象中对应的域想匹配。**

**比如为了避免NullPointerException：**

![clipboard.png](http://ovwunej09.bkt.clouddn.com/EF816.png)

但是如果field和o.field常常是相同的对象引用，那么可以使用下面的做法：

![clipboard.png](http://ovwunej09.bkt.clouddn.com/EF817.png)

为了获得最佳的性能，应该最先比较最有可能不一致的域。

⑤编写完了equals方法之后，有三个问题需要注意：是否是对称的；是否第传递的；是否是一致的。

自反性和非空性通常会自动满足。

总结：

①覆盖equals总要覆盖hashCode

②不要企图让equals方法过于智能

③不要将equals声明中的Object对象替换为其他的类型

![clipboard.png](http://ovwunej09.bkt.clouddn.com/EF818.png)

这种方法不是重写了equals而是重载了Object