---
title: Effective Java 读书笔记（2.1）
date: 2017-07-04 23:53:42
tags: [Effective java, java, 读书笔记]
categories: [Java]
---

第二章 创建和销毁对象

**第6条.消除过期的对象引用**

### 内存泄漏的一个原因----过期的对象引用

![clipboard.png](http://ovwunej09.bkt.clouddn.com/EF61.png)

pop()后，从栈中弹出的对象不会被当做垃圾回收，（这些对象只是不能再从栈中取到而已），下标大于等于size的部分，属于对象的过期引用（永远不会被解除的引用），这就造成了内存泄漏。

#### 修复方法

只要对象引用过期，就清空这些引用，pop()像这样修改：

![clipboard.png](http://ovwunej09.bkt.clouddn.com/EF62.png)

这样就清除了过期引用，并且如果以后又被错误地解除引用，程序还会抛出nullPointerException异常。
但**清除对象引用只是一种例外，不是一种规范工作。清除过期引用的最好方法是让包含该引用的变量结束其生命周期。**

**何时应该清除引用？**
在**需要自己管理内存的时候需要格外注意**。比如我们举例的Stack类。存储池中包含了elements数组，垃圾回收期不知道哪些是活动的，哪些是非活动的，所以程序员需要在数组元素变成非活动部分的一部分的时候，手工清空这些数组元素。

### 缓存造成的内存泄漏

对象引用放到缓存中后，很容易被遗忘掉。

#### 解决方案

只要缓存之外有对某个项的**键**的引用，该项就有意义，可以使用WeakHashMap。缓存中的项过期后，他们会被自动删除。

但是 缓存项的生命周期是否有意义
并不是很容易确定，随着时间推移，其中的项会变得越来越没有价值，所以缓存应该时不时清楚掉没用的项，可以使用后台线程（如timer或者scheduledThreadPoolExcutor）来完成。

### 监听器和其他回调

比如在一个API中注册回调，但没有显式的取消注册。
#### 解决方案：
确保回调立即被当作垃圾回收的最佳方法是只保存他们的弱引用，比如，只将他们保存成WeakHashMap中的键。