---
title: Effective Java 读书笔记（2.5）
date: 2017-07-03 22:23:42
tags: [Effective java, java, 读书笔记]
categories: [Java]
---

第二章 创建和销毁对象

**第五条.避免创建不必要的对象**

### ①

![clipboard.png](http://ovwunej09.bkt.clouddn.com/EF50.png)

传进去的参数“stringette"本身就是一个实例，然后又用new新建一个实例。很明显创建了不必要的实例。

![clipboard.png](http://ovwunej09.bkt.clouddn.com/EF51.png)

这种方法，就只会创建一个实例。

### **②**

![clipboard.png](http://ovwunej09.bkt.clouddn.com/EF52.png)

![clipboard.png](http://ovwunej09.bkt.clouddn.com/EF53.png)

TimeZone tz1 = timeZone.getTimeZone("GMT"); // 指定时区
Calendar cal1 = Calendar.getInstance(tz1); // 使用指定的时区和当前语言环境的日历
每次isbabyboomer()被调用的时候，都会创建一个calendar，一个timezone和两个date。
改进：将两个Date声明为static
final，把他们的初始化和Calendar的声明定义一起放到static代码块中。

![clipboard.png](http://ovwunej09.bkt.clouddn.com/ef54.png)

这种方法只在类初始化时创建Date，Calendar，TimeZone一次。不会在每次调用isBabyBoomer()的时候创建这些实例，那么**万一isBabyBoomer()永远不被调用**，不是浪费了BoomStart和BoomEND吗？可以采用延迟初始化的方法进行，也就是第一次调用isBabyBoomer()的时候进行初始化。但书上不建议这么做，认为这会使方法变得更复杂，并且无法带来太大的性能提高。

### ③考虑适配器，也被叫做视图。

Map接口的keySet()返回Map对象的Set视图，视图中包含Map中所以的key。每次调用keySet()返回的都是同样的Set实例。所以当对其中一个返回Set实例进行更改时，其他的Set实例也会被改变。

④JAVA5开始，有一种**创建多余对象的新方法，也就是自动装箱。**基本类型和装箱类型混用，按需要自动装箱或者拆箱，他们的差别变得模糊，但还是有区别。比如以下这个例子：

![clipboard.png](http://ovwunej09.bkt.clouddn.com/EF55.png)

这样程序会构造2\^31个多余的Long实例，在for循环中，每次增加long时，i都会被转为Long实例。如果把sum的声明从Long改成long，会显著提高性能。

建议：**优先使用基本类型而不是装箱基本类型，**以防止无意识的自动装箱。

但是这个条目并不是说要避免创建对象，一些小对象的创建和回收动作是很廉价的，所以通过创建附加的对象，可以提升程序的清晰性、简洁性和功能性。
维护自己的对象池反而不是一种好做法。除非其中的对象非常重量级。（比如android中的bitmap）。维护对象池会增加内存的占用，损害性能，所以进行不要使用轻量级对象池。

对象池的典型用法：数据库连接池。
建立数据库连接代价很昂贵，所以重用对象很有意义。

这个条目讲的是**，应该重用现有对象的时候，不要创建新的对象。**