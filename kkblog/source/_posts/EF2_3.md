---
title: Effective Java 读书笔记（2.3）
date: 2017-06-30 23:32:27
tags: [Effective java, java, 读书笔记]
categories: [Java]
---

第二章 创建和销毁对象

第3条.用私有构造器或者枚举类型强化Singleton属性

JAVA5之前，有两种方法实现singleton：

#### ①公有静态成员是**静态final域：**

![clipboard.png](http://ovwunej09.bkt.clouddn.com/EF07.png)

私有构造器被调用一次，用来实例公有的静态final域Elvis.INSTANCE.

保证了Elivs的全局唯一性。但是特殊权限的客户端通过AccessibleObject.setAccessible方法，再通过反射机制，可以调用私有构造器。

优点：该公有域总是包含相同的对象引用。

#### ②公有静态成员是**静态工厂方法：**

![clipboard.png](http://ovwunej09.bkt.clouddn.com/EF08.png)

优点：1）提供了灵活性，它返回类的唯一实例，但是也可以修改，改成为每个调用该方法的线程返回一个唯一实例。2）与泛型有关。

为了使上面的某种方法实现的singleton类是可序列化的，不能只加上“implements
serializable",还必须声明所有实例都是瞬时（transient）的，并提供一个readResolve方法。否则，每次反序列化一个序列化的实例时，都会创建一个新的实例。为了防止这种情况，还要加上这个方法：

![clipboard.png](http://ovwunej09.bkt.clouddn.com/EF09.png)

JAVA5之后，还有第三种方法实现Singleton，使用枚举类型：

![clipboard.png](http://ovwunej09.bkt.clouddn.com/EF10.png)

该方法与公有域方法相近，不过更加简洁，提供了序列化机制，绝对防止多次实例化（即使面对复杂的序列化或者是反射攻击），**虽然没有广泛使用，但是单元素的枚举类型已经成为实现Singleton的最佳方法。？？？？**