<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="en">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="eventbus,事件总线,观察者模式," />










<meta name="description" content="3.EventBus 由于没有用过，所以先在这里理解一下几个重点名词： event：我们想监听的事件，比如点击按钮，网页请求返回了响应 eventType：我们想监听的事件的类型 subscrible：订阅者，订阅事件的对象，当订阅者订阅的事件发生后，就会执行订阅者的响应函数，onEvent。 使用第一步：在接收消息的activity中(onStart()) EventBus.getDefault">
<meta name="keywords" content="eventbus,事件总线,观察者模式">
<meta property="og:type" content="article">
<meta property="og:title" content="EventBus源码解析(1)">
<meta property="og:url" content="http://yoursite.com/2017/09/10/eventBus/index.html">
<meta property="og:site_name" content="Coco">
<meta property="og:description" content="3.EventBus 由于没有用过，所以先在这里理解一下几个重点名词： event：我们想监听的事件，比如点击按钮，网页请求返回了响应 eventType：我们想监听的事件的类型 subscrible：订阅者，订阅事件的对象，当订阅者订阅的事件发生后，就会执行订阅者的响应函数，onEvent。 使用第一步：在接收消息的activity中(onStart()) EventBus.getDefault">
<meta property="og:locale" content="en">
<meta property="og:updated_time" content="2018-04-04T03:23:05.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="EventBus源码解析(1)">
<meta name="twitter:description" content="3.EventBus 由于没有用过，所以先在这里理解一下几个重点名词： event：我们想监听的事件，比如点击按钮，网页请求返回了响应 eventType：我们想监听的事件的类型 subscrible：订阅者，订阅事件的对象，当订阅者订阅的事件发生后，就会执行订阅者的响应函数，onEvent。 使用第一步：在接收消息的activity中(onStart()) EventBus.getDefault">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2017/09/10/eventBus/"/>





  <title>EventBus源码解析(1) | Coco</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Coco</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Hello world</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/10/eventBus/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ke Yu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Coco">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">EventBus源码解析(1)</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-09-10T20:19:30+08:00">
                2017-09-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p><strong>3.EventBus</strong></p>
<p>由于没有用过，所以先在这里理解一下几个重点名词：</p>
<p>event：我们想监听的事件，比如点击按钮，网页请求返回了响应</p>
<p>eventType：我们想监听的事件的类型</p>
<p>subscrible：订阅者，订阅事件的对象，当订阅者订阅的事件发生后，就会执行订阅者的响应函数，onEvent。</p>
<p><strong>使用第一步：在接收消息的activity中(onStart())</strong></p>
<p><strong>EventBus.getDefault().register(this); —>B</strong></p>
<p><strong>字母开头和1字母开头的，都是rigister的延伸。</strong></p>
<p><strong>使用第二步：在发送消息的activity中，</strong></p>
<p><strong>EventBus.getDefault().post(new Event(“Event btn clicked”)); ——>2A</strong></p>
<p><strong>2字母开头的，都是这个的延伸。</strong></p>
<p><strong>使用第三步：在接收消息的activity中（onStop())</strong></p>
<p><strong>EventBus.getDefault().unregister(this);——->3A</strong></p>
<p><strong>①EventBus.JAVA</strong></p>
<p><strong>A.</strong></p>
<p>单例模式，双重检查+volatile ，获取eventBus的实例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">volatile</span> EventBus defaultInstance;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> EventBus <span class="title">getDefault</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (defaultInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">synchronized</span> (EventBus.class) &#123;</span><br><span class="line">			<span class="keyword">if</span> (defaultInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">				defaultInstance = <span class="keyword">new</span> EventBus();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> defaultInstance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>3A.</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Unregisters the given subscriber from all event classes. 这是通过订阅者找出订阅类型来注销这个订阅者的所有订阅*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">unregister</span><span class="params">(Object subscriber)</span> </span>&#123;</span><br><span class="line"><span class="comment">//取出订阅者订阅的所有事件类型</span></span><br><span class="line">List&lt;Class&lt;?&gt;&gt; subscribedTypes = typesBySubscriber.get(subscriber);</span><br><span class="line">	<span class="keyword">if</span> (subscribedTypes != <span class="keyword">null</span>) &#123;</span><br><span class="line">	<span class="comment">//遍历所有事件类型，注销订阅</span></span><br><span class="line">	<span class="keyword">for</span> (Class&lt;?&gt; eventType : subscribedTypes) &#123;</span><br><span class="line">		unsubscribeByEventType(subscriber, eventType);----&gt;<span class="number">3</span>B</span><br><span class="line">	&#125;</span><br><span class="line">	typesBySubscriber.remove(subscriber);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123; <span class="comment">//这个订阅者没有订阅过任何事件。</span></span><br><span class="line">	但是，没有订阅过，有可能register啊...？？？？</span><br><span class="line">	Log.w(TAG, <span class="string">"Subscriber to unregister was not registered before: "</span> + subscriber.getClass());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>3B.</strong></p>
<p><strong>更新subscriptionsByEventType，而不是typesBySubscriber，typesBySubscriber在3A中（unregister)更新了</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Only updates subscriptionsByEventType, not typesBySubscriber! Caller must</span></span><br><span class="line"><span class="comment">update typesBySubscriber. 这是通过事件类型找出所有订阅者来取消订阅*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unsubscribeByEventType</span><span class="params">(Object subscriber, Class&lt;?&gt; eventType)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//通过事件类型取出订阅该类型的所有subscriptions，**注意，定义的时候，value是copyOnWriteList,这里就直接List了？？**</span></span><br><span class="line">List&lt;Subscription&gt; subscriptions =</span><br><span class="line">subscriptionsByEventType.get(eventType);</span><br><span class="line">	<span class="keyword">if</span> (subscriptions != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">int</span> size = subscriptions.size();</span><br><span class="line"><span class="comment">//遍历subscription,找到当前要注销的subcriber，更改active状态，并且从这个list中将它移出</span></span><br><span class="line"><span class="comment">// 这个find并且remove的过程- -真是清新自然，没有更简单的方法？？</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">			Subscription subscription = subscriptions.get(i);</span><br><span class="line">			<span class="keyword">if</span> (subscription.subscriber == subscriber) &#123;</span><br><span class="line">				subscription.active = <span class="keyword">false</span>;</span><br><span class="line">				subscriptions.remove(i);</span><br><span class="line">				i--;</span><br><span class="line">				size--;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2A.</strong></p>
<p><strong>从这里到2I，都是这个函数的延伸。</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">post</span><span class="params">(Object event)</span> </span>&#123;</span><br><span class="line">	PostingThreadState postingState =</span><br><span class="line">	currentPostingThreadState.get();---&gt;<span class="number">2</span>B</span><br><span class="line">	List&lt;Object&gt; eventQueue = postingState.eventQueue; <span class="comment">//postingThread的queue</span></span><br><span class="line">	eventQueue.add(event); <span class="comment">//向这个List添加事件</span></span><br><span class="line">	<span class="keyword">if</span> (!postingState.isPosting) &#123;</span><br><span class="line">		<span class="comment">//这个boolean值，都没有被赋值过...所以是取默认值？？boolean的默认值是false，所以就说得通了。</span></span><br><span class="line">		<span class="comment">//判断进行post的线程是否主线程</span></span><br><span class="line">		postingState.isMainThread = Looper.getMainLooper() == Looper.myLooper();</span><br><span class="line">		<span class="comment">//当前线程的isPosting为真</span></span><br><span class="line">		postingState.isPosting = <span class="keyword">true</span>;</span><br><span class="line">		<span class="comment">//如果取消了，抛出异常。</span></span><br><span class="line">		<span class="keyword">if</span> (postingState.canceled) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">"Internal error. Abort state was not reset"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">while</span> (!eventQueue.isEmpty()) &#123;</span><br><span class="line">				<span class="comment">//如果当前线程要post的事件队列不为空，取出队首，执行了postSingleEventForEventType，然后在里面又执行了postToSubscription，完成了post</span></span><br><span class="line">				postSingleEvent(eventQueue.remove(<span class="number">0</span>), postingState);---&gt;<span class="number">2</span>D</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			<span class="comment">//finally里面初始化成员变量</span></span><br><span class="line">			postingState.isPosting = <span class="keyword">false</span>;</span><br><span class="line">			postingState.isMainThread = <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>2D.</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postSingleEvent</span><span class="params">(Object event, PostingThreadState postingState)</span> <span class="keyword">throws</span> Error </span>&#123;</span><br><span class="line">	Class&lt;?&gt; eventClass = event.getClass();</span><br><span class="line">	<span class="keyword">boolean</span> subscriptionFound = <span class="keyword">false</span>;</span><br><span class="line">	<span class="keyword">if</span> (eventInheritance) &#123;</span><br><span class="line">	List&lt;Class&lt;?&gt;&gt; eventTypes = lookupAllEventTypes(eventClass);---&gt;<span class="number">2</span>E,得到这个eventClass的所有超类和父接口（也就是它可以对应的所有事件类型）</span><br><span class="line">	<span class="keyword">int</span> countTypes = eventTypes.size();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> h = <span class="number">0</span>; h &lt; countTypes; h++) &#123;</span><br><span class="line">			Class&lt;?&gt; clazz = eventTypes.get(h);</span><br><span class="line">			subscriptionFound |= postSingleEventForEventType(event, postingState, clazz);----&gt;<span class="number">2</span>G，在postSingleEventForEventType里面遍历所有监听了这个事件类型的subcription,通过postToSubscription去找线程调用订阅者的响应方法</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123; <span class="comment">//没有进入else，就直接调用postSingleEventForEventType	</span></span><br><span class="line">		subscriptionFound = postSingleEventForEventType(event, postingState, eventClass);----&gt;<span class="number">2</span>G</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!subscriptionFound) &#123;<span class="comment">//如果</span></span><br><span class="line">postSingleEventForEventType没执行成功，也就是这个事件没有订阅者订阅这类事件！！</span><br><span class="line">		<span class="keyword">if</span> (logNoSubscriberMessages) &#123;</span><br><span class="line">			Log.d(TAG, <span class="string">"No subscribers registered for event "</span> + eventClass);</span><br><span class="line">		&#125;</span><br><span class="line"><span class="comment">//这个判断有点奇怪。 eventClass 和 NoSubscriberEvent.class</span></span><br><span class="line">,怎么可能相等...不过看到post(<span class="keyword">new</span>...）就明白了，最开始的时候当然都是！=，不过重新<span class="keyword">new</span>了NoSubscriberEvent去post，当然可能==了。</span><br><span class="line">		<span class="keyword">if</span> (sendNoSubscriberEvent &amp;&amp; eventClass != NoSubscriberEvent.class &amp;&amp; eventClass != SubscriberExceptionEvent.class) &#123;----&gt;<span class="number">2</span>H，<span class="number">2</span>I</span><br><span class="line">			post(<span class="keyword">new</span> NoSubscriberEvent(<span class="keyword">this</span>,event));<span class="comment">//用当前类（调用post的类）和被post的event构造NoSubscriberEvent，所以有可能出现if中的第二种情况!!厉害了。但是第三种呢？？</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2H.</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 被post的事件没有订阅者订阅 哈哈哈哈哈 好惨</span></span><br><span class="line"><span class="comment"> This Event is posted by EventBus when no subscriber is found for a posted event.</span></span><br><span class="line"><span class="comment"> @author Markus</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NoSubscriberEvent</span> </span>&#123;</span><br><span class="line"><span class="comment">/* The &#123;\@link EventBus&#125; instance to with the original event was posted to.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">final</span> EventBus eventBus;</span><br><span class="line">	<span class="comment">/* The original event that could not be delivered to any subscriber. */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">final</span> Object originalEvent;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">NoSubscriberEvent</span><span class="params">(EventBus eventBus, Object originalEvent)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.eventBus = eventBus;</span><br><span class="line">		<span class="keyword">this</span>.originalEvent = originalEvent;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2I.</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 这个post的事件在订阅者响应函数中出现异常（需要理解下...</span></span><br><span class="line"><span class="comment"> This Event is posted by EventBus when an exception occurs inside a subscriber's event handling method.*</span></span><br><span class="line"><span class="comment"> @author Markus*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SubscriberExceptionEvent</span> </span>&#123;</span><br><span class="line"><span class="comment">/* The &#123;\@link EventBus&#125; instance to with the original event was posted to.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">final</span> EventBus eventBus;</span><br><span class="line">	<span class="comment">/* The Throwable thrown by a subscriber.*/</span></span><br><span class="line">	<span class="comment">//订阅者抛出的异常</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">final</span> Throwable throwable;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* The original event that could not be delivered to any subscriber. */</span></span><br><span class="line">	<span class="comment">//无法再被post给任何订阅者的event</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">final</span> Object causingEvent;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* The subscriber that threw the Throwable. */</span></span><br><span class="line">	<span class="comment">//抛出异常的订阅者</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">final</span> Object causingSubscriber;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">SubscriberExceptionEvent</span><span class="params">(EventBus eventBus, Throwable throwable,Object causingEvent,Object causingSubscriber)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.eventBus = eventBus;</span><br><span class="line">		<span class="keyword">this</span>.throwable = throwable;</span><br><span class="line">		<span class="keyword">this</span>.causingEvent = causingEvent;</span><br><span class="line">		<span class="keyword">this</span>.causingSubscriber = causingSubscriber;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2G.</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">postSingleEventForEventType</span><span class="params">(Object event, PostingThreadState postingState, Class&lt;?&gt; eventClass)</span> </span>&#123;</span><br><span class="line">	CopyOnWriteArrayList&lt;Subscription&gt; subscriptions;</span><br><span class="line">	<span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">	<span class="comment">//取出这个事件class所涉及的所有subscription(里面存储了订阅者和处理这个事件的方法）</span></span><br><span class="line">		subscriptions = subscriptionsByEventType.get(eventClass);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 这个if里面，不是一个意思？？？</span></span><br><span class="line">	<span class="comment">// 存在订阅这种事件类型的订阅者</span></span><br><span class="line">	<span class="keyword">if</span> (subscriptions != <span class="keyword">null</span> &amp;&amp; !subscriptions.isEmpty()) &#123;</span><br><span class="line">		<span class="keyword">for</span> (Subscription subscription : subscriptions) &#123;</span><br><span class="line">			<span class="comment">//遍历所有的subscription,设置postingState的参数</span></span><br><span class="line">			postingState.event = event;</span><br><span class="line">			postingState.subscription = subscription;</span><br><span class="line">			<span class="keyword">boolean</span> aborted = <span class="keyword">false</span>;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				postToSubscription(subscription, event,postingState.isMainThread);----&gt;<span class="number">1</span>D,在subscribe(..）粘性事件那里分析过了，所以那里的疑惑就解决了....那里的post是由于“粘性”立即post最近的event给订阅者，这里的postToSubscription是发送信息的一方直接调用post导致的</span><br><span class="line">				aborted = postingState.canceled; <span class="comment">//判断是否abort</span></span><br><span class="line">			&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">				<span class="comment">//当前状态的变量置为null，由于if可能结束循环，所以在finally中置空，避免内存泄漏。个人觉得...为什么不直接for循环外面置空，一定要置空了再赋值？？</span></span><br><span class="line">				postingState.event = <span class="keyword">null</span>;</span><br><span class="line">				postingState.subscription = <span class="keyword">null</span>;</span><br><span class="line">				postingState.canceled = <span class="keyword">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (aborted) &#123;</span><br><span class="line">				<span class="keyword">break</span>;<span class="comment">//如果abort了，那么这个事件的post就结束了</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//for循环结束，返回true</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//没进入if，返回false</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>2E.</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Looks up all Class objects including super classes and interfaces. Should also work for interfaces. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;Class&lt;?&gt;&gt; lookupAllEventTypes(Class&lt;?&gt; eventClass)&#123;</span><br><span class="line">	<span class="keyword">synchronized</span> (eventTypesCache) &#123;</span><br><span class="line">		<span class="comment">//从事件类的缓存中，根据事件class取出队列</span></span><br><span class="line">		List&lt;Class&lt;?&gt;&gt; eventTypes = eventTypesCache.get(eventClass);</span><br><span class="line">		<span class="keyword">if</span> (eventTypes == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="comment">//如果没有该类型的event，新建List</span></span><br><span class="line">			eventTypes = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">			Class&lt;?&gt; clazz = eventClass;</span><br><span class="line">			<span class="keyword">while</span> (clazz != <span class="keyword">null</span>) &#123;</span><br><span class="line">				eventTypes.add(clazz); <span class="comment">// 把当前事件类加到这个list中</span></span><br><span class="line">				<span class="comment">//clazz.getInterfaces(),又是反射机制，可以获得这个class实现自哪些接口。</span></span><br><span class="line">				addInterfaces(eventTypes,clazz.getInterfaces());---&gt;<span class="number">2F</span>，递归获得事件类的所有父接口，加到eventTypes这个list中</span><br><span class="line">				clazz = clazz.getSuperclass();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//然后把这个eventClass以及它可以对应的所有事件类型（List集合保存)加入cache</span></span><br><span class="line">			eventTypesCache.put(eventClass, eventTypes);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> eventTypes;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>2F.</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Recurses through super interfaces. */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addInterfaces</span><span class="params">(List&lt;Class&lt;?&gt;&gt; eventTypes, Class&lt;?&gt;[]</span></span></span><br><span class="line"><span class="function"><span class="params">interfaces)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (Class&lt;?&gt; interfaceClass : interfaces) &#123;</span><br><span class="line">	<span class="comment">//遍历事件类实现的接口，如果这个事件类型的List中不包含有这个接口</span></span><br><span class="line">		<span class="keyword">if</span> (!eventTypes.contains(interfaceClass)) &#123;</span><br><span class="line">			eventTypes.add(interfaceClass);<span class="comment">// 把这个接口添加进list</span></span><br><span class="line">		<span class="comment">// 继续用interfaceClass.getInterfaces()得到interfaceClass实现的接口</span></span><br><span class="line">		<span class="comment">//迭代这个方法</span></span><br><span class="line">			addInterfaces(eventTypes, interfaceClass.getInterfaces());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>2B</strong>.一个成员变量，<strong>PostingThreadState类型—&gt;2C</strong>的ThreadLocal<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ThreadLocal&lt;PostingThreadState&gt;</span><br><span class="line">currentPostingThreadState = <span class="keyword">new</span> ThreadLocal&lt;PostingThreadState&gt;() &#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> PostingThreadState <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//这个ThreadLocal的初始化就是new一个新的PostingThreadState();</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> PostingThreadState();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><strong>2C.一个静态常量内部类</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* For ThreadLocal, much faster to set (and get multiple values). */</span></span><br><span class="line"><span class="comment">//为了ThreadLocal可以更快的set和get？这里就是之前看threadLocal时提到的，postingThreadState用到了threadLocal</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PostingThreadState</span> </span>&#123;</span><br><span class="line">	<span class="keyword">final</span> List&lt;Object&gt; eventQueue = <span class="keyword">new</span> ArrayList&lt;Object&gt;();</span><br><span class="line">	<span class="keyword">boolean</span> isPosting;</span><br><span class="line">	<span class="keyword">boolean</span> isMainThread;</span><br><span class="line">	Subscription subscription;</span><br><span class="line">	Object event;</span><br><span class="line">	<span class="keyword">boolean</span> canceled;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>B</strong>.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(Object subscriber)</span> </span>&#123;</span><br><span class="line"><span class="comment">//首先通过反射，获取订阅者的类</span></span><br><span class="line">Class&lt;?&gt; subscriberClass = subscriber.getClass();</span><br><span class="line"><span class="comment">// 然后通过类，找类的方法，不是简单的用getMethod()</span></span><br><span class="line">List\&lt;SubscriberMethod\&gt; subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriberClass);---&gt;C，C~S都是这个函数的延伸，主要是两种方法来查找订阅者的方法</span><br><span class="line">	<span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">		<span class="keyword">for</span> (SubscriberMethod subscriberMethod : subscriberMethods) &#123;</span><br><span class="line">			<span class="comment">// 遍历订阅者的方法，然后执行subscribe---&gt;1A，重点就是处理subscriberMethod，其实不知道放进去在哪一步被执行...</span></span><br><span class="line">			subscribe(subscriber, subscriberMethod);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>1A.</strong><br><strong>1开头的，都是这个函数延伸出去的调用。</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 涉及到数据结构：private final Map&lt;Class&lt;?&gt;, CopyOnWriteArrayList&lt;Subscription&gt;&gt; subscriptionsByEventType;</span></span><br><span class="line"><span class="comment">/* Must be called in synchronized block*</span></span><br><span class="line"><span class="comment">*订阅者subscriber*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(Object subscriber, SubscriberMethod subscriberMethod)</span></span>&#123;</span><br><span class="line">	<span class="comment">//订阅者的方法要订阅的事件类</span></span><br><span class="line">	Class&lt;?&gt; eventType = subscriberMethod.eventType;</span><br><span class="line">	Subscription newSubscription = <span class="keyword">new</span> Subscription(subscriber,</span><br><span class="line">	subscriberMethod);---&gt;<span class="number">1</span>B,封装了这个订阅者和订阅者的响应函数以及是否订阅这三个信息</span><br><span class="line">	CopyOnWriteArrayList&lt;Subscription&gt; subscriptions =</span><br><span class="line">	subscriptionsByEventType.get(eventType); </span><br><span class="line">	<span class="comment">//根据eventType取出订阅这个情况的所有订阅情况</span></span><br><span class="line">	<span class="keyword">if</span> (subscriptions == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="comment">//如果这个event还从未被订阅，自然新建一个它所对应的subscription</span></span><br><span class="line">		subscriptions = <span class="keyword">new</span> CopyOnWriteArrayList&lt;&gt;();	</span><br><span class="line">		subscriptionsByEventType.put(eventType, subscriptions);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">//如果这个订阅关系已经存在， 抛出异常。Subscriber..already registered to event，和自己理解的一样~~~~ 开心</span></span><br><span class="line">		<span class="keyword">if</span> (subscriptions.contains(newSubscription)) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">"Subscriber "</span> + subscriber.getClass() +<span class="string">"already registered to event "</span>+ eventType);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 这个事件有多少个订阅方法（\@subscribe的方法或者onEvent..)</span></span><br><span class="line">	<span class="keyword">int</span> size = subscriptions.size();</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= size; i++) &#123;</span><br><span class="line">		<span class="comment">// 如果当前这个订阅方法的优先级比当前这个订阅方法的优先级高，就把它加入到第i位（也就是倒数第二位），然后break。</span></span><br><span class="line">		<span class="comment">// 如果直接到了size，说明当前方法优先级最低，直接插入尾部。</span></span><br><span class="line">		<span class="keyword">if</span> (i == size || subscriberMethod.priority &gt; subscriptions.get(i).subscriberMethod.priority) &#123;</span><br><span class="line">			subscriptions.add(i, newSubscription);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//涉及到private final Map&lt;Object, List&lt;Class&lt;?&gt;&gt;&gt; typesBySubscriber;</span></span><br><span class="line">	<span class="comment">//查看这个订阅者要订阅的事件类型</span></span><br><span class="line">	List&lt;Class&lt;?&gt;&gt; subscribedEvents = typesBySubscriber.get(subscriber);</span><br><span class="line">	<span class="keyword">if</span> (subscribedEvents == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="comment">//原来这个subscriber没有订阅过事件，那么现在增加订阅者的 subscribedEvents(是一个list）</span></span><br><span class="line">		subscribedEvents = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		typesBySubscriber.put(subscriber, subscribedEvents);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//不管subscriber是否订阅过事件,都把这个事件类型加入到这个subscriber的订阅事件列表中</span></span><br><span class="line">	subscribedEvents.add(eventType);</span><br><span class="line">	<span class="comment">//如果这个响应函数是粘性的。 如果不是粘性的？？哪里涉及到线程去执行？</span></span><br><span class="line">	<span class="comment">//个人理解：</span></span><br><span class="line">	这是<span class="number">3.0</span>增加的新特性：从代码可以看出stickyEvents的entry，其实是一个map，map的key是事件类型（<span class="class"><span class="keyword">class</span>\&lt;?\&gt;），<span class="title">value</span>是事件实例(<span class="title">Object</span>),由于是粘性事件，那么，当这个<span class="title">subscriberMethod</span>订阅这个事件类型，就把最近的事件类型的事件（<span class="title">Object</span>)</span></span><br><span class="line"><span class="class">通过<span class="title">checkPostStickyEventToSubscription</span>立刻将这个事件找到对应的处理线程，进行排队（有可能排）后，由对应的<span class="title">subcriberMethod</span>进行处理。</span></span><br><span class="line"><span class="class">	<span class="title">if</span> (<span class="title">subscriberMethod</span>.<span class="title">sticky</span>) </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (eventInheritance) &#123;</span><br><span class="line">		<span class="comment">/* Existing sticky events of all subclasses of eventType have to be</span></span><br><span class="line"><span class="comment">		considered.这个事件类型的所有子类的粘性事件都要考虑</span></span><br><span class="line"><span class="comment">		Note: Iterating over all events may be inefficient with lots of sticky events, 如果粘性事件比较多，遍历所有的事件可能不够高效</span></span><br><span class="line"><span class="comment">		thus data structure should be changed to allow a more efficient lookup*应该更改数据结构，进行更高效的遍历  (e.g. an additional map storing sub classes of super classes: Class -&gt; List&lt;Class&gt;).*/</span></span><br><span class="line">			Set&lt;Map.Entry&lt;Class&lt;?&gt;, Object&gt;&gt; entries = stickyEvents.entrySet();</span><br><span class="line">		    <span class="comment">//取出保存粘性事件的set</span></span><br><span class="line">			<span class="keyword">for</span> (Map.Entry&lt;Class&lt;?&gt;, Object&gt; entry : entries) &#123;</span><br><span class="line">			<span class="comment">//遍历set中每个元素，取出每个元素的key，也就是事件类型class&lt;?&gt;</span></span><br><span class="line">				Class&lt;?&gt; candidateEventType = entry.getKey();</span><br><span class="line">				<span class="comment">//如果当前订阅方法监听的事件类型，是之前存在的事件的 父类</span></span><br><span class="line">				<span class="keyword">if</span> (eventType.isAssignableFrom(candidateEventType)) &#123;</span><br><span class="line">					<span class="comment">// 取出value,也就是这个事件类型的实例</span></span><br><span class="line">					Object stickyEvent = entry.getValue();</span><br><span class="line">					checkPostStickyEventToSubscription(newSubscription, stickyEvent);----&gt;<span class="number">1</span>C</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			Object stickyEvent = stickyEvents.get(eventType);</span><br><span class="line">			checkPostStickyEventToSubscription(newSubscription, stickyEvent);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>1C. 主要是调用了postToSubscription，选择了合适的线程，执行了post</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkPostStickyEventToSubscription</span><span class="params">(Subscription</span></span></span><br><span class="line"><span class="function"><span class="params">newSubscription, Object stickyEvent)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (stickyEvent != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="comment">/*If the subscriber is trying to abort the event, it will fail (event is not tracked in posting state) 如果订阅者想阻止这个事件，将会失败--&gt; Strange corner case, which we don't take care of here.奇怪的case，我们不用在意？？？ 这注释有点迷...*/</span></span><br><span class="line">		postToSubscription(newSubscription, stickyEvent, Looper.getMainLooper() == Looper.myLooper());---&gt;<span class="number">1</span>D,真正处理event的函数（终于涉及了线程），赞！</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>1D.根据订阅者方法的threadMode，决定这个方法由哪个线程执行。</strong></p>
<p><strong>由各个poster去处理pengdingPost，可能由handler执行，也可能是线程池去执行runnable</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postToSubscription</span><span class="params">(Subscription subscription, Object event,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">boolean</span> isMainThread)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">switch</span> (subscription.subscriberMethod.threadMode) &#123;</span><br><span class="line">		<span class="keyword">case</span> POSTING:</span><br><span class="line">			invokeSubscriber(subscription,event);---&gt;<span class="number">1</span>E，通过java反射机制，使用method.invoke()调用了subscirber对象中的参数为event订阅方法</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> MAIN:</span><br><span class="line">			<span class="keyword">if</span> (isMainThread) &#123;</span><br><span class="line">				<span class="comment">//如果当前就是主线程，那么就当前线程执行subscription.subscriberMethod</span></span><br><span class="line">				invokeSubscriber(subscription, event);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">//mainThreadPoster = new HandlerPoster(this, Looper.getMainLooper(), 10);有主线程的looper</span></span><br><span class="line">				mainThreadPoster.enqueue(subscription, event);----&gt;<span class="number">1F</span>，插入给主线程的handler，会将这个事件和方法放入queue，等待主线程执行，如果主线程的queue之前为空，那么就直接sendMsg。</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> BACKGROUND:</span><br><span class="line">			<span class="keyword">if</span> (isMainThread) &#123;</span><br><span class="line">				<span class="comment">//backgroundPoster = new BackgroundPoster(this);同理，这是后台线程的handler</span></span><br><span class="line">				backgroundPoster.enqueue(subscription, event);---&gt;<span class="number">1</span>I</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">//如果当前线程不是主线程，就直接用当前线程执行，invokeSubscriber是当前的eventBus中的函数</span></span><br><span class="line">				invokeSubscriber(subscription, event);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> ASYNC:</span><br><span class="line">			asyncPoster.enqueue(subscription, event);---&gt;<span class="number">1</span>J</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Unknown thread mode: "</span> + subscription.subscriberMethod.threadMode);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>1E.</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">invokeSubscriber</span><span class="params">(Subscription subscription, Object event)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">//method.invoke(Object obj, Object... args) 是反射机制的一个函数</span></span><br><span class="line">		<span class="comment">//对这个指定的对象obj，调用方法method，args是这个方法需要的参数数组。</span></span><br><span class="line">		<span class="comment">//也就是，调用subscriber这个对象的subscription.subscriberMethod.method方法，其中event是这个方法的参数...JAVA反射好厉害-</span></span><br><span class="line">		subscription.subscriberMethod.method.invoke(subscription.subscriber, event);</span><br><span class="line">	&#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">		handleSubscriberException(subscription, event, e.getCause());</span><br><span class="line">	&#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Unexpected exception"</span>, e);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>1K. 差点以为是1E…</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">invokeSubscriber</span><span class="params">(PendingPost pendingPost)</span> </span>&#123;</span><br><span class="line">	Object event = pendingPost.event; <span class="comment">//取出这个post对应的event obj</span></span><br><span class="line">	<span class="comment">//再取出对应的订阅信息</span></span><br><span class="line">	Subscription subscription = pendingPost.subscription;</span><br><span class="line">	PendingPost.releasePendingPost(pendingPost);----&gt;<span class="number">1L</span></span><br><span class="line">	<span class="keyword">if</span> (subscription.active) &#123;</span><br><span class="line">	<span class="comment">//这个变量注释就说是这里会用到，为了避免race conditions（资源竞争）</span></span><br><span class="line">		invokeSubscriber(subscription, event);---&gt;<span class="number">1</span>E</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>SubscriberMethodFinder.JAVA</strong></p>
<p><strong>C.</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">List&lt;SubscriberMethod&gt; <span class="title">findSubscriberMethods</span><span class="params">(Class&lt;?&gt; subscriberClass)</span></span>&#123;</span><br><span class="line">	<span class="comment">//先直接从缓存中取</span></span><br><span class="line">	List&lt;SubscriberMethod&gt; subscriberMethods = METHOD_CACHE.get(subscriberClass);</span><br><span class="line">	<span class="keyword">if</span> (subscriberMethods != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> subscriberMethods;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//如果没有的话，判断是否要忽略注解器：</span></span><br><span class="line">	<span class="keyword">if</span> (ignoreGeneratedIndex) &#123;</span><br><span class="line">		<span class="comment">//忽略的话，用反射来获取类的方法信息</span></span><br><span class="line">		subscriberMethods = findUsingReflection(subscriberClass);---&gt;D</span><br><span class="line">		<span class="comment">/*D~N，都是利用反射找方法的过程，主要是通过findState，把subscriberClass放进去，找到对应方法，再找它的父类，依次向上。总体来说findUsingReflection就是一个while循环遍历所有相关类，根据类找方法时需要用到反射和注解...*/</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		subscriberMethods = findUsingInfo(subscriberClass); ---&gt;O</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (subscriberMethods.isEmpty()) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">"Subscriber "</span> + subscriberClass + <span class="string">" and its super classes have no public methods with the \@Subscribe annotation"</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		METHOD_CACHE.put(subscriberClass, subscriberMethods);</span><br><span class="line">		<span class="keyword">return</span> subscriberMethods;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>P.</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> SubscriberInfo <span class="title">getSubscriberInfo</span><span class="params">(FindState findState)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 看描述subscriberInfo本来就一直为null啊... 是一个接口的变量</span></span><br><span class="line">	<span class="comment">// getSuperSubscriberInfo()是接口的一个函数，AbstractSubscriberInfo是接口实现</span></span><br><span class="line">	<span class="keyword">if</span> (findState.subscriberInfo != <span class="keyword">null</span> &amp;&amp; findState.subscriberInfo.getSuperSubscriberInfo() != <span class="keyword">null</span>) &#123; ----&gt;Q</span><br><span class="line">		<span class="comment">//如果订阅者信息不为空且订阅者信息子类不为空</span></span><br><span class="line">		SubscriberInfo superclassInfo = findState.subscriberInfo.getSuperSubscriberInfo();</span><br><span class="line">		<span class="comment">//如果findstate当前的clazz和订阅者子类一样，返回这个子类信息。</span></span><br><span class="line">		<span class="keyword">if</span> (findState.clazz == superclassInfo.getSubscriberClass()) &#123;</span><br><span class="line">			<span class="keyword">return</span> superclassInfo;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//如果订阅者信息下标不为空（是一个List),那么遍历List，通过index取出clazz的信息，并返回。</span></span><br><span class="line">	<span class="keyword">if</span> (subscriberInfoIndexes != <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">for</span> (SubscriberInfoIndex index : subscriberInfoIndexes) &#123;</span><br><span class="line">			SubscriberInfo info = index.getSubscriberInfo(findState.clazz);</span><br><span class="line">			<span class="keyword">if</span> (info != <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">return</span> info;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>O.看看和DList<subscribermethod> findUsingReflection(Class&lt;?&gt;<br>subscriberClass)有什么不同</subscribermethod></strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> List&lt;SubscriberMethod&gt; <span class="title">findUsingInfo</span><span class="params">(Class&lt;?&gt; subscriberClass)</span> </span>&#123;</span><br><span class="line">	FindState findState = prepareFindState(); <span class="comment">// same</span></span><br><span class="line">	findState.initForSubscriber(subscriberClass); <span class="comment">// same</span></span><br><span class="line">	<span class="keyword">while</span> (findState.clazz != <span class="keyword">null</span>) &#123; <span class="comment">// same</span></span><br><span class="line">		findState.subscriberInfo =</span><br><span class="line">getSubscriberInfo(findState);---&gt;P,经过PQ，取到订阅者的信息</span><br><span class="line">		<span class="keyword">if</span> (findState.subscriberInfo != <span class="keyword">null</span>) &#123; <span class="comment">//订阅者信息不为空</span></span><br><span class="line">			SubscriberMethod[] array = findState.subscriberInfo.getSubscriberMethods();---&gt;R<span class="comment">//调用接口函数，根据方法信息构建方法，并返回</span></span><br><span class="line">		<span class="keyword">for</span> (SubscriberMethod subscriberMethod : array) &#123;</span><br><span class="line">		<span class="comment">// 遍历方法，但是否能将订阅者方法和要监听的事件类型添加到findState中</span></span><br><span class="line">			<span class="keyword">if</span> (findState.checkAdd(subscriberMethod.method, subscriberMethod.eventType)) &#123;</span><br><span class="line">			<span class="comment">// 将这个方法加入到findState的list中去</span></span><br><span class="line">				findState.subscriberMethods.add(subscriberMethod);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="comment">//订阅者信息为空，那就通过这个方法，用反射得到findState.clazz的相关信息，并构造订阅方法（new SubscriberMethod（....)），add进findState中</span></span><br><span class="line">		findUsingReflectionInSingleClass(findState);</span><br><span class="line">	&#125;</span><br><span class="line">	findState.moveToSuperclass(); <span class="comment">//继续往上找</span></span><br><span class="line">&#125;</span><br><span class="line">	<span class="keyword">return</span> getMethodsAndRelease(findState); <span class="comment">//释放这个findState</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">D.</span><br><span class="line"><span class="function"><span class="keyword">private</span> List&lt;SubscriberMethod&gt; <span class="title">findUsingReflection</span><span class="params">(Class&lt;?&gt;</span></span></span><br><span class="line"><span class="function"><span class="params">subscriberClass)</span> </span>&#123;</span><br><span class="line">	FindState findState = prepareFindState();----&gt;E,得到一个FindState</span><br><span class="line">	findState.initForSubscriber(subscriberClass);---&gt;F,为这个findstate赋值它记在的订阅类，也就是subscriberClass，这是起点，此时findState中的clazz就是它</span><br><span class="line">	<span class="keyword">while</span> (findState.clazz != <span class="keyword">null</span>) &#123;</span><br><span class="line">		findUsingReflectionInSingleClass(findState);----&gt;G</span><br><span class="line">	<span class="comment">/*G到K，终于把subscriberClass里面的订阅方法加入到相应的findState了</span></span><br><span class="line"><span class="comment">	findState.moveToSuperclass();---&gt;L,把findState的clazz换成clazz的父类（超类不能为系统类）</span></span><br><span class="line"><span class="comment">	注意这是一个while循环，所以是从子类开始一直向上，把相应clazz的方法加入到findState*/</span></span><br><span class="line">&#125;</span><br><span class="line">	<span class="keyword">return</span> getMethodsAndRelease(findState);-----&gt;M，释放findstate,<span class="keyword">while</span>循环结束它就功成身退了，把它还给statePool</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>E.从findStatePool中取出第一个不为空的state，取出后把池中这个位置的state置为空。<br>有可能池为空，那么直接new一个FindState();</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> FindState <span class="title">prepareFindState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">synchronized</span> (FIND_STATE_POOL) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; POOL_SIZE; i++) &#123;	</span><br><span class="line">			FindState state = FIND_STATE_POOL[i];</span><br><span class="line">			<span class="keyword">if</span> (state != <span class="keyword">null</span>) &#123;</span><br><span class="line">				FIND_STATE_POOL[i] = <span class="keyword">null</span>;</span><br><span class="line">				<span class="keyword">return</span> state;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> FindState();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>G.利用反射原理取出当前findState中的订阅类的方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">findUsingReflectionInSingleClass</span><span class="params">(FindState findState)</span> </span>&#123;</span><br><span class="line">	Method[] methods;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">	<span class="comment">// This is faster than getMethods, especially when subscribers are fat classes</span></span><br><span class="line">	like Activities</span><br><span class="line">	<span class="comment">/*getMethods()返回某个类的所有公用（public）方法包括其继承类的公用方法，当然也包括它所实现接口的方法。getDeclaredMethods()对象表示的类或接口声明的所有方法，包括公共、保护、默认（包）访问和私有方法，但不包括继承的方法。当然也包括它所实现接口的方法。*/</span></span><br><span class="line">	methods = findState.clazz.getDeclaredMethods();</span><br><span class="line">	&#125; <span class="keyword">catch</span> (Throwable th) &#123;</span><br><span class="line">	<span class="comment">/* Workaround for java.lang.NoClassDefFoundError, see</span></span><br><span class="line"><span class="comment">	https://github.com/greenrobot/EventBus/issues/149*</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">		methods = findState.clazz.getMethods();</span><br><span class="line">		findState.skipSuperClasses = <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">	<span class="comment">//返回类或接口的以整数编码的JAVA语言修饰符，比如得到整数i=1，那么Modefier.toString(i)可以得到String的public</span></span><br><span class="line">	<span class="keyword">int</span> modifiers = method.getModifiers();</span><br><span class="line">	<span class="comment">//如果是public，不是abstract,不是static，不是BRIDGE,不是SYNTHETIC？</span></span><br><span class="line">	<span class="keyword">if</span> ((modifiers &amp; Modifier.PUBLIC) != <span class="number">0</span> &amp;&amp; (modifiers &amp; MODIFIERS_IGNORE)</span><br><span class="line">== <span class="number">0</span>)&#123;</span><br><span class="line">	<span class="comment">//获得方法的各参数的类型数组，不管类型是否一样，都算1，比如 int string</span></span><br><span class="line">	<span class="keyword">int</span>，那么共<span class="number">3</span>个</span><br><span class="line">	Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();</span><br><span class="line">	<span class="comment">// 3.0开始，不是onEvent..开头的方法，也可以作为响应函数了</span></span><br><span class="line">	<span class="comment">// 但是必须只有一个参数（也就是监听的事件event这个参数</span></span><br><span class="line">	<span class="keyword">if</span> (parameterTypes.length == <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="comment">//获得Subscribe.class的注解，这个注解标签（定义的名称）是Subscribe。</span></span><br><span class="line">		<span class="comment">// 有@Subscribe 注解的，都是响应函数，也就是不仅能用onEvent..这四个函数了</span></span><br><span class="line">		Subscribe subscribeAnnotation = method.getAnnotation(Subscribe.class);</span><br><span class="line">		<span class="keyword">if</span> (subscribeAnnotation != <span class="keyword">null</span>) &#123; <span class="comment">// 如果\@Subscribe不为空</span></span><br><span class="line">			Class&lt;?&gt; eventType = parameterTypes[<span class="number">0</span>]; <span class="comment">//取出参数对应的类</span></span><br><span class="line">			<span class="keyword">if</span> (findState.checkAdd(method, eventType)) &#123;-----&gt;H，一系列检查看是否能为这个事件类型添加对应的方法</span><br><span class="line">				ThreadMode threadMode = subscribeAnnotation.threadMode();---&gt;</span><br><span class="line">			findState.subscriberMethods.add(<span class="keyword">new</span> SubscriberMethod(method, eventType,</span><br><span class="line">threadMode,subscribeAnnotation.priority(), subscribeAnnotation.sticky()));</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="comment">//把这个订阅方法以及相关的事件类型、响应模式等封装后，加入到findState保存的订阅者方法的list中去，这是newSubscriberMethod的起点，顺便去看看这个类</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (strictMethodVerification &amp;&amp; method.isAnnotationPresent(Subscribe.class)) &#123;</span><br><span class="line">			<span class="comment">// 如果不止一个参数类型并且.....</span></span><br><span class="line">			<span class="comment">// 获取这个方法的所在的类名，以及方法名</span></span><br><span class="line">			String methodName = method.getDeclaringClass().getName() + <span class="string">"."</span> +</span><br><span class="line">		method.getName();</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">"\@Subscribe method "</span> + methodName +</span><br><span class="line">			<span class="string">"must have exactly 1 parameter but has "</span> + parameterTypes.length);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (strictMethodVerification &amp;&amp;</span><br><span class="line">		method.isAnnotationPresent(Subscribe.class)) &#123; </span><br><span class="line">			<span class="comment">//这个elseif对应的是最外层那个public &amp;&amp; 非abstract ....</span></span><br><span class="line">			String methodName = method.getDeclaringClass().getName() + <span class="string">"."</span> + method.getName();</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(methodName + <span class="string">" is a illegal \@Subscribe method: must be public, non-static, and non-abstract"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>M.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> List&lt;SubscriberMethod&gt; <span class="title">getMethodsAndRelease</span><span class="params">(FindState findState)</span></span>&#123;</span><br><span class="line">	<span class="comment">//把findState里面的subscriberMethods列表复制过来</span></span><br><span class="line">	List&lt;SubscriberMethod&gt; subscriberMethods = <span class="keyword">new</span></span><br><span class="line">	ArrayList&lt;&gt;(findState.subscriberMethods);</span><br><span class="line">	findState.recycle(); ---&gt;N ,就是把findState的各个成员变量清空。</span><br><span class="line">	<span class="keyword">synchronized</span> (FIND_STATE_POOL) &#123;</span><br><span class="line">		<span class="comment">// 从前开始遍历，把这个findstate还给这个pool</span></span><br><span class="line">		<span class="comment">// 之前取的时候，把[i]位置置为了null，所以这里还回去时候找值为null的=</span></span><br><span class="line">		<span class="comment">// 这思路真是简单易懂- -</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; POOL_SIZE; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (FIND_STATE_POOL[i] == <span class="keyword">null</span>) &#123;</span><br><span class="line">				FIND_STATE_POOL[i] = findState;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> subscriberMethods;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>SubscriberMethodFinder.java中的一个静态内部类：<br>static class FindState {}<br>成员变量：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//subscriber的订阅方法</span></span><br><span class="line"><span class="keyword">final</span> List&lt;SubscriberMethod&gt; subscriberMethods = <span class="keyword">new</span></span><br><span class="line">ArrayList&lt;&gt;();</span><br><span class="line"><span class="comment">//订阅方法的事件类型</span></span><br><span class="line"><span class="keyword">final</span> Map&lt;Class, Object&gt; anyMethodByEventType = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="keyword">final</span> Map&lt;String, Class&gt; subscriberClassByMethodKey = <span class="keyword">new</span></span><br><span class="line">HashMap&lt;&gt;();</span><br><span class="line"><span class="keyword">final</span> StringBuilder methodKeyBuilder = <span class="keyword">new</span> StringBuilder(<span class="number">128</span>);</span><br><span class="line">Class&lt;?&gt; subscriberClass;</span><br><span class="line">Class&lt;?&gt; clazz;</span><br><span class="line"><span class="keyword">boolean</span> skipSuperClasses;</span><br><span class="line">SubscriberInfo subscriberInfo;</span><br><span class="line"><span class="comment">//主要保存了订阅类的所有订阅方法信息.</span></span><br></pre></td></tr></table></figure></p>
<p><strong>N.</strong><br><strong><em>集合类用clear()，builder用setLength(0),对象实例用null。</em></strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">recycle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	subscriberMethods.clear();</span><br><span class="line">	anyMethodByEventType.clear();</span><br><span class="line">	subscriberClassByMethodKey.clear();</span><br><span class="line">	methodKeyBuilder.setLength(<span class="number">0</span>);</span><br><span class="line">	subscriberClass = <span class="keyword">null</span>;</span><br><span class="line">	clazz = <span class="keyword">null</span>;</span><br><span class="line">	skipSuperClasses = <span class="keyword">false</span>;</span><br><span class="line">	subscriberInfo = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>F</strong>.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initForSubscriber</span><span class="params">(Class&lt;?&gt; subscriberClass)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.subscriberClass = clazz = subscriberClass;</span><br><span class="line">	skipSuperClasses = <span class="keyword">false</span>;</span><br><span class="line">	subscriberInfo = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>H</strong>.<br><strong>检查是否添加这个方法，</strong>checkAddWithMethodSignature这个方法有点迷惑…记得回来看</p>
<p>两层检查，第一层检查事件类型，第二层检查签名（方法名称+参数类型）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">checkAdd</span><span class="params">(Method method, Class&lt;?&gt; eventType)</span> </span>&#123;</span><br><span class="line">	<span class="comment">/* 2 level check: 1st level with event type only (fast), 2nd level with</span></span><br><span class="line"><span class="comment">	complete signature when required.</span></span><br><span class="line"><span class="comment">	Usually a subscriber doesn't have methods listening to the same event type.*/</span></span><br><span class="line">	<span class="comment">// map的put方法，如果之前Key没有对应的value，那么返回null，否则返回之前对应的值</span></span><br><span class="line">	Object existing = anyMethodByEventType.put(eventType, method);</span><br><span class="line">	<span class="keyword">if</span> (existing == <span class="keyword">null</span>) &#123;</span><br><span class="line">	<span class="comment">//说明之前这个key没有对应值，那么这个类型可以对应这个方法</span></span><br><span class="line">	<span class="comment">//也就是这个事件只有当前这种方法订阅了</span></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="comment">// 如果之前订阅这个事件A的method和当前想订阅事件A的method类型一样</span></span><br><span class="line">		<span class="keyword">if</span> (existing <span class="keyword">instanceof</span> Method) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!checkAddWithMethodSignature((Method) existing, eventType))-----&gt;I&#123; <span class="comment">// 如果之前的classOld是现在methodClass的子类，那么抛出异常</span></span><br><span class="line">				<span class="comment">// Paranoia check</span></span><br><span class="line">				<span class="comment">// 也就是之前存在的classOld是当前方法的子类时，不用重新订阅，需要遵循子类覆写。</span></span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// Put any non-Method object to "consume" the existing Method</span></span><br><span class="line">			<span class="comment">//没有出现父类想和子类抢同一个事件的异常，那么这个事件类型的订阅者就是this</span></span><br><span class="line">			anyMethodByEventType.put(eventType, <span class="keyword">this</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> checkAddWithMethodSignature(method, eventType);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>I.方法签名的检查</strong></p>
<p>这是一个优化，如果现在保存的是旧的子类，那么保存新的，返回true<br>否则没必要保存，直接保存旧的那个父类就行了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">checkAddWithMethodSignature</span><span class="params">(Method method, Class&lt;?&gt; eventType)</span> </span>&#123;</span><br><span class="line">	methodKeyBuilder.setLength(<span class="number">0</span>);</span><br><span class="line">	methodKeyBuilder.append(method.getName()); <span class="comment">//方法名</span></span><br><span class="line">	methodKeyBuilder.append(<span class="string">'&gt;'</span>).append(eventType.getName());</span><br><span class="line">	<span class="comment">// 类名即事件类型名称</span></span><br><span class="line">	<span class="comment">// 用这两个值当做key</span></span><br><span class="line">	String methodKey = methodKeyBuilder.toString();</span><br><span class="line">	<span class="comment">// 得到这个方法所对应的类对象</span></span><br><span class="line">	Class&lt;?&gt; methodClass = method.getDeclaringClass();</span><br><span class="line">	Class&lt;?&gt; methodClassOld = subscriberClassByMethodKey.put(methodKey, methodClass);</span><br><span class="line">	<span class="comment">//methodClassOld为空，或者是父类</span></span><br><span class="line">	<span class="comment">//methodClassOld为空时：说明这个方法签名（methodKey=方法名+事件类型)之前没有彼此对应。那么允许为这个方法添加订阅事件，返回true</span></span><br><span class="line">	<span class="keyword">if</span> (methodClassOld == <span class="keyword">null</span> ||</span><br><span class="line">	methodClassOld.isAssignableFrom(methodClass)) &#123;</span><br><span class="line">		<span class="comment">//这个函数，Class.isAssignableFrom()是用来判断一个类Class1是否Class2的superClass或者superInterface，或者是相同类或者接口。</span></span><br><span class="line">		格式为： Class1.isAssignableFrom(Class2)</span><br><span class="line">		这是判断类之间的关系，<span class="keyword">instanceof</span>是判断实例之间的关系</span><br><span class="line">		<span class="comment">// Only add if not already found in a sub class</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// Revert the put, old class is further down the class hierarchy</span></span><br><span class="line">		<span class="comment">/*methodClassOld不为空，并且它是新的methodClass的子类，把methodClassOld放回去并且返回false，**代表子类classOld覆写了父类的订阅方法，让子类method的订阅方法订阅这个事件而不是父类。*/</span></span><br><span class="line">		subscriberClassByMethodKey.put(methodKey,methodClassOld);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>L.</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">moveToSuperclass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (skipSuperClasses) &#123;</span><br><span class="line">		clazz = <span class="keyword">null</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		clazz = clazz.getSuperclass();</span><br><span class="line">		String clazzName = clazz.getName();</span><br><span class="line">		<span class="comment">/* Skip system classes, this just degrades performance. */</span></span><br><span class="line">		<span class="comment">//跳过系统类，也就是以java, javax,android开头的类</span></span><br><span class="line">		<span class="keyword">if</span> (clazzName.startsWith(<span class="string">"java."</span>) ||clazzName.startsWith(<span class="string">"javax."</span>) || clazzName.startsWith(<span class="string">"android."</span>)) &#123;</span><br><span class="line">			clazz = <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>③注解类\@Subscribe</strong></p>
<p><strong>J.</strong></p>
<p>终于遇到注解了！！看别人的分析，注解中应该还有<br>String[] actions() default {};  </p>
<p>这个版本好像没有了！！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.*RUNTIME*)</span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.*METHOD*&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Subscribe &#123;</span><br><span class="line">	<span class="function">ThreadMode <span class="title">threadMode</span><span class="params">()</span> <span class="keyword">default</span></span></span><br><span class="line"><span class="function">	ThreadMode.POSTING</span>;---&gt;K</span><br><span class="line">	<span class="comment">/*如果是真，如果有订阅者在这个sticky事件发布后才订阅这个事件，那么依然会把最近的这个事件类型的sticky事件发送给这个subscriber*/</span></span><br><span class="line">	<span class="comment">/* If true, delivers the most recent sticky event (posted with &#123;\@link EventBus #postSticky(Object)&#125;) to this subscriber (if event available).*/</span></span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">sticky</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line">	<span class="comment">/* 对于同一个传送线程，优先级高的订阅者更快地接收到事件</span></span><br><span class="line"><span class="comment">	Subscriber priority to influence the order of event delivery.*/</span></span><br><span class="line">	<span class="comment">/* Within the same delivery thread (&#123;\@link ThreadMode&#125;), higher priority subscribers will receive events before*/</span> others with a lower priority. The <span class="keyword">default</span> priority is <span class="number">0</span>. Note: the priority</span><br><span class="line">	does \*NOT\* affect the order of delivery among subscribers with different &#123;\<span class="meta">@link</span> ThreadMode&#125;s! */</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">priority</span><span class="params">()</span> <span class="keyword">default</span> 0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>K.</strong><br>public enum ThreadMode{}<br>枚举类型，共四种：<br><em>POSTING</em>：订阅者的响应函数直接由发起post事件的线程执行，如果发起post的是主线程，那么响应函数不应该是耗时操作。如果要执行的task耗时很短，建议使用这种模式。<br><em>MAIN</em>: 订阅者的响应函数由主线程执行。如果posting<br>thread是主线程，事件响应函数将会直接被这个线程call。<br><em>BACKGROUND</em>：订阅者的响应函数由后台线程执行，如果posting<br>thread不是主线程，事件响应函数将会直接被这个线程call。如果posting<br>thread是主线程，那么eventBus将会使用一个单独的single后台线程，这个线程会按序执行这些响应函数。但还是不建议有很耗时的操作，以避免阻塞这个后台线程。<br><em>ASYNC：</em><br>订阅者的响应函数由一个独立的线程去执行，这个线程不是主线程，也不是posting<br>thread。如果有比较耗时的操作，建议用这种模式，比如网络访问。EventBus使用了线程池来重用线程进行异步操作。</p>
<p><strong>SubscriberMethod.JAVA</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubscriberMethod</span> </span>&#123;</span><br><span class="line">	<span class="keyword">final</span> Method method;</span><br><span class="line">	<span class="keyword">final</span> ThreadMode threadMode;</span><br><span class="line">	<span class="keyword">final</span> Class&lt;?&gt; eventType;</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">int</span> priority;</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">boolean</span> sticky;</span><br><span class="line">	<span class="comment">/* Used for efficient comparison */</span></span><br><span class="line">	String methodString;</span><br><span class="line">....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>构造函数就是对前五个变量进行赋值，很好理解。</p>
<p><strong>AbstractSubscriberInfo.JAVA，实现SubscriberInfo接口</strong><br>public abstract class AbstractSubscriberInfo implements SubscriberInfo<br>{}<br>private final Class subscriberClass;<br>private final Class&lt;? extends SubscriberInfo&gt;<br>superSubscriberInfoClass;<br>private final boolean shouldCheckSuperclass;<br>主要是三个成员变量：<br>订阅者对应的类；订阅者信息的子类（这是什么鬼…); 检查超类的布尔变量</p>
<p><strong>P.</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SubscriberInfo <span class="title">getSuperSubscriberInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 如果没有信息子类，直接返回Null</span></span><br><span class="line">	<span class="keyword">if</span>(superSubscriberInfoClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> superSubscriberInfoClass.newInstance();</span><br><span class="line">	&#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">	&#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>S.</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">simpleSubscriberInfo中的getSubscriberMethods()会调用该函数：</span><br><span class="line"><span class="function"><span class="keyword">protected</span> SubscriberMethod <span class="title">createSubscriberMethod</span><span class="params">(String methodName, Class&lt;?&gt; eventType, ThreadMode threadMode,<span class="keyword">int</span> priority, <span class="keyword">boolean</span> sticky)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		Method method = subscriberClass.getDeclaredMethod(methodName, eventType);</span><br><span class="line">		<span class="comment">//通过方法名称，和方法参数列表（其实就是方法签名）从class中找到类</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> SubscriberMethod(method, eventType, threadMode, priority, sticky); <span class="comment">//然后构造subscriber方法，似乎比第一种通过反射的方式简单</span></span><br><span class="line">	&#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(**<span class="string">"Could not find subscriber method in "</span> + subscriberClass + <span class="string">". Maybe a missing ProGuard rule?"</span>, e);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>**⑥SimpleSubscriberInfo.JAVA<br>又继承了AbstractSubscriberInfo（就不能一次写完吗…)<br>一个成员变量：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> SubscriberMethodInfo[] methodInfos;</span><br><span class="line"><span class="comment">// 存储了订阅者所有的方法信息，用数组保存。</span></span><br></pre></td></tr></table></figure></p>
<p><strong>R.</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> SubscriberMethod[] getSubscriberMethods() &#123;</span><br><span class="line">	<span class="keyword">int</span> length = methodInfos.length;</span><br><span class="line">	<span class="comment">//建立一个方法数组（不是方法信息）</span></span><br><span class="line">	SubscriberMethod[] methods = <span class="keyword">new</span> SubscriberMethod[length];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">		<span class="comment">//取出方法信息	</span></span><br><span class="line">		SubscriberMethodInfo info = methodInfos[i];</span><br><span class="line">		<span class="comment">//根据信息建立方法（调用父类的createSubscriberMethod）</span></span><br><span class="line">		methods[i] = createSubscriberMethod(info.methodName, info.eventType, info.threadMode, info.priority, info.sticky);----&gt;S</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> methods; <span class="comment">//根据信息构造了方法数组，返回去。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>⑦Subscription.JAVA</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Subscription</span> </span>&#123;&#125;</span><br><span class="line"><span class="comment">//三个成员变量：</span></span><br><span class="line"><span class="keyword">final</span> Object subscriber; <span class="comment">//注册的订阅者</span></span><br><span class="line"><span class="keyword">final</span> SubscriberMethod subscriberMethod; <span class="comment">//订阅者响应事件的函数</span></span><br><span class="line"><span class="comment">/*Becomes false as soon as &#123;@link EventBus#unregister(Object)&#125; is called, which is checked by queued event delivery &#123;@link EventBus#invokeSubscriber(PendingPost)&#125; to prevent race conditions.*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">boolean</span> active; <span class="comment">// unrigester之后为false</span></span><br></pre></td></tr></table></figure></p>
<p><strong>1B.</strong></p>
<p>构造函数就是为这三个变量赋值：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Subscription(Object subscriber, SubscriberMethod subscriberMethod)&#123;</span><br><span class="line">	<span class="keyword">this</span>.subscriber = subscriber;</span><br><span class="line">	<span class="keyword">this</span>.subscriberMethod = subscriberMethod;</span><br><span class="line">	active = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>⑧HandlerPoster.JAVA</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HandlerPoster</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;&#125;</span><br><span class="line">	<span class="comment">//四个成员变量：</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> PendingPostQueue queue;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> maxMillisInsideHandleMessage;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> EventBus eventBus;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">boolean</span> handlerActive;</span><br></pre></td></tr></table></figure>
<p><strong>1F.</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Subscription subscription, Object event)</span> </span>&#123;</span><br><span class="line">	PendingPost pendingPost = PendingPost.obtainPendingPost(subscription, event);---&gt; <span class="number">1</span>G,根据订阅信息和event取出pendingPost，</span><br><span class="line">		<span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">			queue.enqueue(pendingPost); <span class="comment">//插入等待队列</span></span><br><span class="line">			<span class="keyword">if</span> (!handlerActive) &#123;</span><br><span class="line">			<span class="comment">//如果handler不活跃，就打开它（可能之前没有msg给handler处理）直接发送消息进行处理</span></span><br><span class="line">				handlerActive = <span class="keyword">true</span>;</span><br><span class="line">			<span class="keyword">if</span> (!sendMessage(obtainMessage())) &#123; </span><br><span class="line">			<span class="comment">//handler发送msg出去----&gt;1H</span></span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(**<span class="string">"Could not send handler message"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>1H.消息处理函数</strong>，但是handleMessage有三个级别,handler的是最不优先的- -</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">boolean</span> rescheduled = <span class="keyword">false</span>;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="keyword">long</span> started = SystemClock.uptimeMillis();</span><br><span class="line">		<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">			PendingPost pendingPost = queue.poll();</span><br><span class="line">			<span class="comment">//移出并返回队头，如果queue是空的，就返回null，不会抛异常</span></span><br><span class="line">			<span class="keyword">if</span> (pendingPost == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="comment">//如果队列为空</span></span><br><span class="line">				<span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123; <span class="comment">//锁住当前handler</span></span><br><span class="line">				<span class="comment">// Check again, this time in synchronized*</span></span><br><span class="line">					pendingPost = queue.poll(); <span class="comment">//再取？</span></span><br><span class="line">					<span class="keyword">if</span> (pendingPost == <span class="keyword">null</span>) &#123;</span><br><span class="line">					<span class="comment">//还是空，那么这个handler没事干了</span></span><br><span class="line">						handlerActive = <span class="keyword">false</span>;</span><br><span class="line">						<span class="keyword">return</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="comment">//又调用eventBus的invokeSubscriber函数，1E已经分析了。利用反射调用订阅方法。</span></span><br><span class="line">		eventBus.invokeSubscriber(pendingPost);----&gt;不是<span class="number">1</span>E！参数不同！<span class="number">1</span>K,不过最终还是可能调用<span class="number">1</span>E</span><br><span class="line">		<span class="keyword">long</span> timeInMethod = SystemClock.uptimeMillis() - started;</span><br><span class="line">		<span class="comment">//如果执行method的时间大于了handleMsg规定的时间</span></span><br><span class="line">		<span class="keyword">if</span> (timeInMethod &gt;= maxMillisInsideHandleMessage) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!sendMessage(obtainMessage())) &#123; <span class="comment">//又发送出去执行？？</span></span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">"Could not send handler message"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			rescheduled = <span class="keyword">true</span>;<span class="comment">// 重新调度了</span></span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">	handlerActive = rescheduled; <span class="comment">//如果发生了重新调度，handlerActive为真</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>⑨PendingPost.JAVA</strong></p>
<p>四个成员变量：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> List&lt;PendingPost&gt; pendingPostPool = <span class="keyword">new</span></span><br><span class="line">ArrayList&lt;PendingPost&gt;();</span><br><span class="line">Object event;</span><br><span class="line">Subscription subscription;</span><br><span class="line">PendingPost next;</span><br></pre></td></tr></table></figure></p>
<p>一个构造函数：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">PendingPost</span><span class="params">(Object event, Subscription subscription)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.event = event;</span><br><span class="line">	<span class="keyword">this</span>.subscription = subscription;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>1G.</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> PendingPost <span class="title">obtainPendingPost</span><span class="params">(Subscription subscription, Object event)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">synchronized</span> (pendingPostPool) &#123;</span><br><span class="line">		<span class="keyword">int</span> size = pendingPostPool.size();</span><br><span class="line">		<span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="comment">//取出postPool中最后一个pendingPost</span></span><br><span class="line">			PendingPost pendingPost = pendingPostPool.remove(size - <span class="number">1</span>);</span><br><span class="line">			pendingPost.event = event;</span><br><span class="line">			pendingPost.subscription = subscription;</span><br><span class="line">			pendingPost.next = <span class="keyword">null</span>;</span><br><span class="line">			<span class="keyword">return</span> pendingPost;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//如果pengdingPostPool为空，直接用事件和订阅信息new一个新的pendingPost</span></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> PendingPost(event, subscription);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>1L.</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">releasePendingPost</span><span class="params">(PendingPost pendingPost)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//将pendingPost的各变量置为null</span></span><br><span class="line">	pendingPost.event = <span class="keyword">null</span>;</span><br><span class="line">	pendingPost.subscription = <span class="keyword">null</span>;</span><br><span class="line">	pendingPost.next = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">synchronized</span> (pendingPostPool) &#123;</span><br><span class="line">		<span class="comment">/*锁住postPool，把这个pendingPost放进去= =话说，为什么不直接pendingPost=null...恩，如果里面的这三个变量不为null，那么应该无法回收，但是也可以先把变量置为null,再把pendingPost=null</span></span><br><span class="line"><span class="comment">		但是这里直接把变量置为null然后重用？ 所以这是传说中的对象池...恩</span></span><br><span class="line"><span class="comment">		// Don't let the pool grow indefinitely</span></span><br><span class="line"><span class="comment">		if (pendingPostPool.size() &lt; 10000) &#123;</span></span><br><span class="line"><span class="comment">			pendingPostPool.add(pendingPost);</span></span><br><span class="line"><span class="comment">		&#125;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br></pre></td></tr></table></figure>
<p><strong>⑩BackgroundPoster.java</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">BackgroundPoster</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;&#125;</span><br><span class="line"><span class="comment">//是一个线程,三个成员变量：</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> PendingPostQueue queue; <span class="comment">//等到这个线程处理的事件队列</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> EventBus eventBus;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> executorRunning;</span><br></pre></td></tr></table></figure>
<p>构造函数：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BackgroundPoster(EventBus eventBus) &#123;</span><br><span class="line">	<span class="keyword">this</span>.eventBus = eventBus;</span><br><span class="line">	queue = <span class="keyword">new</span> PendingPostQueue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>持有了eventBus的引用，也许有内存泄漏？</p>
<p><strong>1I.</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Subscription subscription, Object event)</span> </span>&#123;</span><br><span class="line">PendingPost pendingPost = PendingPost.obtainPendingPost(subscription, event);</span><br><span class="line"><span class="comment">//根据subscription和要发布的事件构造pendingPost</span></span><br><span class="line">	<span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">		queue.enqueue(pendingPost); <span class="comment">//入队</span></span><br><span class="line">		<span class="keyword">if</span> (!executorRunning) &#123; <span class="comment">//这个runnable此时没有在执行</span></span><br><span class="line">			executorRunning = <span class="keyword">true</span>;<span class="comment">//那么可以利用起来了</span></span><br><span class="line">			<span class="comment">//eventBus的线程池执行当前runnable</span></span><br><span class="line">			eventBus.getExecutorService().execute(**<span class="keyword">this</span>**);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>⑪AsyncPoster.JAVA</strong></p>
<p>三个成员变量：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> PendingPostQueue queue;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> EventBus eventBus;</span><br></pre></td></tr></table></figure></p>
<p>构造函数：持有了eventBus的引用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">AsyncPoster(EventBus eventBus) &#123;</span><br><span class="line">	<span class="keyword">this</span>.eventBus = eventBus;</span><br><span class="line">	queue = <span class="keyword">new</span> PendingPostQueue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>1J.</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造了pendingPost后直接进入队列，执行让eventBus的线程池执行它= =</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Subscription subscription, Object event)</span> </span>&#123;</span><br><span class="line">	PendingPost pendingPost = PendingPost.obtainPendingPost(subscription, event);</span><br><span class="line">	queue.enqueue(pendingPost);</span><br><span class="line">	eventBus.getExecutorService().execute(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//从队列里面取出pendingPost</span></span><br><span class="line">	PendingPost pendingPost = queue.poll();</span><br><span class="line">	<span class="keyword">if</span>(pendingPost == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"No pending post available"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*1E分析过，反射机制执行subscription里面的method（打脸，这不是1E</span></span><br><span class="line"><span class="comment">	eventBus.invokeSubscriber(pendingPost);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br></pre></td></tr></table></figure>
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/eventbus/" rel="tag"># eventbus</a>
          
            <a href="/tags/事件总线/" rel="tag"># 事件总线</a>
          
            <a href="/tags/观察者模式/" rel="tag"># 观察者模式</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/09/07/SparseArray/" rel="next" title="SparseArray源码解析">
                <i class="fa fa-chevron-left"></i> SparseArray源码解析
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/09/11/查找算法/" rel="prev" title="常见查找算法总结">
                常见查找算法总结 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.jpg"
                alt="Ke Yu" />
            
              <p class="site-author-name" itemprop="name">Ke Yu</p>
              <p class="site-description motion-element" itemprop="description">Keep moving. Don't settle.</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">34</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">7</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">47</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Ke Yu</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
